[{"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\index.js":"1","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\ExternalConfigurationHandler.js":"2","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\App.js":"3","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\config.js":"4","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\rosWebsocket.js":"5","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\interceptor.js":"6","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\LoaderAlt\\LoaderAlt.js":"7","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\index.js":"8","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\actionTypes.js":"9","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Popup\\Popup.js":"10","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\OutputTabs\\OutputTabs.js":"11","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\ActionButtons\\ActionButtons.js":"12","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Error\\Error.js":"13","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\GlobalMessage\\GlobalMessage.js":"14","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\MapContainer\\MapContainer.js":"15","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\FlightTelemetry\\FlightTelemetry.js":"16","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Clock\\Clock.js":"17","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\ContextMenu\\ContextMenu.js":"18","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Video\\Video.js":"19","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\index.js":"20","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\mapReducer.js":"21","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\videoReducer.js":"22","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\outputReducer.js":"23","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\layoutReducer.js":"24","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Popup\\PopupChildren.js":"25","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\SwitchMapForm\\SwitchMapForm.js":"26","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\Slider\\Slider.js":"27","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\outputActions.js":"28","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\mapActions.js":"29","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\videoActions.js":"30","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\layoutActions.js":"31","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\GoToLocationForm\\GoToLocationForm.js":"32","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\RadioGroup\\RadioGroup.js":"33","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\Radio\\Radio.js":"34","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\utils\\imageUtils.js":"35","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\Input\\Input.js":"36","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\services\\index.js":"37"},{"size":1513,"mtime":1614788451206,"results":"38","hashOfConfig":"39"},{"size":322,"mtime":1614504850000,"results":"40","hashOfConfig":"39"},{"size":5791,"mtime":1614788449499,"results":"41","hashOfConfig":"39"},{"size":1333,"mtime":1615985107505,"results":"42","hashOfConfig":"39"},{"size":2341,"mtime":1615283528881,"results":"43","hashOfConfig":"39"},{"size":656,"mtime":1614504850000,"results":"44","hashOfConfig":"39"},{"size":756,"mtime":1614504850000,"results":"45","hashOfConfig":"39"},{"size":381,"mtime":1614504850000,"results":"46","hashOfConfig":"39"},{"size":1758,"mtime":1616070304245,"results":"47","hashOfConfig":"39"},{"size":4980,"mtime":1614504850000,"results":"48","hashOfConfig":"39"},{"size":7483,"mtime":1616676822624,"results":"49","hashOfConfig":"39"},{"size":3269,"mtime":1614504850000,"results":"50","hashOfConfig":"39"},{"size":205,"mtime":1614504850000,"results":"51","hashOfConfig":"39"},{"size":1878,"mtime":1614504850000,"results":"52","hashOfConfig":"39"},{"size":83168,"mtime":1616677304195,"results":"53","hashOfConfig":"39"},{"size":642,"mtime":1614504850000,"results":"54","hashOfConfig":"39"},{"size":943,"mtime":1614504850000,"results":"55","hashOfConfig":"39"},{"size":2973,"mtime":1614504850000,"results":"56","hashOfConfig":"39"},{"size":7798,"mtime":1616674366768,"results":"57","hashOfConfig":"39"},{"size":283,"mtime":1614504850000,"results":"58","hashOfConfig":"39"},{"size":802,"mtime":1616675149811,"results":"59","hashOfConfig":"39"},{"size":534,"mtime":1614504850000,"results":"60","hashOfConfig":"39"},{"size":814,"mtime":1615989929020,"results":"61","hashOfConfig":"39"},{"size":2277,"mtime":1614504850000,"results":"62","hashOfConfig":"39"},{"size":153,"mtime":1614504850000,"results":"63","hashOfConfig":"39"},{"size":2886,"mtime":1614504850000,"results":"64","hashOfConfig":"39"},{"size":2651,"mtime":1616331217119,"results":"65","hashOfConfig":"39"},{"size":166,"mtime":1616676822616,"results":"66","hashOfConfig":"39"},{"size":1502,"mtime":1616686059275,"results":"67","hashOfConfig":"39"},{"size":6977,"mtime":1616674813967,"results":"68","hashOfConfig":"39"},{"size":407,"mtime":1614504850000,"results":"69","hashOfConfig":"39"},{"size":1306,"mtime":1614504850000,"results":"70","hashOfConfig":"39"},{"size":941,"mtime":1614504850000,"results":"71","hashOfConfig":"39"},{"size":1117,"mtime":1614504850000,"results":"72","hashOfConfig":"39"},{"size":804,"mtime":1614504850000,"results":"73","hashOfConfig":"39"},{"size":2685,"mtime":1614504850000,"results":"74","hashOfConfig":"39"},{"size":3224,"mtime":1616685625497,"results":"75","hashOfConfig":"39"},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},"yrq1ot",{"filePath":"79","messages":"80","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"83","usedDeprecatedRules":"78"},{"filePath":"84","messages":"85","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"88","usedDeprecatedRules":"78"},{"filePath":"89","messages":"90","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"91","messages":"92","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"93","messages":"94","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"95","messages":"96","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"97","messages":"98","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"78"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"78"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"109","usedDeprecatedRules":"78"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":59,"fixableErrorCount":0,"fixableWarningCount":7,"source":"112","usedDeprecatedRules":"78"},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"119","messages":"120","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"121","usedDeprecatedRules":"78"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"124","messages":"125","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"126","messages":"127","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"128","messages":"129","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"130","messages":"131","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"132","messages":"133","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"134","messages":"135","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"136","usedDeprecatedRules":"78"},{"filePath":"137","messages":"138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"139","messages":"140","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"141","usedDeprecatedRules":"78"},{"filePath":"142","messages":"143","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"144","messages":"145","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"146","usedDeprecatedRules":"78"},{"filePath":"147","messages":"148","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"149","messages":"150","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"151","messages":"152","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"153","usedDeprecatedRules":"78"},{"filePath":"154","messages":"155","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"156","messages":"157","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"158","messages":"159","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},{"filePath":"160","messages":"161","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"78"},"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\index.js",[],["162","163"],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\ExternalConfigurationHandler.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\App.js",["164"],"import React, { PureComponent, Component } from 'react';\nimport logo from '../src/assets/images/newLogo.svg';\nimport classNames from './App.module.css';\nimport Loader from './components/LoaderAlt/LoaderAlt';\nimport Clock from './components/Clock/Clock';\nimport Popup from './components/Popup/Popup';\nimport FlightTelemetry from './components/FlightTelemetry/FlightTelemetry';\nimport Error from './components/Error/Error';\nimport MapContainer from './components/MapContainer/MapContainer';\nimport OutputTabs from './components/OutputTabs/OutputTabs';\nimport Video from './components/Video/Video';\nimport ActionButtons from './components/ActionButtons/ActionButtons';\nimport GlobalMessage from './components/GlobalMessage/GlobalMessage';\nimport actionTypes from './store/actions/actionTypes';\nimport { connect } from 'react-redux';\nimport ContextMenu from './components/ContextMenu/ContextMenu';\nimport externalConfig from './ExternalConfigurationHandler';\n\n\nclass App extends Component {\n\n    disableZoomInTouchScreen = e => {\n        if (e.touches.length > 1) {\n            e.preventDefault();\n        }\n    }\n\n    componentDidMount() {\n        window.MapCore.SetStartCallbackFunction(this.props.setMapCoreSDKLoadedFlag);\n\n        const defaultGroup = externalConfig.getConfiguration().streamingLayers[0];\n        this.props.setMapToShow(defaultGroup);\n\n          //Disable zoom in touch\n        window.addEventListener('touchstart', this.disableZoomInTouchScreen, {passive: false});\n    }\n\n    componentWillUnmount() {\n        window.removeEventListener('touchstart', this.disableZoomInTouchScreen);\n    }\n\n    closeErrorPopup = () => {\n        this.setState({\n            generalErrorMessage: false,\n        });\n    };\n\n    getGeneralErrorPopup() {\n        if (false) {\n            return (\n                <Popup\n                    buttonOk='OK'\n                    header={''}\n                    hideXButton\n                    onOk={this.closeErrorPopup}>\n                    <Error errorMsg={''} />\n                </Popup>\n            );\n        }\n        return null;\n    }\n\n    getClock() {\n        return <Clock />;\n    }\n\n    getMainHeader() {\n        return (\n            <header className={classNames.AppHeader}>\n                <img src={logo} alt='logo' />\n                <div className={classNames.HeaderLeftWrapper}>                                        \n                    <span className={classNames.HeaderItem}>\n                        <span className={`${classNames.Icon} ${classNames.PositionIcon}`}></span>\n                        <span className={classNames.LongLatWrapper}>\n                            <span>\n                                <span className={classNames.lonLatLabel}>lat:</span>\n                                <span className={classNames.lonLatValue}>32.35249</span>\n                            </span>\n                            <span>\n                                <span className={classNames.lonLatLabel}>long:</span>\n                                <span className={classNames.lonLatValue}>34.87586</span>\n                            </span>\n                        </span>\n                    </span>\n                    <span className={classNames.HeaderItem}><span className={`${classNames.Icon} ${classNames.WifiIcon}`}></span></span>\n                    <span className={classNames.HeaderItem}>\n                        <span className={`${classNames.Icon} ${classNames.BatteryIcon}`}></span>\n                        <span className={classNames.BatteryValue}>59%</span>\n                    </span>\n                    <div className={classNames.RightHeader}>{this.getClock()}</div>\n                </div>\n            </header>\n        );\n    }\n\n    getMainLeftPane() {\n        return <MapContainer />;\n    }\n\n    getMainRightPane() {\n        return (\n            <div className={classNames.RightPaneWrapper}>\n                <div className={classNames.RightPaneWrapperItem}>\n                    <Video />\n                </div>\n                <div className={classNames.RightPaneWrapperItem}>\n                    <OutputTabs />\n                </div>\n            </div>\n        );\n    }\n\n    getMainContent() {\n        return (\n            <div className={classNames.MainContentWrapper}>\n                <div className={`${classNames.Split} ${classNames.Left}`}>\n                    {this.getMainLeftPane()}\n                </div>\n                <div className={`${classNames.Split} ${classNames.Right}`}>\n                    {this.getMainRightPane()}\n                </div>\n            </div>\n        );\n    }\n\n    getActionButtons() {\n        return <ActionButtons/>        \n    }\n\n    render() {\n        if (this.props.isLoading) {\n            return <Loader loadingMessage={'initializing...'} />;\n        }\n        return (\n            <div className={classNames.App}>\n                <GlobalMessage />\n                {this.props.popupDetails ? <Popup popupDetails={this.props.popupDetails}/> : null}\n                <FlightTelemetry/>\n                {this.props.contextMenu ? <ContextMenu contextMenu={this.props.contextMenu}/> : null}\n                {this.getActionButtons()}\n                {this.getGeneralErrorPopup()}\n                {this.getMainHeader()}\n                {this.getMainContent()}\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = state => {\n    return {\n      contextMenu: state.layout.contextMenu,\n      popupDetails: state.layout.popupDetails,\n    }\n  };\n\nconst mapDispachToProps = (dispatch) => {\n    return {\n        setMapCoreSDKLoadedFlag: () => dispatch({type: actionTypes.SET_MAPCORE_SDK_LOADED_FLAG}),\n        setMapToShow: groupNode => dispatch({type: actionTypes.SET_MAP_TO_SHOW, payload: groupNode})\n    };\n};\n\nexport default connect(mapStateToProps, mapDispachToProps)(App);\n","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\config.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\rosWebsocket.js",["165"],"import config, { logSeverities } from './config';\nimport actionTypes from './store/actions/actionTypes';\nimport actions from './store/actions';\nimport externalConfig from './ExternalConfigurationHandler';\nimport {store} from './index';\n\n\nclass RosWebSocket {\n\n    rosWebSocket = null;\n    RECONNECT_TIMEOUT = 2000;\n\n\n    register() {\n        try {\n            const { ROS_BE_PROTOCOL, BE_IP, ROS_BE_PORT } = externalConfig.getConfiguration();\n            const url =  `${ROS_BE_PROTOCOL}://${BE_IP}:${ROS_BE_PORT}`;\n            store.dispatch({type: actionTypes.SHOW_GLOBAL_MESSAGE, payload: {text: `Trying to connect ros websocket on: ${url}`, type:logSeverities.info}})\n            store.dispatch(actions.showGlobalMessage({text: `Trying to connect ros websocket on: ${url}`, type:logSeverities.info}))\n            console.log(\"Trying to connect ros websocket\");\n            this.rosWebSocket = new window.ROSLIB.Ros({url});\n    \n            this.rosWebSocket.on('connection', () => {\n                store.dispatch(actions.showGlobalMessage({text: `Connected successfuly to ros websocket`, type:logSeverities.success, isRemoved: true}))                \n                store.dispatch({type: actionTypes.ROSS_WEBSOCKET_CONNECTION_SUCCESS});\n            });\n    \n            this.rosWebSocket.on('error', error => {                \n                store.dispatch(actions.showGlobalMessage({text: `Failed to connect ros websocket on: ${url}`, type:logSeverities.error}));\n                store.dispatch({type: actionTypes.ROSS_WEBSOCKET_CONNECTION_FAILED});\n                console.log(error);\n            });\n    \n            this.rosWebSocket.on('close', () => {\n                store.dispatch(actions.showGlobalMessage({text: `Connection to ros websocket on: ${url} closed`, type:logSeverities.error}))\n                store.dispatch({type: actionTypes.ROSS_WEBSOCKET_CONNECTION_CLOSED});\n                this.reRegister();\n            });\n        } catch (e) {\n            console.log(\"RosWebSocket.register() Exception:\" + e);\n        }\n    }\n\n    reRegister = () => {\n        setTimeout( () => this.register() , this.RECONNECT_TIMEOUT);\n    }\n\n    getRosWebsocketObject() {\n        if (this.rosWebSocket == null) {\n            this.register();\n        }\n        return this.rosWebSocket;\n    }\n}\n\nexport default new RosWebSocket();\n\n\n\n","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\interceptor.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\LoaderAlt\\LoaderAlt.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\index.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\actionTypes.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Popup\\Popup.js",["166","167"],"import React, { PureComponent } from 'react';\nimport cn from './Popup.module.css';\nimport closeImg from '../../assets/images/close.svg';\nimport PopupChildren from './PopupChildren';\nimport { connect } from 'react-redux';\nimport actionTypes from '../../store/actions/actionTypes';\n\nclass Popup extends PureComponent {\n    EscKey = 27;\n    EnterKey = 13;\n\n    componentDidMount() {\n        document.addEventListener('keydown', this.handleKeyDown);\n    }\n    \n    componentWillUnmount() {\n        document.removeEventListener('keydown', this.handleKeyDown);\n    }\n\n    handleKeyDown = (e) =>{             \n        if (e.keyCode === this.EscKey){\n            this.closePopup();   \n        } else if ((e.keyCode === this.EnterKey) && this.props.popupDetails.primayButton && this.props.popupDetails.primayButton.callback) {\n            this.props.popupDetails.primayButton.callback();\n            this.closePopup();\n        }\n    }\n\n    closePopup = () => {        \n        if (this.props.popupDetails && this.props.popupDetails.onCloseButtonClick) {\n            this.props.popupDetails.onCloseButtonClick();\n        }\n        this.props.hidePopup();\n    }\n\n    onCloseBtnClick = e => {\n        e.preventDefault();\n        this.closePopup()\n    }\n\n    getXBtn() {\n        return (\n            this.props.hideXButton ? null :\n                <a className={cn.Close} href=\"#\" onClick={this.onCloseBtnClick}>\n                    <img className={cn.closeBtn} src={closeImg}/>\n                </a> \n        );\n    }\n    closePopup() {\n        if (this.props.popupDetails && this.props.popupDetails.onCloseButtonClick) {\n            this.props.popupDetails.onCloseButtonClick();\n        }\n        this.props.hidePopup();\n    }\n\n    onPrimaryBtnClick = e => {\n        e.preventDefault();\n        if (this.props.popupDetails.primayButton && this.props.popupDetails.primayButton.callback) {\n            this.props.popupDetails.primayButton.callback();\n        }\n        this.closePopup();\n    }\n\n    onSecondaryBtnClick = e => {\n        e.preventDefault();\n        if (this.props.popupDetails.secondaryButton && this.props.popupDetails.secondaryButton.callback) {\n            this.props.popupDetails.secondaryButton.callback();\n        }\n        this.closePopup();\n    }\n\n    renderButtons() {\n        //default primary button in case no other button was injected as props\n        let primaryButton = <button type=\"button\" className={`${cn.Btn} ${cn.BtnPrimary}`} onClick={this.onPrimaryBtnClick}>Close</button>;\n        let secondaryButton = null;\n\n        if (this.props.popupDetails.primayButton) {\n            primaryButton = <button type=\"button\" className={`${cn.FormButton} ${cn.Apply}`} onClick={this.onPrimaryBtnClick}>{this.props.popupDetails.primayButton.title}</button>;\n        }\n\n        if (this.props.popupDetails.secondaryButton) {\n            secondaryButton = <button type=\"button\" className={`${cn.FormButton}`} onClick={this.onSecondaryBtnClick}>{this.props.popupDetails.secondaryButton.title}</button>\n        }\n\n        return (\n            <>\n                {secondaryButton}\n                {primaryButton}\n            </>\n        )\n    }\n\n    getFooter() {\n        return (\n\n            <div className={cn.PopupFooter}>\n                <div>         \n                    {this.renderButtons()}\n                </div>\n            </div>\n        );\n    }\n\n    getHeader() {\n        return (\n            <div className={cn.PopupHeader}>\n                <div className={cn.PopupHeaderWrapper}>\n                    <h2 className={cn.h2}>{this.props.popupDetails.title}</h2>                                            \n                    {this.getXBtn()}                    \n                </div>\n            </div>\n        );\n    }\n\n    renderChild() {\n        const Child = PopupChildren[this.props.popupDetails.modalChild];\n        return <Child {...this.props.popupDetails.modalChildProps}/>;\n    }\n\n    getBody() {\n        const noBodyOverflowClass = this.props.noBodyOverflow ? cn.NoBodyOverFlow : '';\n\n        const body =\n            <div className={`${cn.PopupBody} ${noBodyOverflowClass}`}>\n                {this.props.popupDetails.modalChild ? this.renderChild() : null}\n            </div>;\n        return body;\n    }\n\n    render() {\n        if (!this.props.popupDetails) return null;\n        \n        const size = this.props.popupDetails.size ? cn[this.props.popupDetails.size] : '';\n        return (\n            <div className={cn.Overlay}>\n                <div className={`${cn.Popup} ${size}`}>\n                    {this.getHeader()}\n                    {this.getBody()}\n                    {this.getFooter()}\n                </div>\n            </div>\n        )           \n    }\n}\n\nconst mapStateToProps = state => {\n    return {                \n    }\n};\n\nconst mapDispachToProps = dispatch => {\n    return {\n      hidePopup: () => dispatch({type: actionTypes.HIDE_POPUP})\n    }\n}\n\nexport default connect(\n    mapStateToProps,\n    mapDispachToProps\n)(Popup)","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\OutputTabs\\OutputTabs.js",["168","169","170","171","172","173","174","175","176","177","178"],"import React, { Component } from 'react'\nimport cn from './OutputTabs.module.css'\nimport WeaponDetection from '../../assets/images/WeaponDetection.png';\nimport externalConfig from '../../ExternalConfigurationHandler';\nimport actions from '../../store/actions';\nimport config, { devVideoSnapshotUrl, devVideoStreamUrl } from '../../config';\nimport { connect } from 'react-redux';\nimport EnemySpottedSound from '../../assets/EnemySpotted.mp3';\nimport ArmedRed from '../../assets/images/armedRed.svg';\n\n\nclass OutputTabs extends Component {\n\n\n    constructor(props) {\n        super(props);\n        this.state = {\n            pointPosition: null,\n            showCapture: true,\n            selectedTab: \"Capture\"\n        }\n        this.EnemySpotted = new Audio(EnemySpottedSound);\n\n    }\n\n      onImageLoaded = (e) => {\n        if (!this.props.imageSentToDroneData || !this.props.imageSentToDroneData.point) {\n            console.log(\"Error, this.props.imageSentToDroneData.point as it is undefined\");\n            return;\n        }\n\n        const tabsWrapper = document.getElementById('tabs-wrapper');\n\n        const img = e.target;\n        const xFactor = img.naturalWidth / tabsWrapper.getBoundingClientRect().width;\n        const yFactor = img.naturalHeight / tabsWrapper.getBoundingClientRect().height;\n        const { roundedX, roundedY } = this.props.imageSentToDroneData.point;\n        this.setState({\n            pointPosition: {\n                top: roundedY / yFactor,\n                left: roundedX / xFactor,\n            }\n        })\n\n    }\n\n    componentDidUpdate(prevProps) {\n        if (prevProps.imageSentToDroneData !== this.props.imageSentToDroneData) {\n            const img = document.createElement('img');\n            img.onload = this.onImageLoaded;\n            img.src = this.props.imageSentToDroneData.image;\n        }\n\n        if (prevProps.weaponDetected !== this.props.weaponDetected) {\n            this.EnemySpotted.play();\n        }\n    }\n\n    renderTabs() {\n\n        let imageElement = null;\n        let pointElement = null;\n\n        const imageDataUrl = this.props.imageSentToDroneData && this.props.imageSentToDroneData.image;\n        const point = this.props.imageSentToDroneData && this.props.imageSentToDroneData.point;\n        if (imageDataUrl && point) {\n            imageElement = <img className={cn.OutputImage} src={imageDataUrl} />\n            pointElement = <div className={cn.Point} style={this.state.pointPosition}></div>\n        }\n        return (<>\n            { imageElement}\n            { pointElement}\n        </>\n        );\n    }\n\n    renderNoOutputReceived() {\n        return <div className={cn.ErrorMessage}><span className={cn.ErrorIcon}></span> No output has been received yet</div>\n    }\n\n    onToggleTabClick = (selectedTab) => {\n              this.setState({ selectedTab });\n    }\n\n    renderTabsToggle = () => {\n        const selectedTab = this.state.selectedTab;\n        return (<>\n\n            <div className={cn.tabslidernav} >\n                <ul className={cn.tabslidertabs} >\n                    <li className={`${cn.tabslidertrigger} ${ selectedTab == \"Capture\" ? cn.TabSelected : \"\"}`}\n                        onClick={() => this.onToggleTabClick(\"Capture\")}>\n                        Capture\n                    </li>\n                    <li className={`${cn.tabslidertrigger} ${selectedTab == \"Skeleton\"  ? cn.TabSelected : \"\"}`}\n                        onClick={() => this.onToggleTabClick(\"Skeleton\")}>\n                        Skeleton\n                    </li>\n                    <li className={`${cn.tabslidertrigger} ${selectedTab == \"WindowDetection\"  ? cn.TabSelected : \"\"}`}\n                        onClick={() => this.onToggleTabClick(\"WindowDetection\")}>\n                        Window\n                    </li>\n                </ul>\n            </div>\n\n        </>)\n\n    }\n\n    getCaptureTab() {\n        return this.props.imageSentToDroneData ? this.renderTabs() : this.renderNoOutputReceived();\n    }\n\n    getSkeletonTab() {\n        let weaponDetectedClass = this.props.weaponDetected ?  cn.WeaponDetected : undefined;\n        return (<div className={`${cn.SkeletonTab} ${weaponDetectedClass}`} >\n            <img\n                crossOrigin=\"anonymous\"\n                //    onLoad={this.onVideoLoaded}\n                //   onError={this.onVideoError}\n                className={cn.VideoImage}\n                src={this.getSkeletonVideoSrc()}\n                id='droneImage'\n            //    onClick={this.props.pointVideoImage}\n            />\n            {this.props.weaponDetected &&  <img  className={`${cn.AlertIcon}`} src={ArmedRed} />}\n            { this.props.skeletonRange && <span className={`${cn.SkeletonRange}`} > -{this.props.skeletonRange}m- </span>}\n        </div>)\n    }\n\n    getWindowDetectionTab() {\n        return (<div className={`${cn.WindowTab}`} >\n            <img\n                crossOrigin=\"anonymous\"\n                //    onLoad={this.onVideoLoaded}\n                //   onError={this.onVideoError}\n                className={cn.VideoImage}\n                src={this.getWindowDetectionVideoSrc()}\n                id='droneImage'\n            //    onClick={this.props.pointVideoImage}\n            />\n            <span className={`${cn.AlertIcon}`} />\n            { this.props.skeletonRange && <span className={`${cn.SkeletonRange}`} > -{this.props.skeletonRange}m- </span>}\n        </div>)\n    }\n\n    getWindowDetectionVideoSrc() {\n        const { BE_PORT, BE_IP } = externalConfig.getConfiguration();\n\n        const snapshotUrl = `//${BE_IP}:${BE_PORT}${config.urls.windowDetectionSnapshot}`;\n        const streamUrl = `//${BE_IP}:${BE_PORT}${config.urls.windowDetectionStream}`;\n\n        if (this.props.isPaused) {\n            return process.env.NODE_ENV === 'development' ? snapshotUrl : snapshotUrl;\n        } else {\n            return process.env.NODE_ENV === 'development' ? streamUrl : streamUrl;\n        }\n    }\n    getSkeletonVideoSrc() {\n        const { BE_PORT, BE_IP } = externalConfig.getConfiguration();\n\n        const snapshotUrl = `//${BE_IP}:${BE_PORT}${config.urls.skeletonSnapshot}`;\n        const streamUrl = `//${BE_IP}:${BE_PORT}${config.urls.skeletonStream}`;\n\n        if (this.props.isPaused) {\n            return process.env.NODE_ENV === 'development' ? snapshotUrl : snapshotUrl;\n        } else {\n            return process.env.NODE_ENV === 'development' ? streamUrl : streamUrl;\n        }\n    }\n    getSelectedTab() {\n        switch (this.state.selectedTab) {\n            case \"Capture\":\n                return this.getCaptureTab();\n            case \"Skeleton\":\n                return this.getSkeletonTab();\n            case \"WindowDetection\":\n                return this.getWindowDetectionTab();\n            default:\n                return \"\";\n        }\n    }\n\n    render() {\n\n        return (\n            <div className={cn.Wrapper}>\n                {this.renderTabsToggle()}\n                <div className={cn.Tabs} id='tabs-wrapper'>\n                    {this.getSelectedTab()}\n                </div>\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        tabs: state.video.tabs,\n        imageSentToDroneData: state.layout.imageSentToDroneData,\n        skeletonRange: state.output.skeletonRange,\n        weaponDetected :  state.output.weaponDetected,\n    };\n};\n\nconst mapDispachToProps = (dispatch) => {\n    return {\n      \n    };\n};\n\nexport default connect(mapStateToProps, mapDispachToProps)(OutputTabs);","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\ActionButtons\\ActionButtons.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Error\\Error.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\GlobalMessage\\GlobalMessage.js",["179"],"import React,{ PureComponent } from 'react';\nimport classNames from './GlobalMessage.module.css';\nimport infoIcon from '../../assets/images/infoFull.svg';\nimport successIcon from '../../assets/images/success.svg';\nimport errorIcon from '../../assets/images/errorIcon.svg';\nimport warnIcon from '../../assets/images/warnIcon.svg';\nimport { connect } from 'react-redux';\nimport { logSeverities } from '../../config';\n\nclass GlobalMessage extends PureComponent {    \n    \n    renderIcon() {\n        let icon;\n        switch (this.props.appGlobalMessage.type) {\n            case logSeverities.info:\n                icon = infoIcon;\n                break;\n            case logSeverities.success:\n                icon = successIcon;\n                break;\n            case logSeverities.warn:\n                icon = warnIcon;\n                break;\n            case logSeverities.error:\n                icon = errorIcon;\n                break;        \n            default:\n                icon = infoIcon;\n                break;\n        }\n        return <img className={classNames.Icon} src={icon}></img>\n    }\n    renderText(text) {\n        return <div className={classNames.Text}>{text}</div>\n    }\n\n    renderNotification(notification) {\n        return (\n            <div className={classNames.Wrapper}>\n                {this.renderIcon()}\n                {this.renderText(notification.text)}\n            </div>\n        );\n    }\n\n    render() {      \n        const {appGlobalMessage} = this.props;\n        return appGlobalMessage && appGlobalMessage.text ? this.renderNotification(appGlobalMessage) : null\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        appGlobalMessage: state.layout.appGlobalMessage\n    };\n};\n\nconst mapDispachToProps = (dispatch) => {\n    return {\n        \n    };\n};\n\nexport default connect(mapStateToProps, mapDispachToProps)(GlobalMessage);","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\MapContainer\\MapContainer.js",["180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238"],"import React, { PureComponent, Component } from 'react';\nimport cn from './MapContainer.module.css';\nimport axios from 'axios';\nimport config from '../../config';\nimport { connect } from 'react-redux';\nimport externalConfig from '../../ExternalConfigurationHandler';\nimport actionTypes from '../../store/actions/actionTypes';\nimport actions from '../../store/actions';\nimport SwitchMapForm from '../SwitchMapForm/SwitchMapForm';\n\nclass SLayerGroup {\n    constructor(coordSystemString, bShowGeoInMetricProportion, bSetTerrainBoxByStaticLayerOnly, InitialScale2D) {\n        this.aLayerCreateStrings = [];\n        this.coordSystemString = coordSystemString;\n        this.bShowGeoInMetricProportion = bShowGeoInMetricProportion;\n        this.bSetTerrainBoxByStaticLayerOnly = bSetTerrainBoxByStaticLayerOnly;\n        this.InitialScale2D = InitialScale2D;\n    }\n}\n\nclass SViewportData {\n    constructor(_viewport, _editMode) {\n        this.viewport = _viewport;\n        this.editMode = _editMode;\n        this.canvas = _viewport.GetWindowHandle();\n        let aViewportTerrains = _viewport.GetTerrains();\n        this.aLayers = (aViewportTerrains != null && aViewportTerrains.length > 0 ? aViewportTerrains[0].GetLayers() : null);\n        this.terrainBox = null;\n        this.terrainCenter = null;\n        this.rotationCenter = null;\n        this.bCameraPositionSet = false;\n        this.bSetTerrainBoxByStaticLayerOnly = false;\n    }\n}\n\nclass MapContainer extends PureComponent {\n\n    state = {\n        mapLayerGroups: new Map(),\n        lastTerrainConfiguration: null,\n        lastViewportConfiguration: null /*  2D/3D, 3D/2D, 2D, 3D */,\n        bSameCanvas: true,\n        isDTMClicked: false,\n        is3DClicked: false,\n        isSwitchMapFormOpen: false,\n        workingOriginSelected: false\n    }\n\n    mapTerrains = new Map;\n    device = null\n    //callbacks classes from mapCore\n    CLayerReadCallback;\n    CCameraUpdateCallback;\n    CAsyncQueryCallback;\n    viewportData = null;\n    uCameraUpdateCounter = 0;\n    aLastTerrainLayers = [];\n    lastCoordSys = null;\n    overlayManager = null;\n    activeViewport = -1;\n    aViewports = [];\n    viewport;\n    editMode;\n    lastRenderTime = (new Date).getTime();\n    lastMemUsageLogTime = (new Date).getTime();\n    uMemUsageLoggingFrequency = 0;\n    nMousePrevX = 0;\n    nMousePrevY = 0;\n    mouseDownButtons = 0;\n    bEdit = false;\n    layerCallback = null;\n    requestAnimationFrameId = -1;\n    aPositions = [];\n    aObjects = [];\n    testObjectsScheme = null;\n    lineScheme = null;\n    textScheme = null;\n\n    WorkingOrigin = null;\n    DroneRouteCoordinates = [];\n    DroneObject = null;\n    DroneRouteObject = null;\n\n    componentDidMount() {\n        window.addEventListener('resize', this.resizeCanvases);\n        //this.callGetCapabilitiesApi();\n    }\n\n    componentWillUnmount() {\n        //Todo -> un-register events and all the map core object\n        window.removeEventListener('resize', this.resizeCanvases);\n        cancelAnimationFrame(this.requestAnimationFrameId);\n        this.requestAnimationFrameId = null;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n        // first time map load or channing from map a to map b\n        if ((!prevProps.isMapCoreSDKLoaded && this.props.isMapCoreSDKLoaded) ||\n            (this.props.isMapCoreSDKLoaded && prevProps.mapToShow !== this.props.mapToShow)) {\n            this.openMap(this.props.mapToShow.groupName, false);\n            console.log('mapCore version: ', window.MapCore.IMcMapDevice.GetVersion());\n            this.RemoveDroneData();\n        }\n        if (this.state.workingOriginSelected != prevState.workingOriginSelected) {\n            this.props.subscribeToDroneData();\n        }\n        if (this.props.dronePositionOffset && prevProps.dronePositionOffset != this.props.dronePositionOffset) {\n            this.MoveDrone();\n        }\n      \n    }\n\n    RemoveDroneData = () => {\n        if (this.WorkingOrigin) {\n            this.WorkingOrigin.Remove();\n            this.WorkingOrigin = null;\n        }\n        if (this.DroneObject) {\n            this.DroneObject.Remove();\n            this.DroneObject = null;\n        }\n        if (this.roneRouteObject) {\n            this.DroneRouteObject.Remove();\n            this.DroneRouteObject = null;\n        }\n        this.DroneRouteCoordinates = [];\n    }\n\n    // function starting line drawing by EditMode\n    DoLine = () => {\n        if (this.lineScheme == null) {\n            this.FetchFileToByteArray(\"http:ObjectWorld/Schemes/LineScheme.m\").then(\n                bytes => {\n                    if (bytes != null) {\n                        this.lineScheme = this.overlayManager.LoadObjectSchemes(bytes)[0];\n                        this.lineScheme.AddRef();\n                        //   DoStartInitObject(lineScheme); \n                    }\n                }\n            );\n        }\n        else {\n            //  DoStartInitObject(lineScheme);\n        }\n    }\n\n\n    // function creating randomly distributed objects after ensuring testObjectsScheme has been loaded\n    DoCreateObjects = () => {\n\n        this.DoLine();\n        if (this.testObjectsScheme == null) {\n            this.FetchFileToByteArray(\"http:ObjectWorld/Schemes/ScreenPicture-Scheme.m\").then(\n                bytes => {\n                    if (bytes != null) {\n                        this.testObjectsScheme = this.overlayManager.LoadObjectSchemes(bytes)[0];\n                        this.testObjectsScheme.AddRef();\n\n                        this.DoCreateObjectsFromLoadedScheme();\n                    }\n                }\n            );\n        }\n        else {\n            this.DoCreateObjectsFromLoadedScheme();\n        }\n    }\n\n    // function starting text drawing by EditMode\n    createOriginText = () => {\n\n        if (this.textScheme == null) {\n            this.FetchFileToByteArray(\"http:ObjectWorld/Schemes/TextScheme.m\").then(\n                bytes => {\n                    if (bytes != null) {\n                        this.textScheme = this.overlayManager.LoadObjectSchemes(bytes)[0];\n                        this.textScheme.AddRef();\n                        this.DoStartInitObject(this.textScheme);\n                    }\n                }\n            );\n        }\n        else {\n            this.DoStartInitObject(this.textScheme);\n        }\n    }\n\n    // function starting object drawing by EditMode (called by DoLine(), DoText(), etc.)\n    DoStartInitObject = (pScheme) => {\n        if (pScheme != null) {\n            // find item marked for editing (e.g. by setting ID = 1000)\n            let pItem = pScheme.GetNodeByID(1000);\n            if (pItem == null) {\n                alert(\"There is no item marked for editing (with ID = 1000)\");\n                return;\n            }\n\n            let text = window.MapCore.SMcVariantString(\"Origin\", true);\n            pItem.SetText(text);\n            //  let color = window.MapCore.SMcBColor(255,174,201,255);\n            // pItem.SetBackgroundColor(color); \n\n            this.RemoveDroneData();\n\n            // create object\n            let pObject = window.MapCore.IMcObject.Create(this.overlay, pScheme);\n            this.WorkingOrigin = pObject;\n\n            // start EditMode action\n            this.editMode.StartInitObject(pObject, pItem);\n\n        }\n    }\n\n    DoCreateObjectsFromLoadedScheme() {\n\n        let coordinate = {\n            x: this.WorkingOrigin.GetLocationPoints()[0].x,\n            y: this.WorkingOrigin.GetLocationPoints()[0].y,\n            z: this.WorkingOrigin.GetLocationPoints()[0].z\n        }\n        this.DroneRouteCoordinates.push(coordinate);\n        this.DroneObject = window.MapCore.IMcObject.Create(this.overlay, this.testObjectsScheme, [coordinate]);\n        this.DroneRouteObject = window.MapCore.IMcObject.Create(this.overlay, this.lineScheme, [coordinate]);\n    }\n\n    MoveDrone = () => {\n\n        if (!this.WorkingOrigin || !this.state.workingOriginSelected) {\n            console.log(\"No Working Origin Selected!!\");\n            return;\n        }\n        if (!this.DroneObject || !this.DroneRouteObject) {\n            this.DoCreateObjects();\n        }\n\n        const offset = this.props.dronePositionOffset;\n        const origin = this.WorkingOrigin.GetLocationPoints()[0];\n        let newCoordinate = {\n            x: origin.x + offset.x,\n            y: origin.y + offset.y,\n            z: origin.z + offset.z\n        }\n\n        if (!this.DroneObject) {\n            return;\n        }\n        this.DroneRouteCoordinates.push(newCoordinate);\n\n        this.DroneObject.UpdateLocationPoints([newCoordinate]);\n        this.DroneRouteObject = window.MapCore.IMcObject.Create(this.overlay, this.lineScheme, this.DroneRouteCoordinates);\n        this.DroneRouteObject.SetState([2])\n    }\n    // function fetching a file from server to byte-array\n    FetchFileToByteArray(uri) {\n        return fetch(uri)\n            .then(response => (response.ok ? response.arrayBuffer() : null))\n            .then(\n                arrayBuffer => {\n                    if (arrayBuffer != null) {\n                        return new Uint8Array(arrayBuffer);\n                    }\n                    else {\n                        alert(\"Cannot fetch \" + uri);\n                        return null;\n                    }\n                },\n                error => {\n                    alert(\"Network error in fetching \" + uri);\n                    return null;\n                }\n            );\n    }\n\n    parseLayersConfiguration(jsonLayerGroups) {\n        try {\n            for (let jsonGroup of jsonLayerGroups) {\n                // coordinate system creation string: MapCore.IMcGridCoordSystemGeographic.Create(MapCore.IMcGridCoordinateSystem.EDatumType.EDT_WGS84) etc.\n                let coordSystemString = \"MapCore.\" + jsonGroup.coordSystemType + \".Create(\" + jsonGroup.coordSystemParams + \")\";\n                let layerGroup = new SLayerGroup(coordSystemString, jsonGroup.showGeoInMetricProportion, jsonGroup.centerByStaticObjectsLayerOnly, jsonGroup.InitialScale2D);\n\n                if (jsonGroup.layers) {\n                    for (let layer of jsonGroup.layers) {\n                        let layerCreateString = null;\n                        const protocol = window.location.protocol;\n                        switch (layer.type) {\n                            case \"WMSRaster\":\n                                // WMS raster layer creation string: CreateWMSRasterLayer('http://wmtsserver/wmts?request=GetCapabilities', 'layer', 'EPSG:4326', 'jpeg') etc.\n                                layerCreateString = \"Create\" + layer.type + \"Layer('\" + layer.path + \"'\" + (layer.params ? \", \" + layer.params : \"\") + \")\";\n                                break;\n                            case \"IMcNativeRasterMapLayer\":\n                                layerCreateString = \"MapCore.IMcNativeRasterMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"MapCore.UINT_MAX, false, 0, false\") + \", this.layerCallback)\";\n                                break;\n                            case \"IMcNativeDtmMapLayer\":\n                                layerCreateString = \"MapCore.IMcNativeDtmMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"0\") + \", this.layerCallback)\";\n                                break;\n                            case \"IMcNativeVectorMapLayer\":\n                                layerCreateString = \"MapCore.IMcNativeVectorMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"\") + \"this.layerCallback)\";\n                                break;\n                            case \"IMcNative3DModelMapLayer\":\n                                layerCreateString = \"MapCore.IMcNative3DModelMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"0\") + \", this.layerCallback)\";\n                                break;\n                            case \"IMcNativeVector3DExtrusionMapLayer\":\n                                layerCreateString = \"MapCore.IMcNativeVector3DExtrusionMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"0, 10\") + \", this.layerCallback)\";\n                                break;\n                            default:\n                                alert(\"Invalid type of server layer\");\n                                return;\n                        }\n                        layerGroup.aLayerCreateStrings.push(layerCreateString);\n                    }\n                }\n                if (jsonGroup.groupName != undefined) {\n\n                    this.setState({ mapLayerGroups: new Map(this.state.mapLayerGroups.set(jsonGroup.groupName, layerGroup)) });\n\n                }\n                // we should not get here...\n                else if (jsonGroup.wmtsServerURL != undefined) {\n\n                    // layerGroup.wmtsServerURL = jsonGroup.wmtsServerURL;\n                    // if (jsonGroup.tileMatrixSetFilter != undefined) {\n\n                    //     layerGroup.tileMatrixSetFilter = jsonGroup.tileMatrixSetFilter;\n                    // }\n                    // aWmtsAdditionalLayerGroups.push(layerGroup);\n                }\n            }\n        }\n        catch (e) {\n            alert(\"Invalid configuration JSON file\");\n        }\n    }\n\n    parseCapabilitiesXML(xmlDoc, capabilitiesURL, bMapCoreLayerServer = true, wmtsAdditionalLayerGroup) {\n        class CXmlNode {\n            constructor(node) {\n                this.node = node;\n            }\n            GetFirstChild(tagName) {\n                let children = this.node.getElementsByTagName(tagName);\n                for (let child of children) {\n                    if (child.parentNode == this.node) {\n                        return new CXmlNode(child);\n                    }\n                }\n                return null;\n            }\n            GetFirstChildText(tagName) {\n                let children = this.node.getElementsByTagName(tagName);\n                for (let child of children) {\n                    if (child.parentNode == this.node) {\n                        return child.textContent;\n                    }\n                }\n                return null;\n            }\n            GetFirstChildAttribute(tagName, attributeName) {\n                let children = this.node.getElementsByTagName(tagName);\n                for (let child of children) {\n                    if (child.parentNode == this.node) {\n                        return child.attributes.getNamedItem(attributeName).value;\n                    }\n                }\n                return null;\n            }\n            GetChildren(tagName) {\n                let children = this.node.getElementsByTagName(tagName);\n                let aNodes = [];\n                for (let child of children) {\n                    if (child.parentNode == this.node) {\n                        aNodes.push(new CXmlNode(child));\n                    }\n                }\n                return aNodes;\n            }\n            GetChildrenTexts(tagName) {\n                let children = this.node.getElementsByTagName(tagName);\n                let aTexts = [];\n                for (let child of children) {\n                    if (child.parentNode == this.node) {\n                        aTexts.push(child.textContent);\n                    }\n                }\n                return aTexts;\n            }\n        }\n\n        if (xmlDoc != null) {\n            try {\n                let capabilities = new CXmlNode(xmlDoc).GetFirstChild(\"Capabilities\");\n                let MapLayerServerURL = capabilities.GetFirstChildAttribute(\"ServiceMetadataURL\", \"xlink:href\");\n                if (MapLayerServerURL == null || MapLayerServerURL == \"\") {\n                    MapLayerServerURL = capabilitiesURL;\n                }\n                let lastSlashIndex = MapLayerServerURL.lastIndexOf(\"?\");\n                if (lastSlashIndex < 0) {\n                    lastSlashIndex = MapLayerServerURL.lastIndexOf(\"/\");\n                }\n                if (lastSlashIndex < 0) {\n                    alert(\"Invalid Capabilities file\");\n                    return;\n                }\n                let TrimmedMapLayerServerURL = MapLayerServerURL.substring(0, lastSlashIndex);\n\n                let contents = capabilities.GetFirstChild(\"Contents\");\n                let aTileMatrixSets = contents.GetChildren(\"TileMatrixSet\");\n                let mapTileMatrixSets = new Map();\n                for (let matrixSet of aTileMatrixSets) {\n                    let id = matrixSet.GetFirstChildText(\"ows:Identifier\");\n                    let crs = matrixSet.GetFirstChildText(\"ows:SupportedCRS\");\n                    if (id != null && crs != null) {\n                        mapTileMatrixSets.set(matrixSet.GetFirstChildText(\"ows:Identifier\"), { coordSystem: crs, tileMatrixSet: id });\n                    }\n                }\n\n                let aLayers = contents.GetChildren(\"Layer\");\n                for (let layer of aLayers) {\n                    // check here if its single layer preview. if yes put only this layer in the hashMap                    \n                    let layerID = layer.GetFirstChildText(\"ows:Identifier\");\n                    if (this.context.mapToPreview.type === config.nodesLevel.layer &&\n                        (this.context.mapToPreview.data.LayerId !== layerID && this.context.mapToPreview.dtmLayerId !== layerID))\n                        continue;\n\n                    let aFormats = layer.GetChildrenTexts(\"Format\");\n                    let aTileMatrixSetLinks = layer.GetChildren(\"TileMatrixSetLink\");\n                    if (aTileMatrixSetLinks.length == 0) {\n                        aTileMatrixSetLinks.push(null);\n                    }\n\n                    for (let tileMatrixSetLink of aTileMatrixSetLinks) {\n                        let coordSystem = null;\n                        let tileMatrixSet = null;\n                        if (tileMatrixSetLink != null) {\n                            let tileMatrixSetParams = mapTileMatrixSets.get(tileMatrixSetLink.GetFirstChildText(\"TileMatrixSet\"));\n                            coordSystem = tileMatrixSetParams.coordSystem;\n                            tileMatrixSet = tileMatrixSetParams.tileMatrixSet;\n                            if (wmtsAdditionalLayerGroup && wmtsAdditionalLayerGroup.tileMatrixSetFilter && tileMatrixSet != wmtsAdditionalLayerGroup.tileMatrixSetFilter) {\n                                continue;\n                            }\n                        }\n                        if (coordSystem == null) {\n                            let boundingBox = layer.GetFirstChild(\"ows:BoundingBox\");\n                            if (boundingBox) {\n                                coordSystem = boundingBox.GetFirstChildText(\"ows:crs\");\n                            }\n                        }\n                        let prefix = \"urn:ogc:def:crs:\";\n                        if (coordSystem.indexOf(prefix) == 0) {\n                            coordSystem = coordSystem.substring(prefix.length).replace(\"::\", \":\");\n                            let aGroups = [];\n                            if (bMapCoreLayerServer) {\n                                aGroups = layer.GetFirstChildText(\"Group\").split(\",\");\n                                for (let i = 0; i < aGroups.length; ++i) {\n                                    aGroups[i] = aGroups[i] + \" (server \" + coordSystem + \")\";\n                                }\n                            }\n                            else {\n                                let groupName = layer.GetFirstChildText(\"ows:Title\");\n                                if (groupName == null) {\n                                    groupName = layerID;\n                                }\n\n                                for (let i = 0; i < aFormats.length; ++i) {\n                                    aFormats[i] = aFormats[i].replace(\"image/\", \"\");\n                                    aGroups[i] = groupName + \" (WMTS \" + aFormats[i] + \" \" + tileMatrixSet + \")\";\n                                }\n                            }\n                            for (let i = 0; i < aGroups.length; ++i) {\n                                let group = aGroups[i];\n\n                                // coordinate system creation string: MapCore.IMcGridGeneric.Create('EPSG:4326') etc.\n                                let coordSystemString = \"MapCore.IMcGridGeneric.Create('\" + coordSystem + \"')\";\n                                let layerGroup = this.state.mapLayerGroups.get(group);\n                                if (layerGroup == undefined) {\n                                    layerGroup = new SLayerGroup(coordSystemString, true); // for MapCoreLayerServer only: bShowGeoInMetricProportion is true\n                                    this.setState({ mapLayerGroups: new Map(this.state.mapLayerGroups.set(group, layerGroup)) });\n                                }\n                                else if (coordSystemString != layerGroup.coordSystemString) {\n                                    alert(\"Layers' coordinate systems do not match\");\n                                    return;\n                                }\n                                let layerCreateString;\n                                if (bMapCoreLayerServer) {\n                                    layerCreateString = aFormats[0].replace(\"MapCore\", \"MapCore.IMcNative\").replace(\"DTM\", \"Dtm\") + \"MapLayer\" + \".Create('\" + TrimmedMapLayerServerURL + \"/\" + layerID + \"')\";\n                                    layerGroup.aLayerCreateStrings.push(layerCreateString);\n                                }\n                                else {\n                                    // WMTS raster layer creation string: CreateWMTSRasterLayer('http://wmtsserver/wmts?request=GetCapabilities', 'layer', 'EPSG:4326', 'jpeg') etc.\n                                    layerCreateString = \"CreateWMTSRasterLayer('\" + capabilitiesURL + \"', '\" + layerID + \"', '\" + tileMatrixSet + \"', '\" + aFormats[i] + \"')\";\n                                    layerGroup.aLayerCreateStrings.push(layerCreateString);\n                                    if (wmtsAdditionalLayerGroup) {\n                                        layerGroup.aLayerCreateStrings = layerGroup.aLayerCreateStrings.concat(wmtsAdditionalLayerGroup.aLayerCreateStrings);\n                                        layerGroup.bSetTerrainBoxByStaticLayerOnly = wmtsAdditionalLayerGroup.bSetTerrainBoxByStaticLayerOnly;\n                                        layerGroup.bShowGeoInMetricProportion = wmtsAdditionalLayerGroup.bShowGeoInMetricProportion;\n                                        layerGroup.InitialScale2D = wmtsAdditionalLayerGroup.InitialScale2D;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            catch (e) {\n                alert(\"Invalid Capabilities file\");\n            }\n        }\n    }\n\n    createCallbackClasses() {\n        this.CLayerReadCallback = window.MapCore.IMcMapLayer.IReadCallback.extend(\"IMcMapLayer.IReadCallback\", {\n            // mandatory\n            OnInitialized: function (pLayer, eStatus, strAdditionalDataString) {\n                if (eStatus == window.MapCore.IMcErrors.ECode.SUCCESS) {\n                    //this.trySetTerainBox();\n                    // if (pLayer.GetLayerType() ==  window.MapCore.IMcNativeStaticObjectsMapLayer.LAYER_TYPE && !pLayer.IsBuiltOfContoursExtrusion())\n                    // {\n                    //     pLayer.SetDisplayingItemsAttachedToTerrain(true);\n                    //     pLayer.SetDisplayingDtmVisualization(true);\n                    // }\n                }\n                else if (eStatus != window.MapCore.IMcErrors.ECode.NATIVE_SERVER_LAYER_NOT_VALID) {\n                    alert(\"Layer initialization: \" + window.MapCore.IMcErrors.ErrorCodeToString(eStatus) + \" (\" + strAdditionalDataString + \")\");\n                }\n            },\n            // mandatory\n            OnReadError: function (pLayer, eErrorCode, strAdditionalDataString) {\n                alert(\"Layer read error: \" + window.MapCore.IMcErrors.ErrorCodeToString(eErrorCode) + \" (\" + strAdditionalDataString + \")\");\n            },\n            // mandatory\n            OnNativeServerLayerNotValid: function (pLayer, bLayerVersionUpdated) {/*TBD*/ },\n            // optional, needed if to be deleted by MapCore when no longer used\n            // optional\n            OnRemoved(pLayer, eStatus, strAdditionalDataString) {\n                alert(\"Map layer has been removed\");\n            },\n\n            // optional\n            OnReplaced(pOldLayer, pNewLayer, eStatus, strAdditionalDataString) {\n                alert(\"Map layer has been replaced\");\n            },\n            Release: function () { this.delete(); },\n        });\n\n        this.CCameraUpdateCallback = window.MapCore.IMcMapViewport.ICameraUpdateCallback.extend(\"IMcMapViewport.ICameraUpdateCallback\", {\n            // mandatory\n            OnActiveCameraUpdated: function (pViewport) {\n                ++this.uCameraUpdateCounter\n            },\n            // optional\n            Release: function () {\n                this.delete()\n            }\n        });\n\n        this.CAsyncQueryCallback = window.MapCore.IMcSpatialQueries.IAsyncQueryCallback.extend(\"IMcSpatialQueries.IAsyncQueryCallback\", {\n            // optional\n            __construct: function (viewportData) {\n                this.__parent.__construct.call(this);\n                this.viewportData = viewportData;\n            },\n\n            OnTerrainHeightResults: function (bHeightFound, height, normal) {\n                if (this.viewportData.viewport != null) {\n                    this.viewportData.terrainCenter.z = height + 20;\n                    if (this.viewportData.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\n                        this.viewportData.viewport.SetCameraPosition(this.viewportData.terrainCenter);\n                    }\n                }\n                this.delete();\n            },\n            OnTerrainHeightMatrixResults: function (uNumHorizontalPoints, uNumVerticalPoints, adHeightMatrix) { },\n            OnTerrainHeightsAlongLineResults: function (aPointsWithHeights, aSlopes, pSlopesData) { },\n            OnExtremeHeightPointsInPolygonResults: function (bPointsFound, pHighestPoint, pLowestPoint) { },\n            OnTerrainAnglesResults: function (dPitch, dRoll) { },\n\n            // OnRayIntersectionResults\n            OnLineOfSightResults: function (aPoints, dCrestClearanceAngle, dCrestClearanceDistance) { },\n            OnPointVisibilityResults: function (bIsTargetVisible, pdMinimalTargetHeightForVisibility, pdMinimalScouterHeightForVisibility) { },\n            OnAreaOfSightResults: function (pAreaOfSight, aLinesOfSight, pSeenPolygons, pUnseenPolygons, aSeenStaticObjects) { },\n            OnLocationFromTwoDistancesAndAzimuthResults: function (Target) { },\n\n            // mandatory\n            OnError: function (eErrorCode) {\n                alert('error ' + eErrorCode);\n                this.delete();\n            },\n        });\n\n        let CUserData = window.MapCore.IMcUserData.extend(\"IMcUserData\", {\n            // optional\n            __construct: function (bToBeDeleted) {\n                this.__parent.__construct.call(this);\n                this.bToBeDeleted = bToBeDeleted;\n                // ...\n            },\n\n            // optional\n            __destruct: function () {\n                this.__parent.__destruct.call(this);\n                // ...\n            },\n\n            // mandatory\n            Release: function () {\n                if (this.bToBeDeleted) {\n                    this.delete();\n                }\n            },\n\n            // optional\n            Clone: function () {\n                if (this.bToBeDeleted) {\n                    return new CUserData(this.bToBeDeleted);\n                }\n                return this;\n            },\n        });\n        this.layerCallback = new this.CLayerReadCallback();\n    }\n\n    renderMapContinuously = () => {\n        if (!this.requestAnimationFrameId) return;\n        this.trySetTerainBox();\n        let currtRenderTime = (new Date).getTime();\n\n        // render viewport(s)\n        if (!this.state.bSameCanvas) {\n            window.MapCore.IMcMapViewport.RenderAll();\n        } else if (this.viewport != null) {\n            this.viewport.Render();\n        }\n\n        // move objects if they exist\n        this.lastRenderTime = currtRenderTime;\n\n        // log memory usage and heap size\n        if (this.uMemUsageLoggingFrequency != 0 && currtRenderTime >= this.lastMemUsageLogTime + this.uMemUsageLoggingFrequency * 1000) {\n            let usage = window.MapCore.IMcMapDevice.GetMaxMemoryUsage();\n            console.log(\"Max mem = \" + window.MapCore.IMcMapDevice.GetMaxMemoryUsage().toLocaleString() + \", heap = \" + window.MapCore.IMcMapDevice.GetHeapSize().toLocaleString() + \" B\");\n            this.lastMemUsageLogTime = currtRenderTime;\n        }\n\n        // ask the browser to render again\n        this.requestAnimationFrameId = requestAnimationFrame(this.renderMapContinuously);\n    }\n\n    trySetTerainBox = () => {\n        for (let j = 0; j < this.aViewports.length; j++) {\n            if (this.aViewports[j].terrainBox == null) {\n                let aViewportLayers = this.aViewports[j].aLayers;\n                if (aViewportLayers.length != 0) {\n                    this.aViewports[j].terrainBox = new window.MapCore.SMcBox(-window.MapCore.DBL_MAX, -window.MapCore.DBL_MAX, 0, window.MapCore.DBL_MAX, window.MapCore.DBL_MAX, 0);\n                    for (let i = 0; i < aViewportLayers.length; ++i) {\n                        if (this.aViewports[j].bSetTerrainBoxByStaticLayerOnly && aViewportLayers[i].GetLayerType() != window.MapCore.IMcNativeStaticObjectsMapLayer.LAYER_TYPE) {\n                            continue;\n                        }\n\n                        if (!aViewportLayers[i].IsInitialized()) {\n                            this.aViewports[j].terrainBox = null;\n                            return;\n                        }\n\n                        let layerBox = aViewportLayers[i].GetBoundingBox();\n                        if (layerBox.MinVertex.x > this.aViewports[j].terrainBox.MinVertex.x) {\n                            this.aViewports[j].terrainBox.MinVertex.x = layerBox.MinVertex.x;\n                        }\n                        if (layerBox.MaxVertex.x < this.aViewports[j].terrainBox.MaxVertex.x) {\n                            this.aViewports[j].terrainBox.MaxVertex.x = layerBox.MaxVertex.x;\n                        }\n                        if (layerBox.MinVertex.y > this.aViewports[j].terrainBox.MinVertex.y) {\n                            this.aViewports[j].terrainBox.MinVertex.y = layerBox.MinVertex.y;\n                        }\n                        if (layerBox.MaxVertex.y < this.aViewports[j].terrainBox.MaxVertex.y) {\n                            this.aViewports[j].terrainBox.MaxVertex.y = layerBox.MaxVertex.y;\n                        }\n                    }\n                }\n                else {\n                    this.aViewports[j].terrainBox = new window.MapCore.SMcBox(0, 0, 0, 0, 0, 0);\n                }\n\n                this.aViewports[j].terrainCenter = window.MapCore.SMcVector3D((this.aViewports[j].terrainBox.MinVertex.x + this.aViewports[j].terrainBox.MaxVertex.x) / 2, (this.aViewports[j].terrainBox.MinVertex.y + this.aViewports[j].terrainBox.MaxVertex.y) / 2, 0);\n                this.aViewports[j].terrainCenter.z = 10000;\n            }\n\n            if (!this.aViewports[j].bCameraPositionSet) {\n                if (this.aViewports[j].viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_2D) {\n                    this.aViewports[j].viewport.SetCameraPosition(this.aViewports[j].terrainCenter);\n                    this.aViewports[j].bCameraPositionSet = true;\n                }\n                else // 3D\n                {\n                    let height = {};\n                    this.aViewports[j].terrainCenter.z = 100;\n                    this.aViewports[j].viewport.SetCameraPosition(this.aViewports[j].terrainCenter);\n                    let params = new window.MapCore.IMcSpatialQueries.SQueryParams();\n                    params.eTerrainPrecision = window.MapCore.IMcSpatialQueries.EQueryPrecision.EQP_HIGH;\n                    this.aViewports[j].bCameraPositionSet = true;\n                    params.pAsyncQueryCallback = new this.CAsyncQueryCallback(this.aViewports[j]);\n                    this.aViewports[j].viewport.GetTerrainHeight(this.aViewports[j].terrainCenter, height, null, params); // async, wait for OnTerrainHeightResults()\n                }\n            }\n        }\n    }\n\n    resizeCanvases = () => {\n        if (this.aViewports.length == 0) {\n            return;\n        }\n\n        let CanvasesInRow, CanvasesInColumn;\n        if (!this.state.bSameCanvas) {\n            CanvasesInRow = Math.ceil(Math.sqrt(this.aViewports.length));\n            CanvasesInColumn = Math.ceil(this.aViewports.length / CanvasesInRow);\n        }\n        else {\n            CanvasesInRow = 1;\n            CanvasesInColumn = 1;\n        }\n        //todo: use this instead: document.getElementById('id').getBoundingClientRect()\n        //    let width =  (window.innerWidth - 40) / CanvasesInRow - 10;\n        //    let height = (window.innerHeight - 80) / CanvasesInColumn - 15;\n        let width = document.getElementById('canvasesContainer').getBoundingClientRect().width;\n        let height = document.getElementById('canvasesContainer').getBoundingClientRect().height;\n\n        for (let i = 0; i < this.aViewports.length; i++) {\n            this.aViewports[i].canvas.width = width;\n            this.aViewports[i].canvas.height = height;\n            this.aViewports[i].viewport.ViewportResized();\n        }\n    }\n\n    calcMinMaxHeights() {\n        let minHeight = 0;\n        let maxHeight = 700;\n        let fp = this.viewport.GetCameraFootprint();\n\n        if (fp.bUpperLeftFound && fp.bUpperRightFound && fp.bLowerRightFound && fp.bLowerLeftFound) {\n            let minPoint = {}, maxPoint = {};\n            if (this.viewport.GetExtremeHeightPointsInPolygon([fp.UpperLeft, fp.UpperRight, fp.LowerRight, fp.LowerLeft], maxPoint, minPoint)) {\n                minHeight = minPoint.Value.z;\n                maxHeight = maxPoint.Value.z;\n            }\n        }\n        return { minHeight, maxHeight };\n    }\n\n    // function switching DTM-visualization (height map) on/off\n    doDtmVisualization = () => {\n        if (!this.viewport.GetDtmVisualization()) {\n            let result = this.calcMinMaxHeights();\n            let DtmVisualization = new window.MapCore.IMcMapViewport.SDtmVisualizationParams();\n            window.MapCore.IMcMapViewport.SDtmVisualizationParams.SetDefaultHeightColors(DtmVisualization, result.minHeight, result.maxHeight);\n            DtmVisualization.bDtmVisualizationAboveRaster = true;\n            DtmVisualization.uHeightColorsTransparency = 120;\n            DtmVisualization.uShadingTransparency = 255;\n            this.viewport.SetDtmVisualization(true, DtmVisualization);\n        } else {\n            this.viewport.SetDtmVisualization(false);\n        }\n    }\n\n    mouseWheelHandler = e => {\n        let bHandled = {};\n        let eCursor = {};\n        let wheelDelta = - e.deltaY;\n        this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_WHEEL, window.MapCore.SMcPoint(0, 0), e.ctrlKey, wheelDelta, bHandled, eCursor);\n        if (bHandled.Value) {\n            return;\n        }\n\n        let factor = (e.shiftKey ? 10 : 1);\n\n        if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\n            this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(0, 0, wheelDelta / 8.0 * factor), true);\n        } else {\n            let fScale = this.viewport.GetCameraScale();\n            if (wheelDelta > 0) {\n                this.viewport.SetCameraScale(fScale / 1.25);\n            } else {\n                this.viewport.SetCameraScale(fScale * 1.25);\n            }\n\n            if (this.viewport.GetDtmVisualization()) {\n                this.doDtmVisualization();\n                this.doDtmVisualization();\n            }\n        }\n\n        e.preventDefault();\n        e.cancelBubble = true;\n        if (e.stopPropagation) e.stopPropagation();\n    }\n\n\n    mouseMoveHandler = (e, isTouch = false) => {\n        if (this.viewport.GetWindowHandle() != e.target) {\n            return;\n        }\n\n        let EventPixel = null;\n        if (isTouch) {\n            const rect = e.target.getBoundingClientRect();\n            const offsetX = e.targetTouches[0].pageX - rect.left;\n            const offsetY = e.targetTouches[0].pageY - rect.top;\n            EventPixel = window.MapCore.SMcPoint(offsetX, offsetY);\n        } else {\n            EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\n        }\n\n        if (e.buttons <= 1) {\n            let bHandled = {};\n            let eCursor = {};\n            this.editMode.OnMouseEvent((e.buttons == 1 || isTouch) ?\n                window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_MOVED_BUTTON_DOWN :\n                window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_MOVED_BUTTON_UP,\n                EventPixel,\n                e.ctrlKey,\n                0,\n                bHandled,\n                eCursor\n            );\n            if (bHandled.Value) {\n                e.preventDefault();\n                e.cancelBubble = true;\n                if (e.stopPropagation) e.stopPropagation();\n                return;\n            }\n        }\n\n        if (e.buttons == 1 || isTouch) {\n            if (this.nMousePrevX != 0) {\n                let factor = (e.shiftKey ? 10 : 1);\n                if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\n                    if (e.ctrlKey) {\n                        this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D((this.nMousePrevX - EventPixel.x) / 2.0 * factor, - (this.nMousePrevY - EventPixel.y) / 2.0 * factor, 0), false);\n                    }\n                    else {\n                        this.viewport.RotateCameraRelativeToOrientation((this.nMousePrevX - EventPixel.x) / 2.0, - (this.nMousePrevY - EventPixel.y) / 2.0, 0);\n                    }\n                } else {\n                    if (e.ctrlKey) {\n                        this.viewport.SetCameraOrientation((this.nMousePrevX - EventPixel.x) / 2.0, window.MapCore.FLT_MAX, window.MapCore.FLT_MAX, true);\n                    }\n                    else {\n                        this.viewport.ScrollCamera((this.nMousePrevX - EventPixel.x) * factor, (this.nMousePrevY - EventPixel.y) * factor);\n                    }\n                }\n\n                e.preventDefault();\n                e.cancelBubble = true;\n                if (e.stopPropagation) e.stopPropagation();\n            }\n        }\n\n        this.nMousePrevX = EventPixel.x;\n        this.nMousePrevY = EventPixel.y;\n    }\n\n    mouseDownHandler = e => {\n\n        if (this.editMode.IsEditingActive()) {\n            // EditMode is active: don't change active viewport, but ignore click on non-active one\n            if (this.viewport.GetWindowHandle() != e.target) {\n                return;\n            }\n        } else if (!this.state.bSameCanvas) {\n            for (let i = 0; i < this.aViewports.length; i++) {\n                if (e.target == this.aViewports[i].viewport.GetWindowHandle()) {\n                    this.activeViewport = i;\n                    this.updateActiveViewport();\n                    break;\n                }\n            }\n        }\n\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\n        this.mouseDownButtons = e.buttons;\n        if (e.buttons == 1) {\n            let bHandled = {};\n            let eCursor = {};\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_PRESSED, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\n            if (!this.state.workingOriginSelected && this.WorkingOrigin && this.WorkingOrigin.GetLocationPoints().length > 0) {\n                this.setState({ workingOriginSelected: true });\n            }\n\n            if (bHandled.Value) {\n                e.preventDefault();\n                e.cancelBubble = true;\n                if (e.stopPropagation) e.stopPropagation();\n                return;\n            }\n\n            this.nMousePrevX = EventPixel.x;\n            this.nMousePrevY = EventPixel.y;\n        }\n\n\n        e.preventDefault();\n        e.cancelBubble = true;\n        if (e.stopPropagation) e.stopPropagation();\n    }\n    mouseUpHandler = e => {\n        this.props.closeContextMenu();\n        if (this.viewport.GetWindowHandle() != e.target) {\n            return;\n        }\n\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\n        let buttons = this.mouseDownButtons & ~e.buttons;\n        if (buttons == 1) {\n            let bHandled = {};\n            let eCursor = {};\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_RELEASED, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\n            if (bHandled.Value) {\n                e.preventDefault();\n                e.cancelBubble = true;\n                if (e.stopPropagation) e.stopPropagation();\n                return;\n            }\n        }\n\n\n\n    }\n    mouseDblClickHandler = e => {\n        if (this.viewport.GetWindowHandle() != e.target) {\n            return;\n        }\n\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\n        let buttons = this.mouseDownButtons & ~e.buttons;\n        if (this.bEdit) {\n            let aTargets = this.viewport.ScanInGeometry(new window.MapCore.SMcScanPointGeometry(window.MapCore.EMcPointCoordSystem.EPCS_SCREEN, window.MapCore.SMcVector3D(EventPixel.x, EventPixel.y, 0), 20), false);\n            for (let i = 0; i < aTargets.length; ++i) {\n                if (aTargets[i].eTargetType == window.MapCore.IMcSpatialQueries.EIntersectionTargetType.EITT_OVERLAY_MANAGER_OBJECT) {\n                    if (this.bEdit) {\n                        this.editMode.StartEditObject(aTargets[i].ObjectItemData.pObject, aTargets[i].ObjectItemData.pItem);\n                    }\n                    break;\n                }\n            }\n            this.bEdit = false;\n            e.preventDefault();\n            e.cancelBubble = true;\n            if (e.stopPropagation) e.stopPropagation();\n            return;\n        }\n\n        if (buttons == 1) {\n            let bHandled = {};\n            let eCursor = {};\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_DOUBLE_CLICK, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\n            if (bHandled.Value) {\n                e.preventDefault();\n                e.cancelBubble = true;\n                if (e.stopPropagation) e.stopPropagation();\n                return;\n            }\n        }\n    }\n\n    stopEvent = (e) => {\n        e.preventDefault();\n        e.cancelBubble = true;\n        e.stopPropagation && e.stopPropagation();\n    }\n\n    touchStartHandler = (e) => {\n        const rect = e.target.getBoundingClientRect();\n        this.nMousePrevX = this._onMouseDownX = e.targetTouches[0].pageX - rect.left;\n        this.nMousePrevY = this._onMouseDownY = e.targetTouches[0].pageY - rect.top;\n        //this.stopEvent(e);        \n    }\n\n    screenToWorld = (x, y, options) => {\n        const screenPoint = new window.MapCore.SMcVector3D(x, y, 0);\n        const worldPoint = {};\n        if (!this.viewport.ScreenToWorldOnTerrain(screenPoint, worldPoint)) {\n            this.viewport.ScreenToWorldOnPlane(screenPoint, worldPoint);\n        }\n        let ret = worldPoint;\n        if (!options || !options.withoutConvert) {\n            //   const worldPointGeo = this.gridConverter.ConvertAtoB(worldPoint.Value);\n            //   const worldPointGeoConverted = ConvertGEOPartial.geoPartialCoordsToGeoPartial(new geo.coordinate(worldPointGeo.x / DEG_TO_MC, worldPointGeo.y / DEG_TO_MC, worldPointGeo.z));\n            //   const worldPointGrid = worldPoint.Value;\n            //   ret = {worldPointGeo, worldPointGeoConverted, worldPointGrid};\n        }\n        return ret;\n    }\n\n    worldToScreen = (coordinate, options) => {\n        let srcCoords = coordinate;\n        if (!options || !options.native) {\n            //srcCoords = this._transformCoordinateToNative(coordinate);\n        }\n        const screenPoint = this.viewport.WorldToScreen(srcCoords);\n        let inScreen = true;\n        if (screenPoint.x < 0 || screenPoint.x > this._canvas.width ||\n            screenPoint.y < 0 || screenPoint.y > this._canvas.height) {\n            inScreen = false;\n        }\n        return { x: screenPoint.x, y: screenPoint.y, inScreen };\n    }\n\n    moveCameraRelativeToOrientation = (moveX, moveY, ignorePitch = true, useHeightFactor = false) => {\n        let factor = 1;\n        if (useHeightFactor) {\n            const currentPosition = this.viewport.GetCameraPosition();\n            let height = {};\n            let heightDiff = Math.abs(currentPosition.z);\n            if (this.viewport.GetTerrainHeight(currentPosition, height)) {\n                heightDiff = currentPosition.z - height.Value;\n            }\n\n            //   if (this.moveCameraRelativeToOrientationFactor) {\n            //     const heightFactorNameToUse = useHeightFactor ? useHeightFactor : 'other';\n            //     const heightFactorToUse = this.moveCameraRelativeToOrientationFactor[heightFactorNameToUse];\n            //     if (heightFactorToUse) {              \n            //       for (let i = 0; i < heightFactorToUse.length; i++) {\n            //         if (!heightFactorToUse[i].max) {\n            //           factor = heightFactorToUse[i].factor;\n            //         }\n            //         if (heightDiff < heightFactorToUse[i].max) {\n            //           factor = heightFactorToUse[i].factor;\n            //           break;\n            //         }\n            //       }\n            //     }\n            //   }\n            // }\n\n            if (useHeightFactor === 'mouse') {\n                factor = 600;\n                if (heightDiff < 10) {\n                    factor = 1;\n                } else if (heightDiff < 30) {\n                    factor = 3;\n                } else if (heightDiff < 100) {\n                    factor = 6;\n                } else if (heightDiff < 200) {\n                    factor = 12;\n                } else if (heightDiff < 300) {\n                    factor = 20;\n                } else if (heightDiff < 500) {\n                    factor = 35;\n                } else if (heightDiff < 1000) {\n                    factor = 100;\n                } else if (heightDiff < 2000) {\n                    factor = 200;\n                } else if (heightDiff < 5000) {\n                    factor = 400;\n                }\n            } else if (useHeightFactor === 'touch') {\n                factor = 600;\n                if (heightDiff < 10) {\n                    factor = 2;\n                } else if (heightDiff < 30) {\n                    factor = 6;\n                } else if (heightDiff < 100) {\n                    factor = 9;\n                } else if (heightDiff < 200) {\n                    factor = 12;\n                } else if (heightDiff < 300) {\n                    factor = 20;\n                } else if (heightDiff < 500) {\n                    factor = 35;\n                } else if (heightDiff < 1000) {\n                    factor = 100;\n                } else if (heightDiff < 2000) {\n                    factor = 200;\n                } else if (heightDiff < 5000) {\n                    factor = 400;\n                }\n                factor *= 2;\n            } else {\n                factor = 150;\n                if (heightDiff < 10) {\n                    factor = 1;\n                } else if (heightDiff < 30) {\n                    factor = 4;\n                } else if (heightDiff < 100) {\n                    factor = 8;\n                } else if (heightDiff < 200) {\n                    factor = 12;\n                } else if (heightDiff < 300) {\n                    factor = 30;\n                } else if (heightDiff < 500) {\n                    factor = 50;\n                } else if (heightDiff < 1000) {\n                    factor = 100;\n                }\n            }\n        }\n        this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(moveX * factor, moveY * factor, 0), ignorePitch);\n    }\n\n    getCameraOrientation = () => {\n        let ret = { azimuth: 0, pitch: 0 };\n        const azimuthOrientation = {};\n        const pitchOrientation = {};\n        this.viewport.GetCameraOrientation(azimuthOrientation, pitchOrientation, null);\n        if (azimuthOrientation) {\n            ret.azimuth = azimuthOrientation.Value;\n        }\n        if (pitchOrientation) {\n            ret.pitch = pitchOrientation.Value;\n        }\n        return ret;\n    }\n\n    setCameraOrientation = (cameraOrientationAzimuth, cameraOrientationPitch, stopDrag = true) => {\n        const azimuthOrientation = {};\n        const pitchOrientation = {};\n        const rollOrientation = {};\n        this.viewport.GetCameraOrientation(azimuthOrientation, pitchOrientation, rollOrientation);\n        const azimuthToSet = cameraOrientationAzimuth !== undefined ? cameraOrientationAzimuth : azimuthOrientation.Value;\n        const pitchToSet = cameraOrientationPitch !== undefined ? cameraOrientationPitch : pitchOrientation.Value;\n        this.viewport.SetCameraOrientation(azimuthToSet, pitchToSet, 0);\n    }\n\n    isGeoCoordValid = (coord, isNative = true) => {\n        const DEG_TO_MC = 100000;\n\n        let isValid = true;\n        const coordFactor = isNative ? DEG_TO_MC : 1;\n        if (coord.x < -180 * coordFactor || coord.y < -89.5 * coordFactor || coord.y === 0) {\n            isValid = false;\n        } else if (coord.x > 180 * coordFactor || coord.y > 89.5 * coordFactor || coord.z > Number.MAX_VALUE) {\n            isValid = false;\n        }\n        return isValid;\n    }\n\n    rotateCameraAroundWorldPoint = (coord, azimuthDelta, azimuthPitch, watchRoll) => {\n        const currentAzimuth = {};\n        const currentPitch = {};\n        const currentRoll = {};\n        let currentPosition;\n        if (watchRoll) {\n            this.viewport.GetCameraOrientation(currentAzimuth, currentPitch, currentRoll);\n            currentPosition = this.viewport.GetCameraPosition();\n        }\n\n        this.viewport.RotateCameraAroundWorldPoint(coord, azimuthDelta, azimuthPitch);\n\n        if (watchRoll) {\n            const newAzimuth = {};\n            const newPitch = {};\n            const newRoll = {};\n            this.viewport.GetCameraOrientation(newAzimuth, newPitch, newRoll);\n            if (Math.abs(newRoll.Value) === 180) {\n                this.viewport.SetCameraOrientation(currentAzimuth.Value, currentPitch.Value, currentRoll.Value, false);\n                this.viewport.SetCameraPosition(currentPosition);\n            } else {\n                //this.mapMngr.notifyGeneralEvent('maporientationchanged', newAzimuth.Value, this.elementId);\n            }\n        }\n    }\n\n    rotateCameraRelativeToOrientation = (moveX, moveY, factor) => {\n        this.viewport.RotateCameraRelativeToOrientation(moveX * factor, moveY * factor, 0);\n        const azimuthChange = {};\n        this.viewport.GetCameraOrientation(azimuthChange, null, null);\n        //this.mapMngr.notifyGeneralEvent('maporientationchanged', azimuthChange.Value, this.elementId);\n    }\n\n    getCameraScale = (convertToMeters = false) => {\n        let ret;\n        if (!this.state.is3DClicked) {\n            ret = this.viewport.GetCameraScale();\n            if (convertToMeters) {\n                ret /= this.viewport.GetPixelPhysicalHeight();\n                ret = (ret * 10).toFixed(2);\n                ret = parseInt(ret);\n            }\n        } else {\n            ret = this.viewport.GetCameraPosition().z;\n        }\n\n        return ret;\n    }\n    setCameraScale = (scale, factorFor3D = 1, notifyFpAndScale) => {\n        if (!this.state.is3DClicked) {\n            const mapScaleTopLimit = this.mapScaleTopLimit || 200000;\n            this.cameraScaleChanged = true;\n            const pixelPhysicalHeight = this.viewport.GetPixelPhysicalHeight();\n            const ratio = scale / pixelPhysicalHeight;\n            if (ratio < 25) {\n                scale = pixelPhysicalHeight * 25;\n            } else if (ratio > mapScaleTopLimit) {\n                scale = pixelPhysicalHeight * mapScaleTopLimit;\n            }\n            this.viewport.SetCameraScale(scale);\n        } else {\n            const camPosition = this.viewport.GetCameraPosition();\n            let zoomSign = 1;\n            if (scale > camPosition.z) {\n                zoomSign = -1;\n            }\n            const factor = factorFor3D * camPosition.z / 100;\n            this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(0, zoomSign * factor, 0), false);\n        }\n\n        // if (notifyFpAndScale) {\n        //   let fpToUpdate;\n        //   let scaleToUpdate;\n        //   if (!this.state.is3DClicked) {\n        //     // Notify scale change if needed (only in 2d viewport)\n        //     let currentScale = this.viewport.GetCameraScale() / this.viewport.GetPixelPhysicalHeight();\n        //     currentScale = (currentScale * 10).toFixed(2);\n        //     currentScale = parseInt(currentScale);\n\n        //     fpToUpdate = this.viewport.GetCameraFootprint();\n        //     scaleToUpdate = currentScale;\n        //   } else {\n        //     const footPrint = this.calculate3DFootPrint();\n        //     fpToUpdate = footPrint.fp;\n        //     scaleToUpdate = footPrint.scale;\n        //   }\n        //   if (fpToUpdate && fpToUpdate.bUpperLeftFound && fpToUpdate.bUpperRightFound &&\n        //     fpToUpdate.bLowerRightFound && fpToUpdate.bLowerLeftFound) {\n\n        //     this.notifyCameraMove(fpToUpdate, scaleToUpdate, this.elementId);\n        //   }\n        // }\n    }\n\n    updatePositionText = (x, y, z, updateHeight = true) => {\n        let height;\n        try {\n            //when updating position height displayed, use default precision\n            const heightForQuery = {};\n            const lonNew = (Math.abs(x) > 100000) ? x : x * 100000;\n            const latNew = (Math.abs(y) > 100000) ? y : y * 100000;\n            const positionToCheck = new window.MapCore.SMcVector3D(lonNew, latNew, 0);\n            if (this.viewport.GetTerrainHeight(positionToCheck, heightForQuery)) {\n                height = heightForQuery.Value;\n            }\n        } catch (exp) { }\n\n        // Update context with new height\n        if (updateHeight) {\n            this.lastUpdatedHeight = height;\n            console.log('mapheightchanged', height);\n        }\n\n        // Update context with new position\n        // const point = new geo.coordinate(x, y, height);\n        // this.lastPositionChanged = point;\n        // this.mapMngr.notifyGeneralEvent('mappositionchanged', point, this.elementId);\n    }\n\n    zoomIn = (amount, duration) => {\n        const currentScale = this.getCameraScale();\n        this.setCameraScale(currentScale / (amount || 1.5));\n        if (this.lastClickPos) {\n            this.updatePositionText(this.lastClickPos.x, this.lastClickPos.y, this.lastClickPos.z);\n        }\n    }\n\n    zoomOut = (amount, duration) => {\n        const currentScale = this.getCameraScale();\n        this.setCameraScale(currentScale * (amount || 1.5));\n        if (this.lastClickPos) {\n            this.updatePositionText(this.lastClickPos.x, this.lastClickPos.y, this.lastClickPos.z);\n        }\n    }\n\n    handleZoomOrRotate = e => {\n\n        const xDistance = e.touches[0].screenX - e.touches[1].screenX;\n        const yDistance = e.touches[0].screenY - e.touches[1].screenY;\n\n        const currentDistance = Math.abs((xDistance * xDistance) + (yDistance * yDistance));\n\n        if (!this.lastTouchDistance) {\n            this.lastTouchDistance = currentDistance;\n        } else {\n            const zoomIn = currentDistance - this.lastTouchDistance > 0;\n            const difDistance = Math.abs(currentDistance - this.lastTouchDistance);\n\n            // Calculate the average position(screen and geo) of the touches\n            const rect = e.target.getBoundingClientRect();\n\n            const firstTouchX = e.targetTouches[0].pageX - rect.left;\n            const firstTouchY = e.targetTouches[0].pageY - rect.top;\n\n            const secondTouchX = e.targetTouches[1].pageX - rect.left;\n            const secondTouchY = e.targetTouches[1].pageY - rect.top;\n\n            const averageX = (firstTouchX + secondTouchX) / 2;\n            const averageY = (firstTouchY + secondTouchY) / 2;\n\n            const averageWorldPosition = this.screenToWorld(averageX, averageY, { withoutConvert: true });\n\n            let prevAverageX;\n            let prevAverageY;\n\n            if (!this.pinchStatus) {\n                this.pinchStatus = { averageX, averageY, averageWorldPosition };\n            } else {\n                prevAverageX = this.pinchStatus.averageX;\n                prevAverageY = this.pinchStatus.averageY;\n\n                this.pinchStatus.averageX = averageX;\n                this.pinchStatus.averageY = averageY;\n            }\n\n            if (!this.state.is3DClicked) {\n                if (difDistance > 10000) {\n                    //The distance between the touches is big\\small enough for zooming in\\out.\n                    if (zoomIn) {\n                        this.zoomIn(1.05);\n                    } else {\n                        this.zoomOut(1.05);\n                    }\n                    this.lastTouchDistance = currentDistance;\n                }\n            } else if (!this.pinchStatus.coordToRotateAround3D) {\n                if (difDistance > 1000) {\n                    //The distance between the touches is big\\small enough for zooming in\\out.\n                    const zoomFactor = difDistance / 5000;\n                    if (zoomIn) {\n                        this.moveCameraRelativeToOrientation(0, zoomFactor, false, true);\n                    } else {\n                        this.moveCameraRelativeToOrientation(0, -zoomFactor, false, true);\n                    }\n                    this.lastTouchDistance = currentDistance;\n                    prevAverageX = undefined;\n                    prevAverageY = undefined;\n                    this.pinchStatus.zooming3D = true;\n                } else {\n                    this.pinchStatus.zooming3D = false;\n                }\n            }\n\n            if (!this.state.is3DClicked) {\n                // Calculating the angle between the touches for orientation setting\n                const currentRotation = Math.atan2(firstTouchY - secondTouchY, firstTouchX - secondTouchX) * 180 / Math.PI;\n                let difRotation = 0;\n                if (this.lastTouchRotation === undefined) {\n                    //first series of rotations\n                    this.lastTouchRotation = currentRotation;\n                } else {\n                    difRotation = Math.abs(currentRotation - this.lastTouchRotation);\n                    if (difRotation > 0.5) {\n                        const currentCameraOrientation = this.getCameraOrientation().azimuth;\n                        this.setCameraOrientation(currentCameraOrientation + this.lastTouchRotation - currentRotation);\n                        this.lastTouchRotation = currentRotation;\n                    }\n                }\n\n                if (this.pinchStatus) {\n                    // After zooming or changing orientation, set the map so the previous screen position with be placed on\n                    // the same geo position as it was before.\n                    const averageScreenAfterZoom = this.worldToScreen(this.pinchStatus.averageWorldPosition.Value, { native: true });\n                    const scrollX = averageScreenAfterZoom.x - this.pinchStatus.averageX;\n                    const scrollY = averageScreenAfterZoom.y - this.pinchStatus.averageY;\n                    try {\n                        this.viewport.ScrollCamera(scrollX, scrollY);\n                    } catch (exp) {\n                    }\n                }\n            } else {\n                //handle 3d rotating\n                if (prevAverageX || prevAverageY) {\n                    const currentRotation = Math.atan2(firstTouchY - secondTouchY, firstTouchX - secondTouchX) * 180 / Math.PI;\n                    let difRotation = 0;\n                    if (this.lastTouchRotation === undefined) {\n                        //first series of rotations\n                        this.lastTouchRotation = currentRotation;\n                    } else {\n                        difRotation = Math.abs(currentRotation - this.lastTouchRotation);\n                        if (!this.pinchStatus.zooming3D && (difRotation > 2.5 || this.pinchStatus.coordToRotateAround3D)) {\n                            this.pinchStatus.coordToRotateAround3D = this.pinchStatus.coordToRotateAround3D || averageWorldPosition.Value;\n                            const nativeCoord = this.pinchStatus.coordToRotateAround3D;\n                            if (this.isGeoCoordValid(nativeCoord)) {\n                                const rotateSign = Math.sign(this.lastTouchRotation - currentRotation);\n                                this.rotateCameraAroundWorldPoint(nativeCoord, rotateSign * 2, 0, true);\n                            }\n                        } else {\n                            this.cameraMoved = true;\n                            const offsetX = prevAverageX - this.pinchStatus.averageX;\n                            const offsetY = this.pinchStatus.averageY - prevAverageY;\n                            this.rotateCameraRelativeToOrientation(offsetX, offsetY, 0.1);\n                        }\n                        this.lastTouchRotation = currentRotation;\n                    }\n                }\n            }\n        }\n    }\n\n    touchMoveHandler = e => {\n        const isTouch = true;\n        if (e.touches.length === 1) {\n            this.mouseMoveHandler(e, isTouch);\n        } else {\n            this.handleZoomOrRotate(e);\n        }\n        e.preventDefault();\n    }\n\n    touchEndHandler = (e) => {\n        this.isTouch = false;\n        this.pinchStatus = undefined;\n        if (e.touches && e.touches.length) {\n            // Removing only one touch while there is more touches enabled\n            this.disableMoveAfterMultiTouches = true;\n            setTimeout(() => {\n                this.disableMoveAfterMultiTouches = false;\n            }, 200);\n        }\n        if (!e.touches.length) {\n            this.isMouseDown = false;\n            this.lastTouchDistance = 0;\n            this.lastTouchRotation = undefined;\n\n            // Cancel long click listening\n            //clearTimeout(longClick);\n            // Not in edit mode\n            this.dbclickHandled = true;\n\n            // canvas.clickCount++;\n            // if (canvas.clickCount === 1) {\n            //     singleClick = setTimeout(e => {\n            //     canvas.clickCount = 0;\n            //     this.onLeftClick(e) || this.stopEvent(e);\n            //     }, 200, e);\n            // } else if (canvas.clickCount === 2) {\n            //     clearTimeout(singleClick);\n            //     canvas.clickCount = 0;\n            //     this.onLeftDoubleClick(e);\n            // }\n        }\n\n        e.preventDefault();\n        e.target.focus()\n    }\n\n    touchCancelHandler = (e) => { }\n\n    createViewport(terrain, eMapTypeToOpen) {\n        // create canvas if needed\n        let currCanvas;\n        if (!this.state.bSameCanvas || this.aViewports.length == 0) {\n            // create canvas\n            currCanvas = document.createElement('canvas');\n            //currCanvas.style.border = \"thick solid #FFFFFF\"; \n\n            currCanvas.addEventListener(\"wheel\", this.mouseWheelHandler, false);\n            currCanvas.addEventListener(\"mousemove\", this.mouseMoveHandler, false);\n            currCanvas.addEventListener(\"mousedown\", this.mouseDownHandler, false);\n            currCanvas.addEventListener(\"mouseup\", this.mouseUpHandler, false);\n            currCanvas.addEventListener(\"dblclick\", this.mouseDblClickHandler, false);\n\n            currCanvas.addEventListener(\"touchstart\", this.touchStartHandler, false);\n            currCanvas.addEventListener(\"touchend\", this.touchEndHandler, false);\n            currCanvas.addEventListener(\"touchmove\", this.touchMoveHandler, false);\n            currCanvas.addEventListener(\"touchcancel\", this.touchCancelHandler, false);\n        }\n        else {\n            // use existing canvas\n            currCanvas = this.aViewports[0].canvas;\n        }\n\n        // create viewport\n        let layerGroup = this.state.mapLayerGroups.get(this.state.lastTerrainConfiguration);\n        let vpCreateData = new window.MapCore.IMcMapViewport.SCreateData(eMapTypeToOpen);\n        vpCreateData.pDevice = this.device;\n        vpCreateData.pCoordinateSystem = (terrain != null ? terrain.GetCoordinateSystem() : this.overlayManager.GetCoordinateSystemDefinition());\n        vpCreateData.pOverlayManager = this.overlayManager;\n        vpCreateData.hWnd = currCanvas;\n        if (layerGroup.bShowGeoInMetricProportion) {\n            vpCreateData.bShowGeoInMetricProportion = true;\n        }\n        this.viewport = window.MapCore.IMcMapViewport.Create(/*Camera*/null, vpCreateData, terrain != null ? [terrain] : null);\n        this.editMode = window.MapCore.IMcEditMode.Create(this.viewport);\n\n        // add camera-update callback\n        let callback = new this.CCameraUpdateCallback();\n        this.viewport.AddCameraUpdateCallback(callback);\n\n        if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\n            this.viewport.SetScreenSizeTerrainObjectsFactor(1.5);\n            this.viewport.SetCameraRelativeHeightLimits(3, 10000, true);\n        }\n        else {\n            this.viewport.SetStaticObjectsVisibilityMaxScale(50);\n            if (layerGroup.InitialScale2D) {\n                this.viewport.SetCameraScale(layerGroup.InitialScale2D);\n            }\n        }\n\n        this.viewport.SetBackgroundColor(window.MapCore.SMcBColor(70, 70, 70, 255));\n\n        // set object delays for optimazing rendering objects\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_UPDATE, true, 50);\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_CONDITION, true, 50);\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_SIZE, true, 5);\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_HEIGHT, true, 50);\n\n        // set objects movement threshold\n        this.viewport.SetObjectsMovementThreshold(1);\n\n        // set terrain cache\n        if (terrain != null) {\n            this.viewport.SetTerrainNumCacheTiles(terrain, false, 300);\n            this.viewport.SetTerrainNumCacheTiles(terrain, true, 300);\n        }\n\n        let viewportData = new SViewportData(this.viewport, this.editMode);\n        viewportData.terrain = terrain;\n        if (layerGroup.bSetTerrainBoxByStaticLayerOnly) {\n            viewportData.bSetTerrainBoxByStaticLayerOnly = true;\n        }\n\n        this.aViewports.push(viewportData);\n        const canvasParent = document.getElementById('canvasesContainer')\n        canvasParent.appendChild(currCanvas);\n        this.activeViewport = this.aViewports.length - 1;\n\n        this.updateActiveViewport();\n        this.resizeCanvases();\n        this.trySetTerainBox();\n    }\n\n    // function updating active viewport / Edit Mode and canvas borders\n    updateActiveViewport() {\n        if (this.activeViewport >= 0) {\n            for (let i = 0; i < this.aViewports.length; ++i) {\n                if (i == this.activeViewport) {\n                    this.viewport = this.aViewports[i].viewport;\n                    this.editMode = this.aViewports[i].editMode;\n                    if (!this.state.bSameCanvas) {\n                        //this.aViewports[i].canvas.style.borderColor = \"blue\";\n                    }\n                }\n                else {\n                    //this.aViewports[i].canvas.style.borderColor = \"white\";\n                }\n            }\n        }\n    }\n\n    doPrevViewport() {\n        if (this.aViewports.length > 1) {\n            this.activeViewport = (this.activeViewport + this.aViewports.length - 1) % this.aViewports.length;\n            this.updateActiveViewport();\n        }\n    }\n\n    doNextViewport() {\n        if (this.aViewports.length > 1) {\n            this.activeViewport = (this.activeViewport + 1) % this.aViewports.length;\n            this.updateActiveViewport();\n        }\n    }\n\n    // function creating terrain overlayManager and viewport, starting rendering\n    initializeViewports() {\n        let terrain = this.mapTerrains.get(this.state.lastTerrainConfiguration);\n        if (terrain == undefined) {\n            if (this.aLastTerrainLayers.length > 0) {\n                terrain = window.MapCore.IMcMapTerrain.Create(this.lastCoordSys, this.aLastTerrainLayers);\n                terrain.AddRef();\n            }\n            else {\n                terrain = null;\n            }\n            this.mapTerrains.set(this.state.lastTerrainConfiguration, terrain);\n        }\n\n        // create overlay manager\n        if (this.overlayManager == null) {\n            if (this.lastCoordSys == null) {\n                this.lastCoordSys = window.MapCore.IMcGridUTM.Create(36, window.MapCore.IMcGridCoordinateSystem.EDatumType.EDT_ED50_ISRAEL);\n                this.lastCoordSys.AddRef();\n            }\n            this.overlayManager = window.MapCore.IMcOverlayManager.Create(this.lastCoordSys);\n            this.overlayManager.AddRef();\n\n            // create overlay for objects\n            this.overlay = window.MapCore.IMcOverlay.Create(this.overlayManager);\n\n        }\n\n        // create map viewports\n        switch (this.state.lastViewportConfiguration) {\n            case \"2D/3D\":\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\n                this.DoPrevViewport();\n                break;\n            case \"3D/2D\":\n                if (this.state.bSameCanvas) {\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\n                }\n                else {\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\n                    this.doPrevViewport();\n                }\n                break;\n            case \"2D\":\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\n                break;\n            case \"3D\":\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\n                break;\n        }\n\n        // example of try-catch MapCoreError\n        try {\n            // MapCore API function call\n        }\n        catch (ex) {\n            if (ex instanceof window.MapCoreError) {\n                alert(\"MapCore Error #\" + ex.name + \": \" + ex.message);\n            }\n            else {\n                throw ex;\n            }\n        }\n\n        // ask the browser to render once\n        requestAnimationFrame(this.renderMapContinuously);\n    }\n\n    createMapLayersAndViewports() {\n        // if this terrain has not been created yet\n        if (this.mapTerrains.get(this.state.lastTerrainConfiguration) == undefined) {\n            this.aLastTerrainLayers = [];\n            let group = this.state.mapLayerGroups.get(this.state.lastTerrainConfiguration);\n            // create coordinate system by running a code string prepared during parsing configuration files (JSON configuration file and capabilities XML of MapCoreLayerServer)\n            // e.g. MapCore.IMcGridCoordSystemGeographic.Create(MapCore.IMcGridCoordinateSystem.EDatumType.EDT_WGS84)\n            this.lastCoordSys = eval(group.coordSystemString);\n\n            for (let i = 0; i < group.aLayerCreateStrings.length; ++i) {\n                // create map layer by running code string prepared during parsing configuration files (JSON configuration file and capabilities XML of MapCoreLayerServer)\n                // e.g. MapCore.IMcNativeRasterMapLayer.Create('http:Maps/Raster/SwissOrtho-GW') or CreateWMTSRasterLayer(...) or CreateWMSRasterLayer(...)\n                const layer = eval(group.aLayerCreateStrings[i]);\n                this.aLastTerrainLayers.push(layer);\n                if (layer instanceof window.MapCore.IMc3DModelMapLayer) {\n                    layer.SetDisplayingItemsAttachedToTerrain(true);\n                    layer.SetDisplayingDtmVisualization(true);\n                }\n            }\n            this.lastCoordSys.AddRef();\n        }\n\n        this.initializeViewports();\n    }\n\n    // async callGetCapabilitiesApi() {\n    //     try {\n    //         const response = await axios.get(config.urls.getCapabilities);\n    //         const capabilitiesXMLDoc =  new DOMParser().parseFromString(response.data, \"text/xml\");\n    //         this.parseCapabilitiesXML(capabilitiesXMLDoc, config.urls.getCapabilities);\n    //         this.openMap(this.context.mapToPreview.title);\n\n    //     } catch (e) {\n    //         \n    //     }\n    // }\n\n    async openMap(title, is3d) {\n        const serverUrl = externalConfig.getConfiguration().MAPCORE_LAYER_SERVER_URL;\n        if (serverUrl) {\n            try {\n                const response = await axios.get(serverUrl + config.urls.getCapabilities);\n                const capabilitiesXMLDoc = new DOMParser().parseFromString(response.data, \"text/xml\");\n                this.parseCapabilitiesXML(capabilitiesXMLDoc, config.urls.getCapabilities);\n            } catch (e) {\n            }\n        } else {\n            this.parseLayersConfiguration([this.props.mapToShow])\n        }\n\n\n        this.state.mapLayerGroups.forEach((value, key) => {\n            if (key === title) {\n\n                this.setState({\n                    lastTerrainConfiguration: key,\n                    lastViewportConfiguration: is3d ? \"3D\" : \"2D\"\n                }, () => {\n                    if (this.device === null) {\n                        // create map device (MapCore initialization)\n                        let init = new window.MapCore.IMcMapDevice.SInitParams();\n                        init.uNumTerrainTileRenderTargets = 100;\n\n                        const device = window.MapCore.IMcMapDevice.Create(init);\n                        device.AddRef();\n                        this.device = device;\n\n                        // create callback classes\n                        this.createCallbackClasses();\n                    }\n                    this.createMapLayersAndViewports();\n                });\n            }\n        })\n    }\n\n    doDtmVisualization() {\n        if (!this.viewport.GetDtmVisualization()) {\n            let result = this.calcMinMaxHeights();\n            let DtmVisualization = new window.MapCore.IMcMapViewport.SDtmVisualizationParams();\n            window.MapCore.IMcMapViewport.SDtmVisualizationParams.SetDefaultHeightColors(DtmVisualization, result.minHeight, result.maxHeight);\n            DtmVisualization.bDtmVisualizationAboveRaster = true;\n            DtmVisualization.uHeightColorsTransparency = 120;\n            DtmVisualization.uShadingTransparency = 255;\n            this.viewport.SetDtmVisualization(true, DtmVisualization);\n        }\n        else {\n            this.viewport.SetDtmVisualization(false);\n        }\n    }\n\n    // function closing active viewport\n    closeMap() {\n        if (this.activeViewport < 0) {\n            return;\n        }\n        // delete Edit Mode\n        this.editMode.Destroy();\n        // delete viewport\n        this.viewport.Release();\n        if (!this.bSameCanvas || this.aViewports.length == 1) {\n            // delete canvas\n            let currCanvas = this.aViewports[this.activeViewport].canvas;\n            currCanvas.removeEventListener(\"wheel\", this.mouseWheelHandler, false);\n            currCanvas.removeEventListener(\"mousemove\", this.mouseMoveHandler, false);\n            currCanvas.removeEventListener(\"mousedown\", this.mouseDownHandler, false);\n            currCanvas.removeEventListener(\"mouseup\", this.mouseUpHandler, false);\n            currCanvas.removeEventListener(\"dblclick\", this.mouseDblClickHandler, false);\n            currCanvas.removeEventListener(\"touchstart\", this.touchStartHandler, false);\n            currCanvas.removeEventListener(\"touchend\", this.touchEndHandler, false);\n            currCanvas.removeEventListener(\"touchmove\", this.touchMoveHandler, false);\n            currCanvas.removeEventListener(\"touchcancel\", this.touchCancelHandler, false);\n\n            let canvasParent = document.getElementById('canvasesContainer');\n            canvasParent.removeChild(this.aViewports[this.activeViewport].canvas);\n        }\n        // remove viewport from viewport data array\n        //this.activeViewport.viewport = this.activeViewport.viewport ? null :;\n        this.aViewports.splice(this.activeViewport, 1);\n        if (this.aViewports.length == 0) {\n            // no more viewports\n            this.viewport = null;\n            this.editMode = null;\n            this.activeViewport = -1;\n            // delete terrain\n            this.mapTerrains.forEach(terrain => { terrain.Release(); });\n            this.mapTerrains.clear();\n            // delete overlay manager\n            this.overlayManager.Release();\n            this.overlayManager = null;\n\n        }\n        else {\n            // there are viewports: update active viewport\n            if (this.activeViewport >= this.aViewports.length) {\n                this.activeViewport = this.aViewports.length - 1;\n            }\n            this.updateActiveViewport();\n            this.resizeCanvases();\n        }\n\n\n        this.setState({\n            mapLayerGroups: new Map(),\n            lastTerrainConfiguration: null,\n            lastViewportConfiguration: null /*  2D/3D, 3D/2D, 2D, 3D */,\n            bSameCanvas: true\n        });\n\n        this.mapTerrains = new Map;\n        this.device = null\n        this.viewportData = null;\n        this.aLastTerrainLayers = [];\n        this.lastCoordSys = null;\n        this.overlayManager = null;\n        this.activeViewport = -1;\n        this.aViewports = [];\n        this.lastRenderTime = (new Date).getTime();\n        this.lastMemUsageLogTime = (new Date).getTime();\n        this.uMemUsageLoggingFrequency = 0;\n        this.nMousePrevX = 0;\n        this.nMousePrevY = 0;\n        this.mouseDownButtons = 0;\n        this.bEdit = false;\n\n    }\n\n    renderLoadingMessage() {\n        return (\n            <div className={cn.LoadingMessage}>\n                Map core SDK is Loading...\n            </div>\n        )\n    }\n\n    renderRow(label, value) {\n        return (\n            <div className={cn.DescRow}>\n                <span className={cn.DescLabel}>{label}:</span>\n                <span className={cn.DescValue}>{value}</span>\n            </div>\n        )\n    }\n\n    onSelectOtherMapClicked = () => {\n        this.setState({ isSwitchMapFormOpen: true });\n    }\n\n    showHideDtmActionClicked = () => {\n        this.setState({ isDTMClicked: !this.state.isDTMClicked }, this.doDtmVisualization)\n    }\n\n    showHide3DActionClicked = () => {\n        this.setState(\n            {\n                is3DClicked: !this.state.is3DClicked\n            }, () => this.openMap(this.props.mapToShow.groupName, this.state.is3DClicked))\n    }\n\n    onMoreActionsClick = (e) => {\n        e.preventDefault();\n        e.stopPropagation();\n\n        const selectOtherMapAction = {\n            name: \"Select Other Map\",\n            func: this.onSelectOtherMapClicked,\n            iconCss: \"Map\"\n        };\n\n        const menuItemsList = [];\n\n        const dtmLayer = this.props.mapToShow.layers.find(layer => layer.type.toLowerCase().includes('dtm'));\n\n        if (true) {\n            const showHideDtmAction = {\n                name: (this.state.isDTMClicked ? 'Hide' : 'Show') + \" DTM visualization\",\n                func: () => this.showHideDtmActionClicked(),\n                iconCss: \"DTM\"\n            }\n            const selectOrigin = {\n                name: \"Select Origin\",\n                func: () => this.createOriginText(),\n                iconCss: \"DTM\"\n            }\n            const showHide3DAction = {\n                name: 'Switch To ' + (this.state.is3DClicked ? '2D' : '3D'),\n                func: this.showHide3DActionClicked,\n                iconCss: \"ThreeD\"\n            }\n\n            menuItemsList.push(showHideDtmAction);\n            menuItemsList.push(showHide3DAction);\n            menuItemsList.push(selectOtherMapAction);\n            menuItemsList.push(selectOrigin);\n        }\n\n        this.props.showContextMenu(e.nativeEvent.x, e.nativeEvent.y, menuItemsList);\n    }\n\n    renderMapToolbox() {\n        return (\n            <div className={`${cn.MapToolbox}`}>\n                <div className={cn.Description}>\n                    {this.props.mapToShow.groupName}\n                </div>\n                <span className={cn.MoreActionsBtn} onClick={this.onMoreActionsClick}></span>\n            </div>\n        )\n    }\n\n    renderSwitchMapForm() {\n        const isOpenClass = this.state.isSwitchMapFormOpen ? cn.Open : '';\n        return (\n            <div className={`${cn.SwitchMapForm} ${isOpenClass}`}>\n                {isOpenClass ? <SwitchMapForm onCancel={() => this.setState({ isSwitchMapFormOpen: false })} /> : null}\n            </div>\n        )\n    }\n\n    getCanvas() {\n        return (\n            <div className={cn.MapWrapper}>\n                <div className={cn.CanvasContainer} id='canvasesContainer'></div>\n                {this.renderMapToolbox()}\n                {this.renderSwitchMapForm()}\n            </div>\n        );\n    }\n\n    render() {\n        return (\n            <div className={cn.Wrapper}>\n                {this.props.isMapCoreSDKLoaded ? this.getCanvas() : this.renderLoadingMessage()}\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        isMapCoreSDKLoaded: state.map.isMapCoreSDKLoaded,\n        mapToShow: state.map.mapToShow,\n        dronePositionOffset: state.map.dronePositionOffset\n    };\n};\n\nconst mapDispachToProps = (dispatch) => {\n    return {\n        showContextMenu: (x, y, items) => dispatch({ type: actionTypes.SHOW_CONTEXT_MENU, payload: { x, y, items } }),\n        closeContextMenu: () => dispatch({ type: actionTypes.CLOSE_CONTEXT_MENU }),\n        subscribeToDroneData: () => dispatch(actions.subscribeToDroneData())\n    };\n};\n\nexport default connect(mapStateToProps, mapDispachToProps)(MapContainer);","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\FlightTelemetry\\FlightTelemetry.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Clock\\Clock.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\ContextMenu\\ContextMenu.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Video\\Video.js",["239","240","241","242"],"import React, { Component } from 'react';\nimport cn from './Video.module.css';\nimport { connect } from 'react-redux';\nimport actions from '../../store/actions';\nimport actionTypes from '../../store/actions/actionTypes';\nimport externalConfig from '../../ExternalConfigurationHandler';\nimport config, { devVideoSnapshotUrl, devVideoStreamUrl } from '../../config';\nimport targetIcon from '../../assets/images/target.svg';\nimport Slider from '../controls/Slider/Slider';\n\n\nclass Video extends Component {\n\n    state = {\n        isImageLoadingError: false,\n        isImageLoading: true,\n        isFullScreen: false,\n        targetPosition: null,\n        showTarget: true,\n        showExposure: false,\n        isRecording: false\n\n    }\n\n    componentDidMount() {\n        //window.addEventListener('resize', this.setTargetPosition)\n    }\n\n    getVideoSrc() {\n        const { BE_PORT, BE_IP } = externalConfig.getConfiguration();\n\n        const snapshotUrl = `//${BE_IP}:${BE_PORT}${config.urls.videoSnapshot}`;\n        const streamUrl = `//${BE_IP}:${BE_PORT}${config.urls.videoStream}`;\n\n        if (this.props.isPaused) {\n            return process.env.NODE_ENV === 'development' ? snapshotUrl : snapshotUrl;\n        } else {\n            return process.env.NODE_ENV === 'development' ? streamUrl : streamUrl;\n        }\n    }\n\n    onVideoError = (e) => {\n        console.log('error when trying to load camera video', e);\n        this.setState({\n            isImageLoadingError: true\n        })\n    }\n\n    setTargetPosition = () => {\n        const img = document.getElementById('droneImage');\n        if (!img) return;\n        const rect = img.getBoundingClientRect();\n        if (!rect) return;\n\n        this.setState({\n            targetPosition: {\n                top: rect.top + (rect.height / 2),\n                left: rect.left + (rect.width / 2)\n            }\n        })\n    }\n\n    onVideoLoaded = e => {\n        //this.setTargetPosition();\n        this.setState({\n            isImageLoading: false\n        })\n    }\n\n    onPauseOrPlayClick = e => {\n        e.stopPropagation();\n        this.props.isPaused ? this.props.resume() : this.props.pause()\n    }\n\n    onFullScreenClick = () => {\n        //const elem = document.querySelector('#droneImage');\n        const elem = document.querySelector('#videoWrapper');\n        if (elem.requestFullscreen) {\n            elem.requestFullscreen();\n        } else if (elem.webkitRequestFullscreen) { /* Safari */\n            elem.webkitRequestFullscreen();\n        } else if (elem.msRequestFullscreen) { /* IE11 */\n            elem.msRequestFullscreen();\n        }\n        this.setState({ isFullScreen: true })\n    }\n\n    onExitFullScreenClick = () => {\n        if (document.exitFullscreen) {\n            document.exitFullscreen();\n        } else if (document.webkitExitFullscreen) { /* Safari */\n            document.webkitExitFullscreen();\n        } else if (document.msExitFullscreen) { /* IE11 */\n            document.msExitFullscreen();\n        }\n        this.setState({ isFullScreen: false })\n    }\n\n    getPlayOrPauseButton() {\n        return this.props.isPaused ? cn.Play : cn.Pause\n    }\n\n    getPlayOrPauseTitle() {\n        return this.props.isPaused ? 'Play' : 'Pause'\n    }\n\n    getRecordButton = () => {\n        return this.state.isRecording ? cn.RecordindIcon : cn.RecordIcon\n    }\n\n    getRecordTitle = () => {\n        return this.state.isRecording ? 'Recording' : 'Start Recording'\n    }\n\n    renderVideoHeader() {\n        const hideTargetClass = this.state.showTarget ? '' : cn.HideTarget;\n        return (\n            <div className={`${cn.VideoHeader}`}>\n                <div className={cn.Description}>\n                    {this.props.isPaused ? 'Video paused' :\n                        <span className={cn.StreamingIconWrapper}>Video Feed<span className={cn.StreamingIcon} /></span>\n                    }\n                </div>\n                <span className={`${cn.Exposure}`}\n                    onClick={() => this.setState({ showExposure: !this.state.showExposure })}>\n                </span>\n                {this.props.weaponDetected && <span className={`${cn.ToggleTarget} ${hideTargetClass}`}\n                    onClick={() => this.setState({ showTarget: !this.state.showTarget })}>\n                </span>\n                }\n            </div>\n        )\n    }\n\n    renderVideoFooter() {\n        return (\n            <>\n                <button\n                    onClick={this.onPauseOrPlayClick}\n                    title={this.getPlayOrPauseTitle()}\n                    className={`${cn.ControlBtn} ${this.getPlayOrPauseButton()}`}>\n                </button>\n                <button\n                    onClick={() => this.setState({ isRecording: !this.state.isRecording })}\n                    title={this.getRecordTitle()}\n                    className={`${cn.ControlBtn} ${cn.RecordButton}`}>\n                    <span className={`${this.getRecordButton()}`} />\n                </button>\n                <button\n                    onClick={this.state.isFullScreen ? this.onExitFullScreenClick : this.onFullScreenClick}\n                    title={this.state.isFullScreen ? 'Exit Full Screen' : 'Full Screen'}\n                    className={`${cn.ControlBtn} ${this.state.isFullScreen ? cn.ExitFullScreen : cn.FullScreen}`}>\n                </button>\n            </>\n        )\n    }\n\n    updateExposure(sliderOffset) {\n        const exposureValue = 500 * (100 - sliderOffset) / 100;\n        console.log(\"new exposureValue is \", exposureValue);\n        this.setState({ sliderOffset });\n        this.props.setExposure(exposureValue)\n    }\n\n    renderImgElement() {\n\n        if (this.state.isImageLoadingError) {\n            return (\n                <div className={cn.ErrorMessage}><span className={cn.ErrorIcon}></span> Error loading video stream</div>\n            )\n        }\n        const largeTarget = this.state.isFullScreen ? ` ${cn.TargetLarge}` : '';\n        return (\n            <>\n                {this.renderVideoHeader()}\n\n                {this.state.showTarget && this.props.weaponDetected &&\n                    <img className={`${cn.TargetIcon}${largeTarget}`} style={this.state.targetPosition} src={targetIcon} />\n                }\n\n                {this.state.showExposure &&\n                    <Slider sliderOffset={this.state.sliderOffset} updatePosition={(offset) => this.updateExposure(offset)} />\n                }\n\n                <img\n                    crossOrigin=\"anonymous\"\n                    onLoad={this.onVideoLoaded}\n                    onError={this.onVideoError}\n                    className={cn.VideoImage}\n                    src={this.getVideoSrc()}\n                    id='droneImage'\n                    onClick={this.props.pointVideoImage}\n                //onTouchStart={this.props.pointVideoImage}\n                />\n                {this.renderVideoFooter()}\n            </>\n        )\n    }\n\n    render() {\n        const fullHeightClass = this.state.isImageLoadingError || this.state.isImageLoading ? cn.FullHeight : '';\n        return (\n            <div className={`${cn.Wrapper} ${fullHeightClass}`} id='videoWrapper'>\n                {this.renderImgElement()}\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        isPaused: state.video.isPaused,\n        weaponDetected: state.output.weaponDetected,\n    };\n};\n\nconst mapDispachToProps = (dispatch) => {\n    return {\n        pointVideoImage: e => dispatch(actions.pointVideoImage(e)),\n        setExposure: exposureValue => dispatch(actions.setExposure(exposureValue)),\n        pause: () => dispatch({ type: actionTypes.PAUSE_VIDEO }),\n        resume: () => dispatch({ type: actionTypes.RESUME_VIDEO }),\n    };\n};\n\nexport default connect(mapStateToProps, mapDispachToProps)(Video);\n\n\n","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\index.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\mapReducer.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\videoReducer.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\outputReducer.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\reducers\\layoutReducer.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\Popup\\PopupChildren.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\SwitchMapForm\\SwitchMapForm.js",["243"],"import React, { Component } from 'react'\nimport cn from './SwitchMapForm.module.css';\nimport actionTypes from '../../store/actions/actionTypes';\nimport { connect } from 'react-redux';\nimport externalConfig from '../../ExternalConfigurationHandler';\nimport RadioGroup from '../controls/RadioGroup/RadioGroup';\nimport Radio from '../controls/Radio/Radio';\n\nclass SwitchMapForm extends Component {\n    state = {\n        isShown: false,\n        selectedGroup: this.props.currentShownMap\n    }\n\n    renderHeader() {\n        return (\n            <div className={cn.Header}>\n                Select Map to Show:\n            </div>\n        )\n    }\n\n    componentDidMount() {\n        setTimeout(() => this.setState({isShown: true}), 300)\n    }\n\n    selectMapRadioButton(selectedGroup) {\n        this.setState({\n            selectedGroup\n            })\n    }\n\n    renderBody() {\n        const layers = externalConfig.getConfiguration().streamingLayers;\n        const maps = layers.map(item => <div>{item.groupName}</div>)\n\n        return (\n            <div className={cn.Body}>\n                <RadioGroup>\n                    {layers.map((item, i) => {\n                        return (\n                            <Radio\n                                key={i}\n                                id={item.groupName}\n                                isChecked={item.groupName === this.state.selectedGroup.groupName}\n                                label={item.groupName}\n                                onClick={() => this.selectMapRadioButton(item)} />\n                        )\n                    })}\n                </RadioGroup>\n            </div>\n        )\n    }\n\n    onMapSelection = () => {\n        if (this.state.selectedGroup.groupName !== this.props.currentShownMap.groupName) {\n\n            this.props.setMapToShow(this.state.selectedGroup);            \n        }\n        this.props.onCancel()\n    }\n\n    renderFooter() {\n        return (\n            <div className={cn.Footer}>\n                <button className={`${cn.Button} ${cn.Apply}`} onClick={this.onMapSelection}>Select</button>\n                <button className={`${cn.Button}`} onClick={this.props.onCancel}>Cancel</button>\n            </div>\n        )\n    }\n\n    render() {\n        const isShownClass = this.state.isShown ? cn.Shown : '';\n        return (\n            <div className={`${cn.Wrapper} ${isShownClass}`}>\n                {this.renderHeader()}\n                {this.renderBody()}\n                {this.renderFooter()}\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = state => {\n    return {      \n      currentShownMap: state.map.mapToShow,\n    }\n  };\n\nconst mapDispachToProps = (dispatch) => {\n    return {        \n        setMapToShow: groupNode => dispatch({type: actionTypes.SET_MAP_TO_SHOW, payload: groupNode})\n    };\n};\n\nexport default connect(mapStateToProps, mapDispachToProps)(SwitchMapForm);","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\Slider\\Slider.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\outputActions.js",["244","245","246","247","248"],"import actionTypes from './actionTypes';\nimport axios from 'axios';\nimport { urls, logSeverities } from '../../config';\nimport { getService } from '../../services';\n\n","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\mapActions.js",["249","250","251","252"],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\videoActions.js",["253"],"import actionTypes from './actionTypes';\nimport { getBase64Image } from '../../utils/imageUtils';\nimport { getService } from '../../services';\nimport { logSeverities } from '../../config';\nimport { showGlobalMessage } from './layoutActions';\n\nexport const locate = () => {\n    return async (dispatch) => {\n        dispatch({ type: actionTypes.LOACTE_START });\n\n        const img = document.getElementById('droneImage');\n        if (img) {\n            const imgURL = getBase64Image(img);\n            //dispach img to send and pixel\n            dispatch({ type: actionTypes.IMAGE_SENT_TO_DRONE, payload: { image: imgURL } });\n\n            const dataX = imgURL && imgURL.replace(\"data:image/jpeg;base64,\", \"\");\n            if (!dataX) {\n                dispatch({ type: actionTypes.LOACTE_FAILED });\n                return;\n            }\n\n            const imageMessage = new window.ROSLIB.Message({ data: dataX, format: \"jpeg\" });\n            const requestLocate = new window.ROSLIB.ServiceRequest({ image: imageMessage });\n\n            getService('pointingFingerLocate').callService(requestLocate, result => {\n                if (result.isSuccess) {\n                    dispatch({ type: actionTypes.LOACTE_SUCCESS });\n                } else {\n                    dispatch({ type: actionTypes.LOACTE_FAILED });\n                }\n                console.log(getService('pointingFingerLocate').name, result)\n            });\n        } else {\n            dispatch({ type: actionTypes.LOACTE_FAILED });\n        }\n    };\n};\n\nexport const pointVideoImage = ev => {\n    return async (dispatch) => {\n        dispatch({ type: actionTypes.POINT_ON_VIDEO_IMAGE_START });\n\n        const img = document.getElementById('droneImage');\n        // Adjusting pixel to original img sizes\n        const adjustedX = (ev.pageX - img.getBoundingClientRect().x) / img.width * img.naturalWidth;\n        const adjustedY = (ev.pageY - img.getBoundingClientRect().y) / img.height * img.naturalHeight;\n\n        console.log(adjustedX, adjustedY);\n\n        const roundedX = Math.round(adjustedX);\n        const roundedY = Math.round(adjustedY);\n        dispatch(showGlobalMessage({ text: `selected pixel: (${roundedX}, ${roundedY})`, type: logSeverities.info, isRemoved: true }));\n\n        if (img) {\n            const imgURL = getBase64Image(img);\n            //dispach img to send and pixel\n            dispatch({ type: actionTypes.IMAGE_SENT_TO_DRONE, payload: { image: imgURL, point: { roundedX, roundedY } } });\n\n            const dataX = imgURL && imgURL.replace(\"data:image/jpeg;base64,\", \"\");\n            if (!dataX) {\n                dispatch({ type: actionTypes.POINT_ON_VIDEO_IMAGE_FAILED });\n                return;\n            }\n            const imageMessage = new window.ROSLIB.Message({ data: dataX, format: \"jpeg\" });\n\n            const pointMessage = new window.ROSLIB.Message({\n                x: roundedX,\n                y: roundedY,\n                z: 0.0\n            });\n\n            const requestEncode = new window.ROSLIB.ServiceRequest({ image: imageMessage, point: pointMessage });\n\n            getService('pointingFingerEncode').callService(requestEncode, result => {\n\n                console.log(getService('pointingFingerEncode').name, result);\n            });\n\n            const requestLocate = new window.ROSLIB.ServiceRequest({ image: imageMessage });\n\n            getService('pointingFingerLocate').callService(requestLocate, result => {\n                if (result.isSuccess) {\n                    dispatch({ type: actionTypes.POINT_ON_VIDEO_IMAGE_SUCCESS });\n                }\n                console.log(getService('pointingFingerLocate').name, result);\n            });\n\n        } else {\n            dispatch({ type: actionTypes.POINT_ON_VIDEO_IMAGE_FAILED });\n        }\n    };\n};\n\nexport const reset = () => {\n    return async (dispatch) => {\n        dispatch({ type: actionTypes.RESET_START });\n\n        const requestReset = new window.ROSLIB.ServiceRequest({});\n\n        getService('pointingFingerReset').callService(requestReset, result => {\n            if (result.isSuccess) {\n                dispatch({ type: actionTypes.RESET_SUCCESS });\n            } else {\n                dispatch({ type: actionTypes.RESET_FAILED });\n            }\n            console.log(getService('pointingFingerReset').name, result)\n        });\n\n        getService('seekerReset').callService(requestReset, function (result) {\n            console.log('Result for service call on ' + getService('seekerReset').name + ': ' + result.isSuccess);\n            console.log(getService('seekerReset').name, result)\n        });\n\n    };\n};\n\nexport const takeoff = () => {\n    return async (dispatch) => {\n        dispatch({ type: actionTypes.TAKE_OFF_START });\n        dispatch({ type: actionTypes.SHOW_GLOBAL_MESSAGE, payload: { text: `Taking off...`, type: logSeverities.info } });\n\n        const requestTakeoff = new window.ROSLIB.ServiceRequest({});\n\n        getService('seekerTakeoff').callService(requestTakeoff, result => {\n            if (result.isSuccess) {\n                dispatch({ type: actionTypes.TAKE_OFF_SUCCESS });\n            } else {\n                dispatch({ type: actionTypes.TAKE_OFF_FAILED });\n                dispatch({ type: actionTypes.SHOW_GLOBAL_MESSAGE, payload: { text: `Taking off failed...`, type: logSeverities.error } });\n            }\n            console.log(result)\n        });\n    };\n};\n\nexport const goToLocation = (location) => {\n    return async (dispatch) => {\n        dispatch({ type: actionTypes.GO_TO_LOCATION_START });\n        dispatch(showGlobalMessage({ text: `Go To Location ${location}`, type: logSeverities.info, isRemoved: true }));\n\n        const [x, y, z] = location.split(',');\n        const pointMessage = new window.ROSLIB.Message({\n            x: parseFloat(x),\n            y: parseFloat(y),\n            z: parseFloat(z)\n        });\n\n        getService('flyToTopic').publish(pointMessage);\n    };\n};\n\n\n\nexport const setExposure = (exposureVal) => {\n    return async (dispatch) => {\n        dispatch({ type: actionTypes.SET_EXPOSURE_START });\n        dispatch({ type: actionTypes.SHOW_GLOBAL_MESSAGE, payload: { text: `Setting Exposure...`, type: logSeverities.info } });\n\n        const setExposure = new window.ROSLIB.ServiceRequest({\n            config: {\n                bools: [], strs: [], strs: [], doubles: [], groups: [],\n                ints: [\n                    { name: 'exposure', value: exposureVal }\n                ],\n\n            }\n        });\n\n        getService('setExposure').callService(setExposure, result => {\n            if (result.isSuccess) {\n                dispatch({ type: actionTypes.SET_EXPOSURE_SUCCESS });\n            } else {\n             //   dispatch({ type: actionTypes.SET_EXPOSURE_FAILED });\n              //  dispatch({ type: actionTypes.SHOW_GLOBAL_MESSAGE, payload: { text: `Setting Exposure failed...`, type: logSeverities.error } });\n            }\n            console.log(result)\n        });\n    };\n};\n\n\n","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\store\\actions\\layoutActions.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\GoToLocationForm\\GoToLocationForm.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\RadioGroup\\RadioGroup.js",["254"],"import React, {Component} from 'react';\nimport cn from './RadioGroup.module.css';\n\nexport default class RadioGroup extends Component {\n\n    constructor(props) {\n        super(props);\n    }\n\n    render() {\n        return (            \n            <div className={cn.Wrapper}>\n                {this.props.label ? <legend className={cn.Label}>{this.props.label}</legend> : null}\n                <div className={cn.RadioGroupValuesWrapper}>\n                    {\n                        this.props.children.map((child, i) => \n                            React.cloneElement(child, {\n                                key: i,\n                                onClick: () => child.props.onClick(i),\n                                isChecked: child.props.isChecked,\n                                radioIndex: i\n                            })\n                        )\n                    }\n                </div>\n            </div>\n        );\n    }\n}\n","C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\Radio\\Radio.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\utils\\imageUtils.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\components\\controls\\Input\\Input.js",[],"C:\\Users\\tc03044\\Desktop\\wasp\\gitWasp\\src\\services\\index.js",[],{"ruleId":"255","replacedBy":"256"},{"ruleId":"257","replacedBy":"258"},{"ruleId":"259","severity":1,"message":"260","line":1,"column":17,"nodeType":"261","messageId":"262","endLine":1,"endColumn":30},{"ruleId":"259","severity":1,"message":"263","line":1,"column":8,"nodeType":"261","messageId":"262","endLine":1,"endColumn":14},{"ruleId":"264","severity":1,"message":"265","line":44,"column":17,"nodeType":"266","endLine":44,"endColumn":81},{"ruleId":"267","severity":1,"message":"268","line":45,"column":21,"nodeType":"266","endLine":45,"endColumn":66},{"ruleId":"259","severity":1,"message":"269","line":3,"column":8,"nodeType":"261","messageId":"262","endLine":3,"endColumn":23},{"ruleId":"259","severity":1,"message":"270","line":5,"column":8,"nodeType":"261","messageId":"262","endLine":5,"endColumn":15},{"ruleId":"259","severity":1,"message":"271","line":6,"column":18,"nodeType":"261","messageId":"262","endLine":6,"endColumn":37},{"ruleId":"259","severity":1,"message":"272","line":6,"column":39,"nodeType":"261","messageId":"262","endLine":6,"endColumn":56},{"ruleId":"267","severity":1,"message":"268","line":67,"column":28,"nodeType":"266","endLine":67,"endColumn":81},{"ruleId":"273","severity":1,"message":"274","line":91,"column":75,"nodeType":"275","messageId":"276","endLine":91,"endColumn":77},{"ruleId":"273","severity":1,"message":"274","line":95,"column":74,"nodeType":"275","messageId":"276","endLine":95,"endColumn":76},{"ruleId":"273","severity":1,"message":"274","line":99,"column":74,"nodeType":"275","messageId":"276","endLine":99,"endColumn":76},{"ruleId":"267","severity":1,"message":"268","line":117,"column":13,"nodeType":"266","endLine":125,"endColumn":15},{"ruleId":"267","severity":1,"message":"268","line":126,"column":44,"nodeType":"266","endLine":126,"endColumn":97},{"ruleId":"267","severity":1,"message":"268","line":133,"column":13,"nodeType":"266","endLine":141,"endColumn":15},{"ruleId":"267","severity":1,"message":"268","line":31,"column":16,"nodeType":"266","endLine":31,"endColumn":60},{"ruleId":"259","severity":1,"message":"277","line":1,"column":32,"nodeType":"261","messageId":"262","endLine":1,"endColumn":41},{"ruleId":"278","severity":1,"message":"279","line":49,"column":19,"nodeType":"280","messageId":"281","endLine":49,"endColumn":26,"fix":"282"},{"ruleId":"278","severity":1,"message":"279","line":64,"column":23,"nodeType":"280","messageId":"281","endLine":64,"endColumn":31,"fix":"283"},{"ruleId":"278","severity":1,"message":"279","line":65,"column":28,"nodeType":"280","messageId":"281","endLine":65,"endColumn":36,"fix":"284"},{"ruleId":"273","severity":1,"message":"285","line":104,"column":46,"nodeType":"275","messageId":"276","endLine":104,"endColumn":48},{"ruleId":"273","severity":1,"message":"285","line":107,"column":77,"nodeType":"275","messageId":"276","endLine":107,"endColumn":79},{"ruleId":"273","severity":1,"message":"285","line":313,"column":41,"nodeType":"275","messageId":"276","endLine":313,"endColumn":43},{"ruleId":"273","severity":1,"message":"285","line":319,"column":50,"nodeType":"275","messageId":"276","endLine":319,"endColumn":52},{"ruleId":"273","severity":1,"message":"274","line":343,"column":42,"nodeType":"275","messageId":"276","endLine":343,"endColumn":44},{"ruleId":"273","severity":1,"message":"274","line":352,"column":42,"nodeType":"275","messageId":"276","endLine":352,"endColumn":44},{"ruleId":"273","severity":1,"message":"274","line":361,"column":42,"nodeType":"275","messageId":"276","endLine":361,"endColumn":44},{"ruleId":"273","severity":1,"message":"274","line":371,"column":42,"nodeType":"275","messageId":"276","endLine":371,"endColumn":44},{"ruleId":"273","severity":1,"message":"274","line":381,"column":42,"nodeType":"275","messageId":"276","endLine":381,"endColumn":44},{"ruleId":"273","severity":1,"message":"274","line":393,"column":68,"nodeType":"275","messageId":"276","endLine":393,"endColumn":70},{"ruleId":"273","severity":1,"message":"274","line":427,"column":52,"nodeType":"275","messageId":"276","endLine":427,"endColumn":54},{"ruleId":"273","severity":1,"message":"285","line":438,"column":123,"nodeType":"275","messageId":"276","endLine":438,"endColumn":125},{"ruleId":"273","severity":1,"message":"274","line":449,"column":57,"nodeType":"275","messageId":"276","endLine":449,"endColumn":59},{"ruleId":"273","severity":1,"message":"274","line":475,"column":48,"nodeType":"275","messageId":"276","endLine":475,"endColumn":50},{"ruleId":"273","severity":1,"message":"285","line":479,"column":60,"nodeType":"275","messageId":"276","endLine":479,"endColumn":62},{"ruleId":"286","severity":1,"message":"287","line":485,"column":144,"nodeType":"275","messageId":"288","endLine":485,"endColumn":145},{"ruleId":"273","severity":1,"message":"274","line":514,"column":29,"nodeType":"275","messageId":"276","endLine":514,"endColumn":31},{"ruleId":"273","severity":1,"message":"285","line":522,"column":34,"nodeType":"275","messageId":"276","endLine":522,"endColumn":36},{"ruleId":"273","severity":1,"message":"274","line":566,"column":65,"nodeType":"275","messageId":"276","endLine":566,"endColumn":67},{"ruleId":"278","severity":1,"message":"279","line":625,"column":32,"nodeType":"280","messageId":"281","endLine":625,"endColumn":40,"fix":"289"},{"ruleId":"273","severity":1,"message":"285","line":638,"column":44,"nodeType":"275","messageId":"276","endLine":638,"endColumn":46},{"ruleId":"259","severity":1,"message":"290","line":639,"column":17,"nodeType":"261","messageId":"262","endLine":639,"endColumn":22},{"ruleId":"273","severity":1,"message":"285","line":652,"column":44,"nodeType":"275","messageId":"276","endLine":652,"endColumn":46},{"ruleId":"273","severity":1,"message":"285","line":655,"column":117,"nodeType":"275","messageId":"276","endLine":655,"endColumn":119},{"ruleId":"273","severity":1,"message":"274","line":688,"column":62,"nodeType":"275","messageId":"276","endLine":688,"endColumn":64},{"ruleId":"273","severity":1,"message":"274","line":708,"column":36,"nodeType":"275","messageId":"276","endLine":708,"endColumn":38},{"ruleId":"259","severity":1,"message":"291","line":719,"column":13,"nodeType":"261","messageId":"262","endLine":719,"endColumn":29},{"ruleId":"273","severity":1,"message":"274","line":775,"column":40,"nodeType":"275","messageId":"276","endLine":775,"endColumn":42},{"ruleId":"273","severity":1,"message":"285","line":798,"column":45,"nodeType":"275","messageId":"276","endLine":798,"endColumn":47},{"ruleId":"273","severity":1,"message":"274","line":815,"column":51,"nodeType":"275","messageId":"276","endLine":815,"endColumn":53},{"ruleId":"273","severity":1,"message":"274","line":832,"column":23,"nodeType":"275","messageId":"276","endLine":832,"endColumn":25},{"ruleId":"273","severity":1,"message":"285","line":833,"column":34,"nodeType":"275","messageId":"276","endLine":833,"endColumn":36},{"ruleId":"273","severity":1,"message":"274","line":835,"column":48,"nodeType":"275","messageId":"276","endLine":835,"endColumn":50},{"ruleId":"273","severity":1,"message":"285","line":865,"column":49,"nodeType":"275","messageId":"276","endLine":865,"endColumn":51},{"ruleId":"273","severity":1,"message":"274","line":870,"column":30,"nodeType":"275","messageId":"276","endLine":870,"endColumn":32},{"ruleId":"273","severity":1,"message":"274","line":880,"column":23,"nodeType":"275","messageId":"276","endLine":880,"endColumn":25},{"ruleId":"273","severity":1,"message":"285","line":906,"column":45,"nodeType":"275","messageId":"276","endLine":906,"endColumn":47},{"ruleId":"273","severity":1,"message":"274","line":912,"column":21,"nodeType":"275","messageId":"276","endLine":912,"endColumn":23},{"ruleId":"273","severity":1,"message":"285","line":928,"column":45,"nodeType":"275","messageId":"276","endLine":928,"endColumn":47},{"ruleId":"273","severity":1,"message":"274","line":937,"column":45,"nodeType":"275","messageId":"276","endLine":937,"endColumn":47},{"ruleId":"273","severity":1,"message":"274","line":951,"column":21,"nodeType":"275","messageId":"276","endLine":951,"endColumn":23},{"ruleId":"273","severity":1,"message":"274","line":1448,"column":63,"nodeType":"275","messageId":"276","endLine":1448,"endColumn":65},{"ruleId":"273","severity":1,"message":"274","line":1486,"column":40,"nodeType":"275","messageId":"276","endLine":1486,"endColumn":42},{"ruleId":"273","severity":1,"message":"274","line":1534,"column":23,"nodeType":"275","messageId":"276","endLine":1534,"endColumn":25},{"ruleId":"273","severity":1,"message":"274","line":1565,"column":21,"nodeType":"275","messageId":"276","endLine":1565,"endColumn":23},{"ruleId":"292","severity":1,"message":"293","line":1591,"column":9,"nodeType":"294","messageId":"295","endLine":1614,"endColumn":10},{"ruleId":"273","severity":1,"message":"274","line":1635,"column":71,"nodeType":"275","messageId":"276","endLine":1635,"endColumn":73},{"ruleId":"296","severity":1,"message":"297","line":1640,"column":33,"nodeType":"298","messageId":"276","endLine":1640,"endColumn":37},{"ruleId":"296","severity":1,"message":"297","line":1645,"column":31,"nodeType":"298","messageId":"276","endLine":1645,"endColumn":35},{"ruleId":"273","severity":1,"message":"274","line":1733,"column":57,"nodeType":"275","messageId":"276","endLine":1733,"endColumn":59},{"ruleId":"273","severity":1,"message":"274","line":1752,"column":36,"nodeType":"275","messageId":"276","endLine":1752,"endColumn":38},{"ruleId":"278","severity":1,"message":"279","line":1782,"column":28,"nodeType":"280","messageId":"281","endLine":1782,"endColumn":35,"fix":"299"},{"ruleId":"278","severity":1,"message":"279","line":1790,"column":32,"nodeType":"280","messageId":"281","endLine":1790,"endColumn":40,"fix":"300"},{"ruleId":"278","severity":1,"message":"279","line":1791,"column":37,"nodeType":"280","messageId":"281","endLine":1791,"endColumn":45,"fix":"301"},{"ruleId":"259","severity":1,"message":"302","line":1844,"column":15,"nodeType":"261","messageId":"262","endLine":1844,"endColumn":23},{"ruleId":"259","severity":1,"message":"271","line":7,"column":18,"nodeType":"261","messageId":"262","endLine":7,"endColumn":37},{"ruleId":"259","severity":1,"message":"272","line":7,"column":39,"nodeType":"261","messageId":"262","endLine":7,"endColumn":56},{"ruleId":"267","severity":1,"message":"268","line":178,"column":21,"nodeType":"266","endLine":178,"endColumn":124},{"ruleId":"267","severity":1,"message":"268","line":185,"column":17,"nodeType":"266","endLine":194,"endColumn":19},{"ruleId":"259","severity":1,"message":"303","line":35,"column":15,"nodeType":"261","messageId":"262","endLine":35,"endColumn":19},{"ruleId":"259","severity":1,"message":"304","line":1,"column":8,"nodeType":"261","messageId":"262","endLine":1,"endColumn":19},{"ruleId":"259","severity":1,"message":"305","line":2,"column":8,"nodeType":"261","messageId":"262","endLine":2,"endColumn":13},{"ruleId":"259","severity":1,"message":"306","line":3,"column":10,"nodeType":"261","messageId":"262","endLine":3,"endColumn":14},{"ruleId":"259","severity":1,"message":"307","line":3,"column":16,"nodeType":"261","messageId":"262","endLine":3,"endColumn":29},{"ruleId":"259","severity":1,"message":"308","line":4,"column":10,"nodeType":"261","messageId":"262","endLine":4,"endColumn":20},{"ruleId":"259","severity":1,"message":"305","line":2,"column":8,"nodeType":"261","messageId":"262","endLine":2,"endColumn":13},{"ruleId":"259","severity":1,"message":"306","line":3,"column":10,"nodeType":"261","messageId":"262","endLine":3,"endColumn":14},{"ruleId":"259","severity":1,"message":"309","line":11,"column":11,"nodeType":"261","messageId":"262","endLine":11,"endColumn":20},{"ruleId":"273","severity":1,"message":"274","line":24,"column":42,"nodeType":"275","messageId":"276","endLine":24,"endColumn":44},{"ruleId":"310","severity":1,"message":"311","line":162,"column":38,"nodeType":"312","messageId":"276","endLine":162,"endColumn":42},{"ruleId":"313","severity":1,"message":"314","line":6,"column":5,"nodeType":"315","messageId":"316","endLine":8,"endColumn":6},"no-native-reassign",["317"],"no-negated-in-lhs",["318"],"no-unused-vars","'PureComponent' is defined but never used.","Identifier","unusedVar","'config' is defined but never used.","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'WeaponDetection' is defined but never used.","'actions' is defined but never used.","'devVideoSnapshotUrl' is defined but never used.","'devVideoStreamUrl' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'Component' is defined but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"319","text":"320"},{"range":"321","text":"320"},{"range":"322","text":"320"},"Expected '!==' and instead saw '!='.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat",{"range":"323","text":"320"},"'usage' is assigned a value but never used.","'CanvasesInColumn' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-eval","eval can be harmful.","CallExpression",{"range":"324","text":"320"},{"range":"325","text":"320"},{"range":"326","text":"320"},"'dtmLayer' is assigned a value but never used.","'maps' is assigned a value but never used.","'actionTypes' is defined but never used.","'axios' is defined but never used.","'urls' is defined but never used.","'logSeverities' is defined but never used.","'getService' is defined but never used.","'WEAPON_ID' is assigned a value but never used.","no-dupe-keys","Duplicate key 'strs'.","ObjectExpression","no-useless-constructor","Useless constructor.","MethodDefinition","noUselessConstructor","no-global-assign","no-unsafe-negation",[1824,1824],"()",[2197,2197],[2245,2245],[28225,28225],[78594,78594],[78868,78868],[78925,78925]]