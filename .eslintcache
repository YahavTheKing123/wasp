[{"C:\\mapCoreDrones\\wasp\\src\\index.js":"1","C:\\mapCoreDrones\\wasp\\src\\App.js":"2","C:\\mapCoreDrones\\wasp\\src\\components\\LoaderAlt\\LoaderAlt.js":"3","C:\\mapCoreDrones\\wasp\\src\\components\\Clock\\Clock.js":"4","C:\\mapCoreDrones\\wasp\\src\\components\\Popup\\Popup.js":"5","C:\\mapCoreDrones\\wasp\\src\\components\\Error\\Error.js":"6","C:\\mapCoreDrones\\wasp\\src\\components\\MapContainer\\MapContainer.js":"7","C:\\mapCoreDrones\\wasp\\src\\config.js":"8","C:\\mapCoreDrones\\wasp\\src\\components\\Video\\Video.js":"9","C:\\mapCoreDrones\\wasp\\src\\components\\OutputTabs\\OutputTabs.js":"10","C:\\mapCoreDrones\\wasp\\src\\components\\ActionButtons\\ActionButtons.js":"11","C:\\mapCoreDrones\\wasp\\src\\store\\interceptor.js":"12","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\index.js":"13","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\actionTypes.js":"14","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\index.js":"15","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\mapReducer.js":"16","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\videoReducer.js":"17","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\outputReducer.js":"18","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\outputActions.js":"19","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\videoActions.js":"20","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\mapActions.js":"21","C:\\mapCoreDrones\\wasp\\src\\utils\\imageUtils.js":"22","C:\\mapCoreDrones\\wasp\\src\\services\\index.js":"23","C:\\mapCoreDrones\\wasp\\src\\rosWebsocket.js":"24","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\layoutReducer.js":"25","C:\\mapCoreDrones\\wasp\\src\\components\\GlobalMessage\\GlobalMessage.js":"26","C:\\mapCoreDrones\\wasp\\src\\ExternalConfigurationHandler.js":"27","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\layoutActions.js":"28","C:\\mapCoreDrones\\wasp\\src\\components\\ContextMenu\\ContextMenu.js":"29"},{"size":1507,"mtime":1609768048895,"results":"30","hashOfConfig":"31"},{"size":4215,"mtime":1609944410654,"results":"32","hashOfConfig":"31"},{"size":779,"mtime":1608726765864,"results":"33","hashOfConfig":"31"},{"size":1011,"mtime":1608732931954,"results":"34","hashOfConfig":"31"},{"size":3148,"mtime":1608731475370,"results":"35","hashOfConfig":"31"},{"size":215,"mtime":1608731475370,"results":"36","hashOfConfig":"31"},{"size":56145,"mtime":1609681026910,"results":"37","hashOfConfig":"31"},{"size":906,"mtime":1609940403883,"results":"38","hashOfConfig":"31"},{"size":4259,"mtime":1609940471054,"results":"39","hashOfConfig":"31"},{"size":878,"mtime":1609664293507,"results":"40","hashOfConfig":"31"},{"size":1873,"mtime":1609762941468,"results":"41","hashOfConfig":"31"},{"size":680,"mtime":1608816921990,"results":"42","hashOfConfig":"31"},{"size":396,"mtime":1609141411067,"results":"43","hashOfConfig":"31"},{"size":1241,"mtime":1609425027136,"results":"44","hashOfConfig":"31"},{"size":295,"mtime":1609336084102,"results":"45","hashOfConfig":"31"},{"size":620,"mtime":1609425107762,"results":"46","hashOfConfig":"31"},{"size":557,"mtime":1609074331296,"results":"47","hashOfConfig":"31"},{"size":450,"mtime":1608817506687,"results":"48","hashOfConfig":"31"},{"size":123,"mtime":1608817826415,"results":"49","hashOfConfig":"31"},{"size":4647,"mtime":1609778847873,"results":"50","hashOfConfig":"31"},{"size":121,"mtime":1608817781949,"results":"51","hashOfConfig":"31"},{"size":861,"mtime":1609852383392,"results":"52","hashOfConfig":"31"},{"size":2265,"mtime":1609767845136,"results":"53","hashOfConfig":"31"},{"size":2126,"mtime":1609765858559,"results":"54","hashOfConfig":"31"},{"size":1797,"mtime":1609409282895,"results":"55","hashOfConfig":"31"},{"size":1941,"mtime":1609156784665,"results":"56","hashOfConfig":"31"},{"size":335,"mtime":1609164957537,"results":"57","hashOfConfig":"31"},{"size":423,"mtime":1609336654627,"results":"58","hashOfConfig":"31"},{"size":3076,"mtime":1609420894312,"results":"59","hashOfConfig":"31"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},"1ikvebo",{"filePath":"63","messages":"64","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"62"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":58,"fixableErrorCount":0,"fixableWarningCount":8,"source":"76","usedDeprecatedRules":"62"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"83","messages":"84","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"85","usedDeprecatedRules":"62"},{"filePath":"86","messages":"87","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"98","messages":"99","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"100","messages":"101","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"62"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"62"},{"filePath":"108","messages":"109","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"110","messages":"111","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"112","messages":"113","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114","usedDeprecatedRules":"62"},{"filePath":"115","messages":"116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"117","messages":"118","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"119","usedDeprecatedRules":"62"},{"filePath":"120","messages":"121","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"122","messages":"123","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},{"filePath":"124","messages":"125","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"62"},"C:\\mapCoreDrones\\wasp\\src\\index.js",[],["126","127"],"C:\\mapCoreDrones\\wasp\\src\\App.js",["128"],"C:\\mapCoreDrones\\wasp\\src\\components\\LoaderAlt\\LoaderAlt.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\Clock\\Clock.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\Popup\\Popup.js",["129","130"],"import React, { PureComponent } from 'react';\r\nimport cn from './Popup.module.css';\r\nimport closeImg from '../../assets/images/close.svg';\r\n\r\n\r\nexport default class Popup extends PureComponent {\r\n    EscKey = 27;\r\n    componentDidMount() {\r\n        document.addEventListener('keydown', this.handleKeyDown);\r\n    }\r\n    \r\n    componentWillUnmount() {\r\n        document.removeEventListener('keydown', this.handleKeyDown);\r\n    }\r\n\r\n    handleKeyDown = (e) =>{\r\n        if (e.keyCode === this.EscKey && this.props.onCancel){\r\n            this.onCancelClicked(e);    \r\n        }\r\n    }\r\n\r\n    onOkClicked = (e) => {\r\n        e.preventDefault();\r\n        if (this.props.onOk) {\r\n            this.props.onOk();    \r\n        }\r\n    }\r\n\r\n    onCancelClicked = (e) => {\r\n        e.preventDefault();\r\n        if (this.props.onCancel) {\r\n            this.props.onCancel();    \r\n        }\r\n    }\r\n\r\n    getXBtn() {\r\n        return (\r\n            this.props.hideXButton ? null :\r\n                <a className={cn.Close} href=\"#\" onClick={this.onCancelClicked}>\r\n                    <img className={cn.closeBtn} src={closeImg}/>\r\n                </a> \r\n        );\r\n    }\r\n    getFooter() {\r\n        let okButton = null;\r\n        let cancelButton = null;\r\n        if (this.props.buttonOk) {\r\n            okButton = <button onClick={this.onOkClicked} className={`${cn.FormButton} ${cn.Apply}`}>{this.props.buttonOk}</button>;            \r\n        }\r\n        if (this.props.buttonCancel) {\r\n            cancelButton = <button onClick={this.onCancelClicked} className={`${cn.FormButton}`}>{this.props.buttonCancel}</button>;            \r\n        }\r\n\r\n        if (!okButton && !cancelButton) return null;\r\n        return (\r\n\r\n            <div className={cn.PopupFooter}>\r\n                <div>         \r\n                    {cancelButton}       \r\n                    {okButton}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n    getHeader() {\r\n        return (\r\n            <div className={cn.PopupHeader}>\r\n                <div className={cn.PopupHeaderWrapper}>\r\n                    <h2 className={cn.h2}>{this.props.header}</h2>                                            \r\n                    {this.getXBtn()}                    \r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    getBody() {\r\n        const noBodyOverflowClass = this.props.noBodyOverflow ? cn.NoBodyOverFlow : '';\r\n\r\n        const body =  React.Children.count(this.props.children)  > 0 ?\r\n            (<div className={`${cn.PopupBody} ${noBodyOverflowClass}`}>\r\n                {this.props.children}\r\n            </div>) : null;\r\n        return body;\r\n    }\r\n\r\n    render() {\r\n        const size = this.props.size ? cn[this.props.size] : '';\r\n        return (this.props.children) ? \r\n                (\r\n                   <div className={cn.Overlay}>\r\n                       <div className={`${cn.Popup} ${size}`}>\r\n                           {this.getHeader()}\r\n                           {this.getBody()}\r\n                           {this.getFooter()}\r\n                       </div>\r\n                   </div>\r\n               ) : null;\r\n        \r\n    }\r\n}\r\n","C:\\mapCoreDrones\\wasp\\src\\components\\Error\\Error.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\MapContainer\\MapContainer.js",["131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188"],"import React, { PureComponent, Component } from 'react';\r\nimport cn from './MapContainer.module.css';\r\nimport axios from 'axios';\r\nimport config from '../../config'; \r\nimport { connect } from 'react-redux';\r\nimport externalConfig from '../../ExternalConfigurationHandler';\r\nimport actionTypes from '../../store/actions/actionTypes';\r\n\r\nclass SLayerGroup\r\n{\r\n    constructor(coordSystemString, bShowGeoInMetricProportion, bSetTerrainBoxByStaticLayerOnly, InitialScale2D)\r\n    {\r\n        this.aLayerCreateStrings = [];\r\n        this.coordSystemString = coordSystemString;\r\n        this.bShowGeoInMetricProportion = bShowGeoInMetricProportion;\r\n        this.bSetTerrainBoxByStaticLayerOnly = bSetTerrainBoxByStaticLayerOnly;\r\n        this.InitialScale2D = InitialScale2D;        \r\n    }\r\n}\r\n\r\nclass SViewportData {\r\n    constructor(_viewport, _editMode) {\r\n        this.viewport = _viewport;\r\n        this.editMode = _editMode;\r\n        this.canvas = _viewport.GetWindowHandle();\r\n        let aViewportTerrains = _viewport.GetTerrains();\r\n        this.aLayers = (aViewportTerrains != null && aViewportTerrains.length > 0 ? aViewportTerrains[0].GetLayers() : null);\r\n        this.terrainBox = null;\r\n        this.terrainCenter = null;\r\n        this.rotationCenter = null;\r\n        this.bCameraPositionSet = false;\r\n        this.bSetTerrainBoxByStaticLayerOnly = false;\r\n    }\r\n}\r\n\r\nclass MapContainer extends PureComponent {\r\n\r\n    state = {\r\n        mapLayerGroups: new Map(),\r\n        lastTerrainConfiguration: null,\r\n        lastViewportConfiguration: null /*  2D/3D, 3D/2D, 2D, 3D */,\r\n        bSameCanvas: true,\r\n        isDTMClicked: false,\r\n        is3DClicked: false,\r\n    }\r\n\r\n    mapTerrains = new Map;\r\n    device = null\r\n    //callbacks classes from mapCore\r\n    CLayerReadCallback;\r\n    CCameraUpdateCallback;\r\n    CAsyncQueryCallback;    \r\n    viewportData = null;\r\n    uCameraUpdateCounter = 0;\r\n    aLastTerrainLayers = [];\r\n    lastCoordSys = null;\r\n    overlayManager = null;\r\n    activeViewport = -1;\r\n    aViewports = [];\r\n    viewport;\r\n    editMode;\r\n    lastRenderTime = (new Date).getTime();\r\n    lastMemUsageLogTime = (new Date).getTime();\r\n    uMemUsageLoggingFrequency = 0;\r\n    nMousePrevX = 0;\r\n    nMousePrevY = 0;\r\n    mouseDownButtons = 0;\r\n    bEdit = false;\r\n    layerCallback = null;\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', this.resizeCanvases);\r\n        //this.callGetCapabilitiesApi();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        //Todo -> un-register events and all the map core object\r\n        window.removeEventListener('resize', this.resizeCanvases)\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        // first time map load or channing from map a to map b\r\n        if ((!prevProps.isMapCoreSDKLoaded && this.props.isMapCoreSDKLoaded) || \r\n                (this.props.isMapCoreSDKLoaded && prevProps.mapToShow !== this.props.mapToShow)) {\r\n            this.openMap(this.props.mapToShow.groupName, false);\r\n        }\r\n    }\r\n\r\n    parseLayersConfiguration(jsonLayerGroups) {\r\n    try {\r\n        for (let jsonGroup of jsonLayerGroups)\r\n        {\r\n            // coordinate system creation string: MapCore.IMcGridCoordSystemGeographic.Create(MapCore.IMcGridCoordinateSystem.EDatumType.EDT_WGS84) etc.\r\n            let coordSystemString = \"MapCore.\" + jsonGroup.coordSystemType + \".Create(\" + jsonGroup.coordSystemParams + \")\";\r\n            let layerGroup = new SLayerGroup(coordSystemString, jsonGroup.showGeoInMetricProportion, jsonGroup.centerByStaticObjectsLayerOnly, jsonGroup.InitialScale2D);\r\n\r\n            if (jsonGroup.layers) {\r\n                for (let layer of jsonGroup.layers) {\r\n                    let layerCreateString = null;\r\n                    switch (layer.type) {\r\n                        case \"WMSRaster\":\r\n                            // WMS raster layer creation string: CreateWMSRasterLayer('http://wmtsserver/wmts?request=GetCapabilities', 'layer', 'EPSG:4326', 'jpeg') etc.\r\n                            layerCreateString = \"Create\" + layer.type + \"Layer('\" + layer.path + \"'\" + (layer.params ? \", \" + layer.params : \"\") + \")\";\r\n                            break;\r\n                        case \"IMcNativeRasterMapLayer\":\r\n                            layerCreateString = \"MapCore.IMcNativeRasterMapLayer.Create('\" + layer.path + \"', \" + (layer.params ? layer.params : \"MapCore.UINT_MAX, false, 0, false\") + \", this.layerCallback)\";\r\n                            break;\r\n                        case \"IMcNativeDtmMapLayer\":\r\n                            layerCreateString = \"MapCore.IMcNativeDtmMapLayer.Create('\" + layer.path + \"', \" + (layer.params ? layer.params : \"0\") + \", this.layerCallback)\";\r\n                            break;\r\n                        case \"IMcNativeVectorMapLayer\":\r\n                            layerCreateString = \"MapCore.IMcNativeVectorMapLayer.Create('\" + layer.path + \"', \" + (layer.params ? layer.params : \"\") + \"this.layerCallback)\";\r\n                            break;\r\n                        case \"IMcNativeStaticObjectsMapLayer\":\r\n                            layerCreateString = \"MapCore.IMcNativeStaticObjectsMapLayer.Create('\" + layer.path +  \"', \" + (layer.params ? layer.params : \"0, 0\") + \", this.layerCallback)\";\r\n                            break;\r\n                        default:\r\n                            alert(\"Invalid type of server layer\");\r\n                            return;\r\n                    }\r\n                    layerGroup.aLayerCreateStrings.push(layerCreateString);\r\n                }\r\n            }\r\n            if (jsonGroup.groupName != undefined) {\r\n                \r\n                this.setState({mapLayerGroups: new Map(this.state.mapLayerGroups.set(jsonGroup.groupName, layerGroup))});                \r\n                                \r\n            } \r\n            // we should not get here...\r\n            else if (jsonGroup.wmtsServerURL != undefined) {\r\n\r\n                // layerGroup.wmtsServerURL = jsonGroup.wmtsServerURL;\r\n                // if (jsonGroup.tileMatrixSetFilter != undefined) {\r\n\r\n                //     layerGroup.tileMatrixSetFilter = jsonGroup.tileMatrixSetFilter;\r\n                // }\r\n                // aWmtsAdditionalLayerGroups.push(layerGroup);\r\n            }\r\n        }\r\n    }\r\n    catch (e)\r\n    {\r\n        alert(\"Invalid configuration JSON file\");\r\n    }\r\n    }\r\n\r\n    parseCapabilitiesXML(xmlDoc, capabilitiesURL, bMapCoreLayerServer = true, wmtsAdditionalLayerGroup) {\r\n        class CXmlNode\r\n        {\r\n            constructor(node)\r\n            {\r\n                this.node = node;\r\n            }\r\n            GetFirstChild(tagName)\r\n            {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                for (let child of children)\r\n                {\r\n                    if (child.parentNode == this.node)\r\n                    {\r\n                        return new CXmlNode(child);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            GetFirstChildText(tagName)\r\n            {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                for (let child of children)\r\n                {\r\n                    if (child.parentNode == this.node)\r\n                    {\r\n                        return child.textContent;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            GetFirstChildAttribute(tagName, attributeName)\r\n            {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                for (let child of children)\r\n                {\r\n                    if (child.parentNode == this.node)\r\n                    {\r\n                        return child.attributes.getNamedItem(attributeName).value;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            GetChildren(tagName)\r\n            {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                let aNodes = [];\r\n                for (let child of children)\r\n                {\r\n                    if (child.parentNode == this.node)\r\n                    {\r\n                        aNodes.push(new CXmlNode(child));\r\n                    }\r\n                }\r\n                return aNodes;\r\n            }\r\n            GetChildrenTexts(tagName)\r\n            {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                let aTexts = [];\r\n                for (let child of children)\r\n                {\r\n                    if (child.parentNode == this.node)\r\n                    {\r\n                        aTexts.push(child.textContent);\r\n                    }\r\n                }\r\n                return aTexts;\r\n            }\r\n        }\r\n        \r\n        if (xmlDoc != null)\r\n        {\r\n            try\r\n            {\r\n                let capabilities = new CXmlNode(xmlDoc).GetFirstChild(\"Capabilities\");\r\n                let MapLayerServerURL = capabilities.GetFirstChildAttribute(\"ServiceMetadataURL\", \"xlink:href\");\r\n                if (MapLayerServerURL == null || MapLayerServerURL == \"\")\r\n                {\r\n                    MapLayerServerURL = capabilitiesURL;\r\n                }\r\n                let lastSlashIndex = MapLayerServerURL.lastIndexOf(\"?\");\r\n                if (lastSlashIndex < 0)\r\n                {\r\n                    lastSlashIndex = MapLayerServerURL.lastIndexOf(\"/\");\r\n                }\r\n                if (lastSlashIndex < 0)\r\n                {\r\n                    alert(\"Invalid Capabilities file\");\r\n                    return;\r\n                }\r\n                let TrimmedMapLayerServerURL = MapLayerServerURL.substring(0, lastSlashIndex);\r\n    \r\n                let contents = capabilities.GetFirstChild(\"Contents\");\r\n                let aTileMatrixSets = contents.GetChildren(\"TileMatrixSet\");\r\n                let mapTileMatrixSets = new Map();\r\n                for (let matrixSet of aTileMatrixSets)\r\n                {\r\n                    let id = matrixSet.GetFirstChildText(\"ows:Identifier\");\r\n                    let crs = matrixSet.GetFirstChildText(\"ows:SupportedCRS\");\r\n                    if (id != null &&  crs != null)\r\n                    {\r\n                        mapTileMatrixSets.set(matrixSet.GetFirstChildText(\"ows:Identifier\"), { coordSystem : crs, tileMatrixSet : id});\r\n                    }\r\n                }\r\n    \r\n                let aLayers = contents.GetChildren(\"Layer\");\r\n                for (let layer of aLayers)\r\n                {\r\n                    // check here if its single layer preview. if yes put only this layer in the hashMap                    \r\n                    let layerID = layer.GetFirstChildText(\"ows:Identifier\");                    \r\n                    if (this.context.mapToPreview.type === config.nodesLevel.layer && \r\n                            (this.context.mapToPreview.data.LayerId !== layerID && this.context.mapToPreview.dtmLayerId !== layerID)) \r\n                            continue;\r\n\r\n                    let aFormats = layer.GetChildrenTexts(\"Format\");\r\n                    let aTileMatrixSetLinks = layer.GetChildren(\"TileMatrixSetLink\");\r\n                    if (aTileMatrixSetLinks.length == 0)\r\n                    {\r\n                        aTileMatrixSetLinks.push(null);\r\n                    }\r\n                    \r\n                    for (let tileMatrixSetLink of aTileMatrixSetLinks)\r\n                    {\r\n                        let coordSystem = null;\r\n                        let tileMatrixSet = null;\r\n                        if (tileMatrixSetLink != null)\r\n                        {\r\n                            let tileMatrixSetParams = mapTileMatrixSets.get(tileMatrixSetLink.GetFirstChildText(\"TileMatrixSet\"));\r\n                            coordSystem = tileMatrixSetParams.coordSystem;\r\n                            tileMatrixSet = tileMatrixSetParams.tileMatrixSet;\r\n                            if (wmtsAdditionalLayerGroup && wmtsAdditionalLayerGroup.tileMatrixSetFilter && tileMatrixSet != wmtsAdditionalLayerGroup.tileMatrixSetFilter)\r\n                            {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (coordSystem == null)\r\n                        {\r\n                            let boundingBox = layer.GetFirstChild(\"ows:BoundingBox\");\r\n                            if (boundingBox)\r\n                            {\r\n                                coordSystem = boundingBox.GetFirstChildText(\"ows:crs\");\r\n                            }\r\n                        }\r\n                        let prefix = \"urn:ogc:def:crs:\";\r\n                        if (coordSystem.indexOf(prefix) == 0)\r\n                        {\r\n                            coordSystem = coordSystem.substring(prefix.length).replace(\"::\", \":\");\r\n                            let aGroups = [];\r\n                            if (bMapCoreLayerServer)\r\n                            {\r\n                                aGroups = layer.GetFirstChildText(\"Group\").split(\",\");\r\n                                for (let i = 0; i < aGroups.length; ++i)\r\n                                {\r\n                                    aGroups[i] = aGroups[i] + \" (server \" + coordSystem + \")\";\r\n                                }\r\n                            }\r\n                            else\r\n                            {\r\n                                let groupName = layer.GetFirstChildText(\"ows:Title\");\r\n                                if (groupName == null)\r\n                                {\r\n                                    groupName = layerID;\r\n                                }\r\n    \r\n                                for (let i = 0; i < aFormats.length; ++i)\r\n                                {\r\n                                    aFormats[i] = aFormats[i].replace(\"image/\", \"\");\r\n                                    aGroups[i] = groupName  + \" (WMTS \" + aFormats[i] + \" \" + tileMatrixSet + \")\";\r\n                                }\r\n                            }\r\n                            for (let i = 0; i < aGroups.length; ++i)\r\n                            {\r\n                                let group = aGroups[i];\r\n    \r\n                                // coordinate system creation string: MapCore.IMcGridGeneric.Create('EPSG:4326') etc.\r\n                                let coordSystemString = \"MapCore.IMcGridGeneric.Create('\" + coordSystem + \"')\";\r\n                                let layerGroup = this.state.mapLayerGroups.get(group);\r\n                                if (layerGroup == undefined)\r\n                                {\r\n                                    layerGroup = new SLayerGroup(coordSystemString, true); // for MapCoreLayerServer only: bShowGeoInMetricProportion is true\r\n                                    this.setState({mapLayerGroups: new Map(this.state.mapLayerGroups.set(group, layerGroup))});\r\n                                }\r\n                                else if (coordSystemString != layerGroup.coordSystemString)\r\n                                {\r\n                                    alert(\"Layers' coordinate systems do not match\");\r\n                                    return;\r\n                                }\r\n                                let layerCreateString;\r\n                                if (bMapCoreLayerServer)\r\n                                {\r\n                                    layerCreateString = aFormats[0].replace(\"MapCore\", \"MapCore.IMcNative\").replace(\"DTM\", \"Dtm\") + \"MapLayer\" + \".Create('\" + TrimmedMapLayerServerURL + \"/\" + layerID + \"')\";\r\n                                    layerGroup.aLayerCreateStrings.push(layerCreateString);\r\n                                }\r\n                                else\r\n                                {\r\n                                    // WMTS raster layer creation string: CreateWMTSRasterLayer('http://wmtsserver/wmts?request=GetCapabilities', 'layer', 'EPSG:4326', 'jpeg') etc.\r\n                                    layerCreateString = \"CreateWMTSRasterLayer('\" + capabilitiesURL + \"', '\" + layerID + \"', '\" + tileMatrixSet + \"', '\" + aFormats[i] + \"')\";\r\n                                    layerGroup.aLayerCreateStrings.push(layerCreateString);\r\n                                    if (wmtsAdditionalLayerGroup)\r\n                                    {\r\n                                        layerGroup.aLayerCreateStrings = layerGroup.aLayerCreateStrings.concat(wmtsAdditionalLayerGroup.aLayerCreateStrings);\r\n                                        layerGroup.bSetTerrainBoxByStaticLayerOnly = wmtsAdditionalLayerGroup.bSetTerrainBoxByStaticLayerOnly;\r\n                                        layerGroup.bShowGeoInMetricProportion = wmtsAdditionalLayerGroup.bShowGeoInMetricProportion;\r\n                                        layerGroup.InitialScale2D = wmtsAdditionalLayerGroup.InitialScale2D;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (e)\r\n            {\r\n                alert(\"Invalid Capabilities file\");\r\n            }\r\n        }\r\n    }\r\n\r\n    createCallbackClasses() {        \r\n        this.CLayerReadCallback = window.MapCore.IMcMapLayer.IReadCallback.extend(\"IMcMapLayer.IReadCallback\", {\r\n            // mandatory\r\n            OnInitialized : function(pLayer, eStatus, strAdditionalDataString)\r\n            {\r\n                if (eStatus == window.MapCore.IMcErrors.ECode.SUCCESS)\r\n                {\r\n                    if (pLayer.GetLayerType() ==  window.MapCore.IMcNativeStaticObjectsMapLayer.LAYER_TYPE && !pLayer.IsBuiltOfContoursExtrusion())\r\n                    {\r\n                        pLayer.SetDisplayingItemsAttachedToTerrain(true);\r\n                        pLayer.SetDisplayingDtmVisualization(true);\r\n                    }\r\n                }\r\n                else if (eStatus !=  window.MapCore.IMcErrors.ECode.NATIVE_SERVER_LAYER_NOT_VALID)\r\n                {\r\n                    alert(\"Layer initialization: \" +  window.MapCore.IMcErrors.ErrorCodeToString(eStatus) + \" (\" + strAdditionalDataString + \")\");\r\n                }\r\n            },\r\n            // mandatory\r\n            OnReadError: function(pLayer, eErrorCode, strAdditionalDataString) {\r\n                alert(\"Layer read error: \" + window.MapCore.IMcErrors.ErrorCodeToString(eErrorCode) + \" (\" + strAdditionalDataString + \")\");\r\n            },\r\n            // mandatory\r\n            OnNativeServerLayerNotValid: function(pLayer, bLayerVersionUpdated) {/*TBD*/},\r\n            // optional, needed if to be deleted by MapCore when no longer used\r\n            // optional\r\n            OnRemoved(pLayer, eStatus, strAdditionalDataString)\r\n            {\r\n                alert(\"Map layer has been removed\");\r\n            },\r\n\r\n            // optional\r\n            OnReplaced(pOldLayer, pNewLayer, eStatus, strAdditionalDataString)\r\n            {\r\n                alert(\"Map layer has been replaced\");\r\n            },            \r\n            Release: function() { this.delete(); },\r\n        });\r\n        \r\n        this.CCameraUpdateCallback = window.MapCore.IMcMapViewport.ICameraUpdateCallback.extend(\"IMcMapViewport.ICameraUpdateCallback\", {\r\n            // mandatory\r\n            OnActiveCameraUpdated: function(pViewport) {\r\n                ++this.uCameraUpdateCounter\r\n            },\r\n            // optional\r\n            Release: function() {\r\n                this.delete()\r\n            }\r\n        });\r\n        \r\n        this.CAsyncQueryCallback = window.MapCore.IMcSpatialQueries.IAsyncQueryCallback.extend(\"IMcSpatialQueries.IAsyncQueryCallback\", {\r\n            // optional\r\n            __construct: function(viewportData) {\r\n                this.__parent.__construct.call(this);\r\n                this.viewportData = viewportData;\r\n            },\r\n\r\n            OnTerrainHeightResults: function (bHeightFound, height, normal) {\r\n                if (this.viewportData.viewport != null) {\r\n                    this.viewportData.terrainCenter.z = height + 20;\r\n                    if (this.viewportData.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n                        this.viewportData.viewport.SetCameraPosition(this.viewportData.terrainCenter);\r\n                    }\r\n                }\r\n                this.delete();\r\n            },\r\n            OnTerrainHeightMatrixResults: function(uNumHorizontalPoints, uNumVerticalPoints, adHeightMatrix) {},\r\n            OnTerrainHeightsAlongLineResults: function(aPointsWithHeights, aSlopes, pSlopesData) {},\r\n            OnExtremeHeightPointsInPolygonResults: function(bPointsFound, pHighestPoint, pLowestPoint) {},\r\n            OnTerrainAnglesResults: function(dPitch, dRoll) {},\r\n\r\n            // OnRayIntersectionResults\r\n            OnLineOfSightResults: function(aPoints, dCrestClearanceAngle, dCrestClearanceDistance){},\r\n            OnPointVisibilityResults: function(bIsTargetVisible, pdMinimalTargetHeightForVisibility, pdMinimalScouterHeightForVisibility) {},\r\n            OnAreaOfSightResults: function(pAreaOfSight, aLinesOfSight, pSeenPolygons, pUnseenPolygons, aSeenStaticObjects) {},\r\n            OnLocationFromTwoDistancesAndAzimuthResults: function(Target){},\r\n\r\n            // mandatory\r\n            OnError: function(eErrorCode) {\r\n                alert('error '+ eErrorCode);\r\n                this.delete();\r\n            },\r\n        });\r\n\r\n        let CUserData = window.MapCore.IMcUserData.extend(\"IMcUserData\", {\r\n            // optional\r\n            __construct: function(bToBeDeleted) {\r\n                this.__parent.__construct.call(this);\r\n                this.bToBeDeleted = bToBeDeleted;\r\n                // ...\r\n            },\r\n\r\n            // optional\r\n            __destruct: function() {\r\n                this.__parent.__destruct.call(this);\r\n                // ...\r\n            },\r\n\r\n            // mandatory\r\n            Release: function() {\r\n                if (this.bToBeDeleted)\r\n                {\r\n                    this.delete();\r\n                }\r\n            },\r\n\r\n            // optional\r\n            Clone: function() {\r\n                if (this.bToBeDeleted) {\r\n                    return new CUserData(this.bToBeDeleted);\r\n                }\r\n                return this;\r\n            },\r\n        });\r\n        this.layerCallback = new this.CLayerReadCallback();\r\n    }\r\n\r\n    doMoveObjects() {\r\n    }\r\n\r\n    renderMapContinuously = () => {\r\n        this.trySetTerainBox();\r\n        let currtRenderTime = (new Date).getTime();\r\n        \r\n        // render viewport(s)\r\n        if (!this.state.bSameCanvas) {\r\n            window.MapCore.IMcMapViewport.RenderAll(); \r\n        } else if (this.viewport != null) {\r\n            this.viewport.Render();\r\n        }\r\n    \r\n        // move objects if they exist\r\n        this.doMoveObjects();\r\n        this.lastRenderTime = currtRenderTime;\r\n    \r\n        // log memory usage and heap size\r\n        if (this.uMemUsageLoggingFrequency != 0 && currtRenderTime >= this.lastMemUsageLogTime + this.uMemUsageLoggingFrequency * 1000) {\r\n            let usage = window.MapCore.IMcMapDevice.GetMaxMemoryUsage();\r\n            console.log(\"Max mem = \" + window.MapCore.IMcMapDevice.GetMaxMemoryUsage().toLocaleString() + \", heap = \" + window.MapCore.IMcMapDevice.GetHeapSize().toLocaleString() + \" B\");\r\n            this.lastMemUsageLogTime = currtRenderTime;\r\n        }\r\n    \r\n        // ask the browser to render again\r\n        requestAnimationFrame(this.renderMapContinuously);\r\n    }\r\n\r\n    trySetTerainBox() {\r\n        for (let j = 0; j < this.aViewports.length; j++) {\r\n            if (this.aViewports[j].terrainBox == null) {\r\n                let aViewportLayers = this.aViewports[j].aLayers;\r\n                if (aViewportLayers.length != 0) {\r\n                    this.aViewports[j].terrainBox = new window.MapCore.SMcBox(-window.MapCore.DBL_MAX, -window.MapCore.DBL_MAX, 0, window.MapCore.DBL_MAX, window.MapCore.DBL_MAX, 0);\r\n                    for (let i = 0; i < aViewportLayers.length; ++i) {\r\n                        if (this.aViewports[j].bSetTerrainBoxByStaticLayerOnly && aViewportLayers[i].GetLayerType() != window.MapCore.IMcNativeStaticObjectsMapLayer.LAYER_TYPE) {\r\n                            continue;\r\n                        }\r\n    \r\n                        if (!aViewportLayers[i].IsInitialized()) {\r\n                            this.aViewports[j].terrainBox = null;\r\n                            return;\r\n                        }\r\n    \r\n                        let layerBox = aViewportLayers[i].GetBoundingBox();\r\n                        if (layerBox.MinVertex.x > this.aViewports[j].terrainBox.MinVertex.x) {\r\n                            this.aViewports[j].terrainBox.MinVertex.x = layerBox.MinVertex.x;\r\n                        }\r\n                        if (layerBox.MaxVertex.x < this.aViewports[j].terrainBox.MaxVertex.x) {\r\n                            this.aViewports[j].terrainBox.MaxVertex.x = layerBox.MaxVertex.x;\r\n                        }\r\n                        if (layerBox.MinVertex.y > this.aViewports[j].terrainBox.MinVertex.y) {\r\n                            this.aViewports[j].terrainBox.MinVertex.y = layerBox.MinVertex.y;\r\n                        }\r\n                        if (layerBox.MaxVertex.y < this.aViewports[j].terrainBox.MaxVertex.y) {\r\n                            this.aViewports[j].terrainBox.MaxVertex.y = layerBox.MaxVertex.y;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.aViewports[j].terrainBox = new window.MapCore.SMcBox(0, 0, 0, 0, 0, 0);\r\n                }\r\n    \r\n                this.aViewports[j].terrainCenter = window.MapCore.SMcVector3D((this.aViewports[j].terrainBox.MinVertex.x + this.aViewports[j].terrainBox.MaxVertex.x) / 2, (this.aViewports[j].terrainBox.MinVertex.y + this.aViewports[j].terrainBox.MaxVertex.y) / 2, 0);\r\n                this.aViewports[j].terrainCenter.z = 10000;\r\n            }\r\n    \r\n            if (!this.aViewports[j].bCameraPositionSet)\r\n            {\r\n                if (this.aViewports[j].viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_2D)\r\n                {\r\n                    this.aViewports[j].viewport.SetCameraPosition(this.aViewports[j].terrainCenter);\r\n                    this.aViewports[j].bCameraPositionSet = true;\r\n                }\r\n                else // 3D\r\n                {\r\n                    let height = {};\r\n                    this.aViewports[j].terrainCenter.z = 1000;\r\n                    this.aViewports[j].viewport.SetCameraPosition(this.aViewports[j].terrainCenter);\r\n                    let params = new window.MapCore.IMcSpatialQueries.SQueryParams();\r\n                    params.eTerrainPrecision = window.MapCore.IMcSpatialQueries.EQueryPrecision.EQP_HIGH;\r\n                    this.aViewports[j].bCameraPositionSet = true;\r\n                    params.pAsyncQueryCallback = new this.CAsyncQueryCallback(this.aViewports[j]);\r\n                    this.aViewports[j].viewport.GetTerrainHeight(this.aViewports[j].terrainCenter, height, null, params); // async, wait for OnTerrainHeightResults()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    resizeCanvases = () => {\r\n        if (this.aViewports.length == 0) {\r\n            return;\r\n        }\r\n   \r\n       let CanvasesInRow, CanvasesInColumn;\r\n       if (!this.state.bSameCanvas) {\r\n           CanvasesInRow = Math.ceil(Math.sqrt(this.aViewports.length));\r\n           CanvasesInColumn = Math.ceil(this.aViewports.length / CanvasesInRow);\r\n       }\r\n       else {\r\n           CanvasesInRow = 1;\r\n           CanvasesInColumn = 1;\r\n       }\r\n       //todo: use this instead: document.getElementById('id').getBoundingClientRect()\r\n    //    let width =  (window.innerWidth - 40) / CanvasesInRow - 10;\r\n    //    let height = (window.innerHeight - 80) / CanvasesInColumn - 15;\r\n       let width =  document.getElementById('canvasesContainer').getBoundingClientRect().width;\r\n       let height = document.getElementById('canvasesContainer').getBoundingClientRect().height;\r\n       \r\n       for (let i = 0; i < this.aViewports.length ; i++) {\r\n           this.aViewports[i].canvas.width = width;\r\n           this.aViewports[i].canvas.height = height;\r\n           this.aViewports[i].viewport.ViewportResized();\r\n       }\r\n    }\r\n\r\n    calcMinMaxHeights() {\r\n        let minHeight = 0;\r\n        let maxHeight = 700;\r\n        let fp = this.viewport.GetCameraFootprint();\r\n\r\n        if (fp.bUpperLeftFound && fp.bUpperRightFound && fp.bLowerRightFound && fp.bLowerLeftFound) {\r\n            let minPoint = {}, maxPoint = {};\r\n            if (this.viewport.GetExtremeHeightPointsInPolygon([fp.UpperLeft, fp.UpperRight, fp.LowerRight, fp.LowerLeft], maxPoint, minPoint)) {\r\n                minHeight = minPoint.Value.z;\r\n                maxHeight = maxPoint.Value.z;\r\n            }\r\n        }\r\n        return { minHeight, maxHeight };\r\n    }\r\n\r\n    // function switching DTM-visualization (height map) on/off\r\n    doDtmVisualization = () => {\r\n        if (!this.viewport.GetDtmVisualization()) {\r\n            let result = this.calcMinMaxHeights();\r\n            let DtmVisualization = new window.MapCore.IMcMapViewport.SDtmVisualizationParams();\r\n            window.MapCore.IMcMapViewport.SDtmVisualizationParams.SetDefaultHeightColors(DtmVisualization, result.minHeight, result.maxHeight);\r\n            DtmVisualization.bDtmVisualizationAboveRaster = true;\r\n            DtmVisualization.uHeightColorsTransparency = 120;\r\n            DtmVisualization.uShadingTransparency = 255;\r\n            this.viewport.SetDtmVisualization(true, DtmVisualization);\r\n        } else {\r\n            this.viewport.SetDtmVisualization(false);\r\n        }\r\n    }\r\n\r\n    mouseWheelHandler = e => {\r\n        let bHandled = {};\r\n        let eCursor = {};\r\n        let wheelDelta = - e.deltaY;\r\n        this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_WHEEL, window.MapCore.SMcPoint(0, 0), e.ctrlKey, wheelDelta, bHandled, eCursor);\r\n        if (bHandled.Value) {\r\n            return;\r\n        }\r\n    \r\n        let factor = (e.shiftKey ? 10 : 1);\r\n    \r\n        if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n            this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(0, 0, wheelDelta / 8.0 * factor), true);\r\n        } else {\r\n            let fScale = this.viewport.GetCameraScale();\r\n            if (wheelDelta > 0) {\r\n                this.viewport.SetCameraScale(fScale / 1.25);\r\n            } else {\r\n                this.viewport.SetCameraScale(fScale * 1.25);\r\n            }\r\n    \r\n            if (this.viewport.GetDtmVisualization()) {\r\n                this.doDtmVisualization();\r\n                this.doDtmVisualization();\r\n            }\r\n        }\r\n    \r\n        e.preventDefault();\r\n        e.cancelBubble = true;\r\n        if (e.stopPropagation) e.stopPropagation();\r\n    }\r\n\r\n\r\n    mouseMoveHandler = e => {\r\n        if (this.viewport.GetWindowHandle() != e.target) {\r\n            return;\r\n        }\r\n    \r\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        if (e.buttons <= 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(e.buttons == 1 ? window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_MOVED_BUTTON_DOWN : window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_MOVED_BUTTON_UP, \r\n                EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n        }\r\n    \r\n        if (e.buttons == 1) {\r\n            if (this.nMousePrevX != 0) {\r\n                let factor = (e.shiftKey ? 10 : 1);\r\n                if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n                    if (e.ctrlKey) {\r\n                        this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D((this.nMousePrevX - EventPixel.x) / 2.0 * factor, - (this.nMousePrevY - EventPixel.y) / 2.0 * factor, 0), false);\r\n                    }\r\n                    else {\r\n                        this.viewport.RotateCameraRelativeToOrientation((this.nMousePrevX - EventPixel.x) / 2.0, - (this.nMousePrevY - EventPixel.y) / 2.0, 0);\r\n                    }\r\n                } else {\r\n                    if (e.ctrlKey) {\r\n                        this.viewport.SetCameraOrientation((this.nMousePrevX - EventPixel.x) / 2.0, window.MapCore.FLT_MAX, window.MapCore.FLT_MAX, true);\r\n                    }\r\n                    else {\r\n                        this.viewport.ScrollCamera((this.nMousePrevX - EventPixel.x) * factor, (this.nMousePrevY - EventPixel.y) * factor);\r\n                    }\r\n                }\r\n    \r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n            }\r\n        }\r\n    \r\n        this.nMousePrevX = EventPixel.x;\r\n        this.nMousePrevY = EventPixel.y;\r\n    }\r\n\r\n    mouseDownHandler = e => {\r\n        if (this.editMode.IsEditingActive()) {\r\n            // EditMode is active: don't change active viewport, but ignore click on non-active one\r\n            if (this.viewport.GetWindowHandle() != e.target)\r\n            {\r\n               return;\r\n            }\r\n        } else if (!this.state.bSameCanvas) {\r\n            for (let i = 0; i < this.aViewports.length; i++) {\r\n                if (e.target ==  this.aViewports[i].viewport.GetWindowHandle()) {\r\n                    this.activeViewport = i;\r\n                    this.updateActiveViewport();\r\n                    break;\r\n                }                \r\n            }\r\n        }\r\n    \r\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        this.mouseDownButtons = e.buttons;\r\n        if (e.buttons == 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_PRESSED, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n    \r\n            this.nMousePrevX = EventPixel.x;\r\n            this.nMousePrevY = EventPixel.y;\r\n        }\r\n    \r\n        e.preventDefault();\r\n        e.cancelBubble = true;\r\n        if (e.stopPropagation) e.stopPropagation();\r\n    }\r\n    mouseUpHandler = e => {\r\n        this.props.closeContextMenu();\r\n        if (this.viewport.GetWindowHandle() != e.target) {\r\n            return;\r\n        }\r\n        \r\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        let buttons = this.mouseDownButtons & ~e.buttons;\r\n        if (buttons == 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_RELEASED, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    mouseDblClickHandler = e => {\r\n        if (this.viewport.GetWindowHandle() != e.target) {\r\n            return;\r\n        }\r\n        \r\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        let buttons = this.mouseDownButtons & ~e.buttons;\r\n        if (this.bEdit) {\r\n            let aTargets = this.viewport.ScanInGeometry(new window.MapCore.SMcScanPointGeometry(window.MapCore.EMcPointCoordSystem.EPCS_SCREEN, window.MapCore.SMcVector3D(EventPixel.x, EventPixel.y, 0), 20), false);\r\n            for (let i = 0; i < aTargets.length; ++i) {\r\n                if (aTargets[i].eTargetType == window.MapCore.IMcSpatialQueries.EIntersectionTargetType.EITT_OVERLAY_MANAGER_OBJECT) {\r\n                    if (this.bEdit) {\r\n                        this.editMode.StartEditObject(aTargets[i].ObjectItemData.pObject, aTargets[i].ObjectItemData.pItem);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            this.bEdit = false;\r\n            e.preventDefault();\r\n            e.cancelBubble = true;\r\n            if (e.stopPropagation) e.stopPropagation();\r\n            return;\r\n        }\r\n    \r\n        if (buttons == 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_DOUBLE_CLICK, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    createViewport(terrain, eMapTypeToOpen) {\r\n        // create canvas if needed\r\n        let currCanvas;\r\n        if (!this.state.bSameCanvas || this.aViewports.length == 0) {\r\n            // create canvas\r\n            currCanvas = document.createElement('canvas');\r\n            //currCanvas.style.border = \"thick solid #FFFFFF\"; \r\n            \r\n            currCanvas.addEventListener(\"wheel\", this.mouseWheelHandler, false);\r\n            currCanvas.addEventListener(\"mousemove\", this.mouseMoveHandler, false);\r\n            currCanvas.addEventListener(\"mousedown\", this.mouseDownHandler, false);\r\n            currCanvas.addEventListener(\"mouseup\", this.mouseUpHandler, false);\r\n            currCanvas.addEventListener(\"dblclick\", this.mouseDblClickHandler, false);\r\n        }\r\n        else {\r\n            // use existing canvas\r\n            currCanvas = this.aViewports[0].canvas;\r\n        }\r\n    \r\n        // create viewport\r\n        let layerGroup = this.state.mapLayerGroups.get(this.state.lastTerrainConfiguration);\r\n        let vpCreateData = new window.MapCore.IMcMapViewport.SCreateData(eMapTypeToOpen);\r\n        vpCreateData.pDevice = this.device;\r\n        vpCreateData.pCoordinateSystem = (terrain != null ? terrain.GetCoordinateSystem() : this.overlayManager.GetCoordinateSystemDefinition());\r\n        vpCreateData.pOverlayManager = this.overlayManager;\r\n        vpCreateData.hWnd = currCanvas;\r\n        if (layerGroup.bShowGeoInMetricProportion) {\r\n            vpCreateData.bShowGeoInMetricProportion = true;\r\n        }\r\n        this.viewport = window.MapCore.IMcMapViewport.Create(/*Camera*/null, vpCreateData, terrain != null ? [terrain] : null);\r\n        this.editMode = window.MapCore.IMcEditMode.Create(this.viewport);\r\n        \r\n        // add camera-update callback\r\n        let callback = new this.CCameraUpdateCallback();\r\n        this.viewport.AddCameraUpdateCallback(callback);\r\n\r\n        if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n            this.viewport.SetScreenSizeTerrainObjectsFactor(1.5);\r\n            this.viewport.SetCameraRelativeHeightLimits(3, 10000, true);\r\n        }\r\n        else {\r\n            this.viewport.SetStaticObjectsVisibilityMaxScale(50);\r\n            if (layerGroup.InitialScale2D) {\r\n                this.viewport.SetCameraScale(layerGroup.InitialScale2D);\r\n            }\r\n        }\r\n        \r\n        this.viewport.SetBackgroundColor(window.MapCore.SMcBColor(70, 70, 70, 255));\r\n\r\n        // set object delays for optimazing rendering objects\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_UPDATE, true, 50);\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_CONDITION, true, 50);\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_SIZE, true, 5);\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_HEIGHT, true, 50);\r\n\r\n        // set objects movement threshold\r\n        this.viewport.SetObjectsMovementThreshold(1);\r\n\r\n        // set terrain cache\r\n        if (terrain != null) {\r\n            this.viewport.SetTerrainNumCacheTiles(terrain, false, 300);\r\n            this.viewport.SetTerrainNumCacheTiles(terrain, true, 300);\r\n        }\r\n\r\n        let viewportData = new SViewportData(this.viewport, this.editMode);\r\n        viewportData.terrain = terrain;\r\n        if (layerGroup.bSetTerrainBoxByStaticLayerOnly) {\r\n            viewportData.bSetTerrainBoxByStaticLayerOnly = true;\r\n        }\r\n\r\n        this.aViewports.push(viewportData);\r\n        const canvasParent =  document.getElementById('canvasesContainer')\r\n        canvasParent.appendChild(currCanvas);\r\n        this.activeViewport = this.aViewports.length - 1;\r\n\r\n        this.updateActiveViewport();\r\n        this.resizeCanvases();\r\n        this.trySetTerainBox();\r\n    }\r\n\r\n    // function updating active viewport / Edit Mode and canvas borders\r\n    updateActiveViewport() {\r\n        if (this.activeViewport >= 0) {\r\n            for (let i = 0; i < this.aViewports.length; ++i) {\r\n                if (i == this.activeViewport) {\r\n                    this.viewport = this.aViewports[i].viewport;\r\n                    this.editMode = this.aViewports[i].editMode;\r\n                    if (!this.state.bSameCanvas) {\r\n                        //this.aViewports[i].canvas.style.borderColor = \"blue\";\r\n                    }\r\n                }\r\n                else {\r\n                    //this.aViewports[i].canvas.style.borderColor = \"white\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    doPrevViewport() {\r\n        if (this.aViewports.length > 1) {\r\n            this.activeViewport = (this.activeViewport + this.aViewports.length - 1) % this.aViewports.length;\r\n            this.updateActiveViewport();\r\n        }\r\n    }\r\n\r\n    doNextViewport() {\r\n        if (this.aViewports.length > 1)\r\n        {\r\n            this.activeViewport = (this.activeViewport + 1) % this.aViewports.length;\r\n            this.updateActiveViewport();\r\n        }\r\n    }   \r\n\r\n    // function creating terrain overlayManager and viewport, starting rendering\r\n    initializeViewports() {\r\n        let terrain = this.mapTerrains.get(this.state.lastTerrainConfiguration);\r\n        if (terrain == undefined) {            \r\n            if (this.aLastTerrainLayers.length > 0) {\r\n                terrain = window.MapCore.IMcMapTerrain.Create(this.lastCoordSys, this.aLastTerrainLayers);\r\n                terrain.AddRef();\r\n            }\r\n            else {\r\n                terrain = null;\r\n            }\r\n            this.mapTerrains.set(this.state.lastTerrainConfiguration, terrain);\r\n        }\r\n    \r\n        // create overlay manager\r\n        if (this.overlayManager == null) {            \r\n            if (this.lastCoordSys == null) {\r\n                this.lastCoordSys = window.MapCore.IMcGridUTM.Create(36, window.MapCore.IMcGridCoordinateSystem.EDatumType.EDT_ED50_ISRAEL);\r\n                this.lastCoordSys.AddRef();\r\n            }\r\n            this.overlayManager = window.MapCore.IMcOverlayManager.Create(this.lastCoordSys);\r\n            this.overlayManager.AddRef();\r\n    \r\n            // create overlay for objects\r\n            this.overlay = window.MapCore.IMcOverlay.Create(this.overlayManager);\r\n    \r\n        }\r\n    \r\n        // create map viewports\r\n        switch (this.state.lastViewportConfiguration) {\r\n            case \"2D/3D\":\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                this.createViewport(terrain,window. MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                this.DoPrevViewport();\r\n                break;\r\n            case \"3D/2D\":\r\n                if (this.state.bSameCanvas) {\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                }\r\n                else {\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                    this.doPrevViewport();\r\n                }\r\n                break;\r\n            case \"2D\":\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                break;\r\n            case \"3D\":\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                break;\r\n        }\r\n        \r\n        // example of try-catch MapCoreError\r\n        try {\r\n            // MapCore API function call\r\n        }\r\n        catch (ex) {\r\n            if (ex instanceof window.MapCoreError) {\r\n                alert(\"MapCore Error #\" + ex.name + \": \" + ex.message);\r\n            }\r\n            else {\r\n                throw ex;\r\n            }\r\n        }\r\n    \r\n        // ask the browser to render once\r\n        requestAnimationFrame(this.renderMapContinuously);\r\n    }\r\n\r\n    createMapLayersAndViewports() {\r\n        // if this terrain has not been created yet\r\n        if (this.mapTerrains.get(this.state.lastTerrainConfiguration) == undefined) {\r\n            this.aLastTerrainLayers = [];\r\n            let group = this.state.mapLayerGroups.get(this.state.lastTerrainConfiguration);            \r\n            // create coordinate system by running a code string prepared during parsing configuration files (JSON configuration file and capabilities XML of MapCoreLayerServer)\r\n            // e.g. MapCore.IMcGridCoordSystemGeographic.Create(MapCore.IMcGridCoordinateSystem.EDatumType.EDT_WGS84)\r\n            this.lastCoordSys = eval(group.coordSystemString);\r\n        \r\n            for (let i = 0; i < group.aLayerCreateStrings.length; ++i) {\r\n                // create map layer by running code string prepared during parsing configuration files (JSON configuration file and capabilities XML of MapCoreLayerServer)\r\n                // e.g. MapCore.IMcNativeRasterMapLayer.Create('http:Maps/Raster/SwissOrtho-GW') or CreateWMTSRasterLayer(...) or CreateWMSRasterLayer(...)\r\n                const layer = eval(group.aLayerCreateStrings[i]);\r\n                this.aLastTerrainLayers.push(layer);\r\n            }\r\n            this.lastCoordSys.AddRef();\r\n        }\r\n    \r\n        this.initializeViewports();\r\n    }\r\n\r\n    // async callGetCapabilitiesApi() {\r\n    //     try {\r\n    //         const response = await axios.get(config.urls.getCapabilities);\r\n    //         const capabilitiesXMLDoc =  new DOMParser().parseFromString(response.data, \"text/xml\");\r\n    //         this.parseCapabilitiesXML(capabilitiesXMLDoc, config.urls.getCapabilities);\r\n    //         this.openMap(this.context.mapToPreview.title);\r\n            \r\n    //     } catch (e) {\r\n    //         console.log('error when trying to call getCapabilities: ', e);\r\n    //     }\r\n    // }\r\n    \r\n    async openMap(title, is3d) {\r\n        const serverUrl = externalConfig.getConfiguration().MAPCORE_LAYER_SERVER_URL;        \r\n            if (serverUrl) {\r\n                try {\r\n                    const response = await axios.get(serverUrl + config.urls.getCapabilities);\r\n                    const capabilitiesXMLDoc =  new DOMParser().parseFromString(response.data, \"text/xml\");\r\n                    this.parseCapabilitiesXML(capabilitiesXMLDoc, config.urls.getCapabilities);\r\n                } catch (e) {\r\n                    console.log('error when trying to call getCapabilities: ', e);\r\n                }\r\n            } else {\r\n                this.parseLayersConfiguration([this.props.mapToShow])\r\n            }\r\n\r\n\r\n            this.state.mapLayerGroups.forEach( (value, key) => {\r\n                if (key === title) {\r\n                    \r\n                    this.setState({\r\n                            lastTerrainConfiguration: key,\r\n                            lastViewportConfiguration: is3d ? \"3D\":\"2D\"\r\n                    }, () => {\r\n                        if (this.device === null) {\r\n                            // create map device (MapCore initialization)\r\n                            let init = new window.MapCore.IMcMapDevice.SInitParams();\r\n                            init.uNumTerrainTileRenderTargets = 100;\r\n                        \r\n                            const device = window.MapCore.IMcMapDevice.Create(init);\r\n                            device.AddRef();\r\n                            this.device = device;\r\n                        \r\n                            // create callback classes\r\n                            this.createCallbackClasses();\r\n                        }        \r\n                        this.createMapLayersAndViewports();\r\n                    });\r\n                }\r\n            })                                \r\n    }\r\n\r\n    doDtmVisualization() {\r\n        if (!this.viewport.GetDtmVisualization())\r\n        {\r\n            let result = this.calcMinMaxHeights();\r\n            let DtmVisualization = new window.MapCore.IMcMapViewport.SDtmVisualizationParams();\r\n            window.MapCore.IMcMapViewport.SDtmVisualizationParams.SetDefaultHeightColors(DtmVisualization, result.minHeight, result.maxHeight);\r\n            DtmVisualization.bDtmVisualizationAboveRaster = true;\r\n            DtmVisualization.uHeightColorsTransparency = 120;\r\n            DtmVisualization.uShadingTransparency = 255;\r\n            this.viewport.SetDtmVisualization(true, DtmVisualization);\r\n        }\r\n        else\r\n        {\r\n            this.viewport.SetDtmVisualization(false);\r\n        }\r\n    }\r\n\r\n    // function closing active viewport\r\n    closeMap() {\r\n        if (this.activeViewport < 0) {\r\n            return;\r\n        }\r\n        // delete Edit Mode\r\n        this.editMode.Destroy();\r\n        // delete viewport\r\n        this.viewport.Release();\r\n        if (!this.bSameCanvas || this.aViewports.length == 1) {\r\n            // delete canvas\r\n            let currCanvas = this.aViewports[this.activeViewport].canvas;\r\n            currCanvas.removeEventListener(\"wheel\", this.mouseWheelHandler, false);\r\n            currCanvas.removeEventListener(\"mousemove\", this.mouseMoveHandler, false);\r\n            currCanvas.removeEventListener(\"mousedown\", this.mouseDownHandler, false);\r\n            currCanvas.removeEventListener(\"mouseup\", this.mouseUpHandler, false);\r\n            currCanvas.removeEventListener(\"dblclick\", this.mouseDblClickHandler, false);\r\n            let canvasParent = document.getElementById('canvasesContainer');\r\n            canvasParent.removeChild(this.aViewports[this.activeViewport].canvas);\r\n        }\r\n        // remove viewport from viewport data array\r\n        //this.activeViewport.viewport = this.activeViewport.viewport ? null :;\r\n        this.aViewports.splice(this.activeViewport, 1);\r\n        if (this.aViewports.length == 0) {\r\n            // no more viewports\r\n            this.viewport = null;\r\n            this.editMode = null;\r\n            this.activeViewport = -1;\r\n            // delete terrain\r\n            this.mapTerrains.forEach(terrain => { terrain.Release(); });\r\n            this.mapTerrains.clear();\r\n            // delete overlay manager\r\n            this.overlayManager.Release();\r\n            this.overlayManager = null;\r\n    \r\n        }\r\n        else {\r\n            // there are viewports: update active viewport\r\n            if (this.activeViewport >= this.aViewports.length) {\r\n                this.activeViewport = this.aViewports.length - 1;\r\n            }\r\n            this.updateActiveViewport();\r\n            this.resizeCanvases();\r\n        }\r\n\r\n\r\n        this.setState({\r\n            mapLayerGroups: new Map(),\r\n            lastTerrainConfiguration: null,\r\n            lastViewportConfiguration: null /*  2D/3D, 3D/2D, 2D, 3D */,\r\n            bSameCanvas: true\r\n        });\r\n    \r\n        this.mapTerrains = new Map;\r\n        this.device = null         \r\n        this.viewportData = null;\r\n        this.aLastTerrainLayers = [];\r\n        this.lastCoordSys = null;\r\n        this.overlayManager = null;\r\n        this.activeViewport = -1;\r\n        this.aViewports = [];\r\n        this.lastRenderTime = (new Date).getTime();\r\n        this.lastMemUsageLogTime = (new Date).getTime();\r\n        this.uMemUsageLoggingFrequency = 0;\r\n        this.nMousePrevX = 0;\r\n        this.nMousePrevY = 0;\r\n        this.mouseDownButtons = 0;\r\n        this.bEdit = false;\r\n\r\n    }\r\n\r\n    renderLoadingMessage() {\r\n        return (\r\n            <div className={cn.LoadingMessage}>\r\n                Map core SDK is Loading...\r\n            </div>\r\n        )\r\n    }\r\n    \r\n    renderRow(label, value) {\r\n        return (\r\n            <div className={cn.DescRow}>\r\n                <span className={cn.DescLabel}>{label}:</span>\r\n                <span className={cn.DescValue}>{value}</span>\r\n             </div>\r\n        )\r\n    }\r\n\r\n    onSelectOtherMapClicked = () => {\r\n\r\n    }\r\n\r\n    showHideDtmActionClicked = () => {\r\n        this.setState({isDTMClicked: !this.state.isDTMClicked}, this.doDtmVisualization)\r\n    }\r\n\r\n    showHide3DActionClicked = () => {\r\n        this.setState(\r\n            {\r\n                is3DClicked: !this.state.is3DClicked\r\n            }, () => this.openMap(this.props.mapToShow.groupName, this.state.is3DClicked))\r\n    }\r\n\r\n    onMoreActionsClick = (e) => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        const selectOtherMapAction = {            \r\n            name: \"Select Other Map\",\r\n            func: this.onSelectOtherMapClicked,\r\n            iconCss: \"Map\"            \r\n        };\r\n\r\n        const menuItemsList = [];\r\n\r\n        const dtmLayer = this.props.mapToShow.layers.find(layer => layer.type.toLowerCase().includes('dtm'));\r\n\r\n        if (dtmLayer) {\r\n            const showHideDtmAction = {\r\n                name: (this.state.isDTMClicked ? 'Hide' : 'Show') + \" DTM visualization\",\r\n                func: this.showHideDtmActionClicked,\r\n                iconCss: \"DTM\"\r\n            }\r\n    \r\n            const showHide3DAction = {\r\n                name: 'Switch To ' + (this.state.is3DClicked ? '2D' : '3D'),\r\n                func: this.showHide3DActionClicked,\r\n                iconCss: \"ThreeD\"\r\n            }\r\n\r\n            menuItemsList.push(showHideDtmAction);\r\n            menuItemsList.push(showHide3DAction);\r\n            menuItemsList.push(selectOtherMapAction);\r\n        }\r\n\r\n        this.props.showContextMenu(e.nativeEvent.x, e.nativeEvent.y, menuItemsList);        \r\n    }\r\n\r\n    renderMapToolbox() {        \r\n        return (\r\n            <div className={`${cn.MapToolbox}`}>\r\n                <div className={cn.Description}>\r\n                    {this.props.mapToShow.groupName}\r\n                </div>\r\n                <span className={cn.MoreActionsBtn} onClick={this.onMoreActionsClick}></span>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    getCanvas() {\r\n        return (\r\n            <div className={cn.MapWrapper}>\r\n                <div className={cn.CanvasContainer} id='canvasesContainer'></div>\r\n                {this.renderMapToolbox()}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    render() {    \r\n        return (\r\n            <div className={cn.Wrapper}>\r\n                {this.props.isMapCoreSDKLoaded ? this.getCanvas() : this.renderLoadingMessage()}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        isMapCoreSDKLoaded: state.map.isMapCoreSDKLoaded,\r\n        mapToShow: state.map.mapToShow\r\n    };\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        showContextMenu: (x, y, items) => dispatch({ type: actionTypes.SHOW_CONTEXT_MENU, payload: {x, y, items} }),\r\n        closeContextMenu: () => dispatch({ type: actionTypes.CLOSE_CONTEXT_MENU}),\r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(MapContainer);","C:\\mapCoreDrones\\wasp\\src\\config.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\Video\\Video.js",["189","190"],"C:\\mapCoreDrones\\wasp\\src\\components\\OutputTabs\\OutputTabs.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\ActionButtons\\ActionButtons.js",["191"],"import React, { Component } from 'react'\r\nimport cn from './ActionButtons.module.css'\r\nimport { connect } from 'react-redux';\r\nimport actions from '../../store/actions';\r\nimport actionTypes from '../../store/actions/actionTypes';\r\n\r\nclass ActionButtons extends Component {\r\n\r\n    getPauseIcon() {\r\n        return this.props.isPaused ? cn.PlayIcon : cn.PauseIcon\r\n    }\r\n\r\n    render() {\r\n        const isHiddenClass = this.props.isRosWebsocketConncted ? '' : cn.Hidden;\r\n        return (\r\n            <div className={`${cn.Wrapper} ${isHiddenClass}`}>\r\n                    <button className={cn.Button} onClick={this.props.takeoff}>\r\n                        <span className={`${cn.Icon} ${cn.TakeoffIcon}`}></span>\r\n                        <span className={cn.ButtonLabel}>Takeoff</span>\r\n                    </button>\r\n                    <button className={cn.Button} onClick={this.props.locate}>\r\n                        <span className={`${cn.Icon} ${cn.LocateIcon}`}></span>\r\n                        <span className={cn.ButtonLabel}>Locate</span>\r\n                    </button>\r\n                    <button className={cn.Button} onClick={this.props.reset}>\r\n                        <span className={`${cn.Icon} ${cn.ResetIcon}`}></span>\r\n                        <span className={cn.ButtonLabel}>Reset</span>\r\n                    </button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        isPaused: state.video.isPaused,\r\n        isRosWebsocketConncted: state.layout.isRosWebsocketConncted\r\n    }\r\n};\r\n\r\nconst mapDispachToProps = dispatch => {\r\n    return {\r\n        takeoff: () => dispatch(actions.takeoff()),\r\n        locate: () => dispatch(actions.locate()),\r\n        restart: () => dispatch(actions.restart()),\r\n    }\r\n}\r\n\r\nexport default connect(\r\n    mapStateToProps,\r\n    mapDispachToProps\r\n)(ActionButtons)","C:\\mapCoreDrones\\wasp\\src\\store\\interceptor.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\index.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\actionTypes.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\index.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\mapReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\videoReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\outputReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\outputActions.js",["192","193","194","195"],"import actionTypes from './actionTypes';\r\nimport axios from 'axios';\r\nimport {urls, logSeverities} from '../../config';\r\n\r\n","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\videoActions.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\mapActions.js",["196","197","198","199"],"import actionTypes from './actionTypes';\r\nimport axios from 'axios';\r\nimport {urls, logSeverities} from '../../config';\r\n","C:\\mapCoreDrones\\wasp\\src\\utils\\imageUtils.js",[],"C:\\mapCoreDrones\\wasp\\src\\services\\index.js",[],"C:\\mapCoreDrones\\wasp\\src\\rosWebsocket.js",["200"],"import config, { logSeverities } from './config';\r\nimport actionTypes from './store/actions/actionTypes';\r\nimport actions from './store/actions';\r\nimport externalConfig from './ExternalConfigurationHandler';\r\nimport {store} from './index';\r\n\r\nclass RosWebSocket {\r\n\r\n    rosWebSocket = null;\r\n\r\n    register() {\r\n        try {\r\n            const { ROS_BE_PROTOCOL, BE_IP, ROS_BE_PORT } = externalConfig.getConfiguration();\r\n            const url =  `${ROS_BE_PROTOCOL}://${BE_IP}:${ROS_BE_PORT}`;\r\n            store.dispatch({type: actionTypes.SHOW_GLOBAL_MESSAGE, payload: {text: `Trying to connect ros websocket on: ${url}`, type:logSeverities.info}})\r\n            store.dispatch(actions.showGlobalMessage({text: `Trying to connect ros websocket on: ${url}`, type:logSeverities.info}))\r\n\r\n            this.rosWebSocket = new window.ROSLIB.Ros({url});\r\n    \r\n            this.rosWebSocket.on('connection', () => {\r\n                store.dispatch(actions.showGlobalMessage({text: `Connected successfuly to ros websocket`, type:logSeverities.success, isRemoved: true}))                \r\n                store.dispatch({type: actionTypes.ROSS_WEBSOCKET_CONNECTION_SUCCESS});\r\n            });\r\n    \r\n            this.rosWebSocket.on('error', error => {                \r\n                store.dispatch(actions.showGlobalMessage({text: `Failed to connect ros websocket on: ${url}`, type:logSeverities.error}));\r\n                store.dispatch({type: actionTypes.ROSS_WEBSOCKET_CONNECTION_FAILED});\r\n                console.log(error);\r\n            });\r\n    \r\n            this.rosWebSocket.on('close', () => {\r\n                store.dispatch(actions.showGlobalMessage({text: `Connection to ros websocket on: ${url} closed`, type:logSeverities.error}))\r\n                store.dispatch({type: actionTypes.ROSS_WEBSOCKET_CONNECTION_CLOSED});\r\n            });\r\n        } catch (e) {\r\n            console.log(e);\r\n        }\r\n    }\r\n\r\n    getRosWebsocketObject() {\r\n        if (this.rosWebSocket == null) {\r\n            this.register();\r\n        }\r\n        return this.rosWebSocket;\r\n    }\r\n}\r\n\r\nexport default new RosWebSocket();\r\n\r\n\r\n\r\n","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\layoutReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\GlobalMessage\\GlobalMessage.js",["201"],"import React,{ PureComponent } from 'react';\r\nimport classNames from './GlobalMessage.module.css';\r\nimport infoIcon from '../../assets/images/infoFull.svg';\r\nimport successIcon from '../../assets/images/success.svg';\r\nimport errorIcon from '../../assets/images/errorIcon.svg';\r\nimport warnIcon from '../../assets/images/warnIcon.svg';\r\nimport { connect } from 'react-redux';\r\nimport { logSeverities } from '../../config';\r\n\r\nclass GlobalMessage extends PureComponent {    \r\n    \r\n    renderIcon() {\r\n        let icon;\r\n        switch (this.props.appGlobalMessage.type) {\r\n            case logSeverities.info:\r\n                icon = infoIcon;\r\n                break;\r\n            case logSeverities.success:\r\n                icon = successIcon;\r\n                break;\r\n            case logSeverities.warn:\r\n                icon = warnIcon;\r\n                break;\r\n            case logSeverities.error:\r\n                icon = errorIcon;\r\n                break;        \r\n            default:\r\n                icon = infoIcon;\r\n                break;\r\n        }\r\n        return <img className={classNames.Icon} src={icon}></img>\r\n    }\r\n    renderText(text) {\r\n        return <div className={classNames.Text}>{text}</div>\r\n    }\r\n\r\n    renderNotification(notification) {\r\n        return (\r\n            <div className={classNames.Wrapper}>\r\n                {this.renderIcon()}\r\n                {this.renderText(notification.text)}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    render() {      \r\n        const {appGlobalMessage} = this.props;\r\n        return appGlobalMessage && appGlobalMessage.text ? this.renderNotification(appGlobalMessage) : null\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        appGlobalMessage: state.layout.appGlobalMessage\r\n    };\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        \r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(GlobalMessage);","C:\\mapCoreDrones\\wasp\\src\\ExternalConfigurationHandler.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\layoutActions.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\ContextMenu\\ContextMenu.js",[],{"ruleId":"202","replacedBy":"203"},{"ruleId":"204","replacedBy":"205"},{"ruleId":"206","severity":1,"message":"207","line":1,"column":17,"nodeType":"208","messageId":"209","endLine":1,"endColumn":30},{"ruleId":"210","severity":1,"message":"211","line":39,"column":17,"nodeType":"212","endLine":39,"endColumn":81},{"ruleId":"213","severity":1,"message":"214","line":40,"column":21,"nodeType":"212","endLine":40,"endColumn":66},{"ruleId":"206","severity":1,"message":"215","line":1,"column":32,"nodeType":"208","messageId":"209","endLine":1,"endColumn":41},{"ruleId":"216","severity":1,"message":"217","line":47,"column":19,"nodeType":"218","messageId":"219","endLine":47,"endColumn":26,"fix":"220"},{"ruleId":"216","severity":1,"message":"217","line":62,"column":23,"nodeType":"218","messageId":"219","endLine":62,"endColumn":31,"fix":"221"},{"ruleId":"216","severity":1,"message":"217","line":63,"column":28,"nodeType":"218","messageId":"219","endLine":63,"endColumn":36,"fix":"222"},{"ruleId":"223","severity":1,"message":"224","line":124,"column":37,"nodeType":"225","messageId":"226","endLine":124,"endColumn":39},{"ruleId":"223","severity":1,"message":"224","line":130,"column":46,"nodeType":"225","messageId":"226","endLine":130,"endColumn":48},{"ruleId":"223","severity":1,"message":"227","line":159,"column":42,"nodeType":"225","messageId":"226","endLine":159,"endColumn":44},{"ruleId":"223","severity":1,"message":"227","line":171,"column":42,"nodeType":"225","messageId":"226","endLine":171,"endColumn":44},{"ruleId":"223","severity":1,"message":"227","line":183,"column":42,"nodeType":"225","messageId":"226","endLine":183,"endColumn":44},{"ruleId":"223","severity":1,"message":"227","line":196,"column":42,"nodeType":"225","messageId":"226","endLine":196,"endColumn":44},{"ruleId":"223","severity":1,"message":"227","line":209,"column":42,"nodeType":"225","messageId":"226","endLine":209,"endColumn":44},{"ruleId":"223","severity":1,"message":"227","line":224,"column":68,"nodeType":"225","messageId":"226","endLine":224,"endColumn":70},{"ruleId":"223","severity":1,"message":"227","line":264,"column":52,"nodeType":"225","messageId":"226","endLine":264,"endColumn":54},{"ruleId":"223","severity":1,"message":"224","line":278,"column":123,"nodeType":"225","messageId":"226","endLine":278,"endColumn":125},{"ruleId":"223","severity":1,"message":"227","line":292,"column":57,"nodeType":"225","messageId":"226","endLine":292,"endColumn":59},{"ruleId":"223","severity":1,"message":"227","line":325,"column":48,"nodeType":"225","messageId":"226","endLine":325,"endColumn":50},{"ruleId":"223","severity":1,"message":"224","line":330,"column":60,"nodeType":"225","messageId":"226","endLine":330,"endColumn":62},{"ruleId":"228","severity":1,"message":"229","line":338,"column":144,"nodeType":"225","messageId":"230","endLine":338,"endColumn":145},{"ruleId":"223","severity":1,"message":"227","line":371,"column":29,"nodeType":"225","messageId":"226","endLine":371,"endColumn":31},{"ruleId":"223","severity":1,"message":"227","line":373,"column":47,"nodeType":"225","messageId":"226","endLine":373,"endColumn":49},{"ruleId":"223","severity":1,"message":"224","line":379,"column":34,"nodeType":"225","messageId":"226","endLine":379,"endColumn":36},{"ruleId":"223","severity":1,"message":"227","line":426,"column":65,"nodeType":"225","messageId":"226","endLine":426,"endColumn":67},{"ruleId":"216","severity":1,"message":"217","line":488,"column":32,"nodeType":"218","messageId":"219","endLine":488,"endColumn":40,"fix":"231"},{"ruleId":"223","severity":1,"message":"224","line":502,"column":44,"nodeType":"225","messageId":"226","endLine":502,"endColumn":46},{"ruleId":"206","severity":1,"message":"232","line":503,"column":17,"nodeType":"208","messageId":"209","endLine":503,"endColumn":22},{"ruleId":"223","severity":1,"message":"224","line":516,"column":44,"nodeType":"225","messageId":"226","endLine":516,"endColumn":46},{"ruleId":"223","severity":1,"message":"224","line":519,"column":117,"nodeType":"225","messageId":"226","endLine":519,"endColumn":119},{"ruleId":"223","severity":1,"message":"227","line":553,"column":62,"nodeType":"225","messageId":"226","endLine":553,"endColumn":64},{"ruleId":"223","severity":1,"message":"227","line":574,"column":36,"nodeType":"225","messageId":"226","endLine":574,"endColumn":38},{"ruleId":"206","severity":1,"message":"233","line":585,"column":12,"nodeType":"208","messageId":"209","endLine":585,"endColumn":28},{"ruleId":"223","severity":1,"message":"227","line":641,"column":40,"nodeType":"225","messageId":"226","endLine":641,"endColumn":42},{"ruleId":"223","severity":1,"message":"224","line":664,"column":45,"nodeType":"225","messageId":"226","endLine":664,"endColumn":47},{"ruleId":"223","severity":1,"message":"227","line":672,"column":50,"nodeType":"225","messageId":"226","endLine":672,"endColumn":52},{"ruleId":"223","severity":1,"message":"227","line":682,"column":23,"nodeType":"225","messageId":"226","endLine":682,"endColumn":25},{"ruleId":"223","severity":1,"message":"224","line":683,"column":34,"nodeType":"225","messageId":"226","endLine":683,"endColumn":36},{"ruleId":"223","severity":1,"message":"227","line":685,"column":48,"nodeType":"225","messageId":"226","endLine":685,"endColumn":50},{"ruleId":"223","severity":1,"message":"224","line":714,"column":49,"nodeType":"225","messageId":"226","endLine":714,"endColumn":51},{"ruleId":"223","severity":1,"message":"227","line":720,"column":30,"nodeType":"225","messageId":"226","endLine":720,"endColumn":32},{"ruleId":"223","severity":1,"message":"227","line":730,"column":23,"nodeType":"225","messageId":"226","endLine":730,"endColumn":25},{"ruleId":"223","severity":1,"message":"224","line":751,"column":45,"nodeType":"225","messageId":"226","endLine":751,"endColumn":47},{"ruleId":"223","severity":1,"message":"227","line":757,"column":21,"nodeType":"225","messageId":"226","endLine":757,"endColumn":23},{"ruleId":"223","severity":1,"message":"224","line":770,"column":45,"nodeType":"225","messageId":"226","endLine":770,"endColumn":47},{"ruleId":"223","severity":1,"message":"227","line":779,"column":45,"nodeType":"225","messageId":"226","endLine":779,"endColumn":47},{"ruleId":"223","severity":1,"message":"227","line":793,"column":21,"nodeType":"225","messageId":"226","endLine":793,"endColumn":23},{"ruleId":"223","severity":1,"message":"227","line":809,"column":63,"nodeType":"225","messageId":"226","endLine":809,"endColumn":65},{"ruleId":"223","severity":1,"message":"227","line":842,"column":40,"nodeType":"225","messageId":"226","endLine":842,"endColumn":42},{"ruleId":"223","severity":1,"message":"227","line":890,"column":23,"nodeType":"225","messageId":"226","endLine":890,"endColumn":25},{"ruleId":"223","severity":1,"message":"227","line":922,"column":21,"nodeType":"225","messageId":"226","endLine":922,"endColumn":23},{"ruleId":"234","severity":1,"message":"235","line":948,"column":9,"nodeType":"236","messageId":"237","endLine":971,"endColumn":10},{"ruleId":"238","severity":1,"message":"239","line":951,"column":45,"nodeType":"240","messageId":"241","endLine":951,"endColumn":60,"fix":"242"},{"ruleId":"223","severity":1,"message":"227","line":992,"column":71,"nodeType":"225","messageId":"226","endLine":992,"endColumn":73},{"ruleId":"243","severity":1,"message":"244","line":997,"column":33,"nodeType":"245","messageId":"226","endLine":997,"endColumn":37},{"ruleId":"243","severity":1,"message":"244","line":1002,"column":31,"nodeType":"245","messageId":"226","endLine":1002,"endColumn":35},{"ruleId":"223","severity":1,"message":"227","line":1089,"column":57,"nodeType":"225","messageId":"226","endLine":1089,"endColumn":59},{"ruleId":"223","severity":1,"message":"227","line":1103,"column":36,"nodeType":"225","messageId":"226","endLine":1103,"endColumn":38},{"ruleId":"216","severity":1,"message":"217","line":1133,"column":28,"nodeType":"218","messageId":"219","endLine":1133,"endColumn":35,"fix":"246"},{"ruleId":"216","severity":1,"message":"217","line":1141,"column":32,"nodeType":"218","messageId":"219","endLine":1141,"endColumn":40,"fix":"247"},{"ruleId":"216","severity":1,"message":"217","line":1142,"column":37,"nodeType":"218","messageId":"219","endLine":1142,"endColumn":45,"fix":"248"},{"ruleId":"206","severity":1,"message":"249","line":8,"column":8,"nodeType":"208","messageId":"209","endLine":8,"endColumn":16},{"ruleId":"213","severity":1,"message":"214","line":91,"column":17,"nodeType":"212","endLine":99,"endColumn":19},{"ruleId":"206","severity":1,"message":"250","line":5,"column":8,"nodeType":"208","messageId":"209","endLine":5,"endColumn":19},{"ruleId":"206","severity":1,"message":"250","line":1,"column":8,"nodeType":"208","messageId":"209","endLine":1,"endColumn":19},{"ruleId":"206","severity":1,"message":"251","line":2,"column":8,"nodeType":"208","messageId":"209","endLine":2,"endColumn":13},{"ruleId":"206","severity":1,"message":"252","line":3,"column":9,"nodeType":"208","messageId":"209","endLine":3,"endColumn":13},{"ruleId":"206","severity":1,"message":"253","line":3,"column":15,"nodeType":"208","messageId":"209","endLine":3,"endColumn":28},{"ruleId":"206","severity":1,"message":"250","line":1,"column":8,"nodeType":"208","messageId":"209","endLine":1,"endColumn":19},{"ruleId":"206","severity":1,"message":"251","line":2,"column":8,"nodeType":"208","messageId":"209","endLine":2,"endColumn":13},{"ruleId":"206","severity":1,"message":"252","line":3,"column":9,"nodeType":"208","messageId":"209","endLine":3,"endColumn":13},{"ruleId":"206","severity":1,"message":"253","line":3,"column":15,"nodeType":"208","messageId":"209","endLine":3,"endColumn":28},{"ruleId":"206","severity":1,"message":"254","line":1,"column":8,"nodeType":"208","messageId":"209","endLine":1,"endColumn":14},{"ruleId":"213","severity":1,"message":"214","line":31,"column":16,"nodeType":"212","endLine":31,"endColumn":60},"no-native-reassign",["255"],"no-negated-in-lhs",["256"],"no-unused-vars","'PureComponent' is defined but never used.","Identifier","unusedVar","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'Component' is defined but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"257","text":"258"},{"range":"259","text":"258"},{"range":"260","text":"258"},"eqeqeq","Expected '!==' and instead saw '!='.","BinaryExpression","unexpected","Expected '===' and instead saw '=='.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat",{"range":"261","text":"258"},"'usage' is assigned a value but never used.","'CanvasesInColumn' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-whitespace-before-property","Unexpected whitespace before property MapCore.","MemberExpression","unexpectedWhitespace",{"range":"262","text":"263"},"no-eval","eval can be harmful.","CallExpression",{"range":"264","text":"258"},{"range":"265","text":"258"},{"range":"266","text":"258"},"'liveFeed' is defined but never used.","'actionTypes' is defined but never used.","'axios' is defined but never used.","'urls' is defined but never used.","'logSeverities' is defined but never used.","'config' is defined but never used.","no-global-assign","no-unsafe-negation",[1707,1707],"()",[2099,2099],[2148,2148],[22670,22670],[43906,43908],".",[52185,52185],[52476,52476],[52534,52534]]