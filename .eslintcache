[{"C:\\mapCoreDrones\\wasp\\src\\index.js":"1","C:\\mapCoreDrones\\wasp\\src\\ExternalConfigurationHandler.js":"2","C:\\mapCoreDrones\\wasp\\src\\rosWebsocket.js":"3","C:\\mapCoreDrones\\wasp\\src\\config.js":"4","C:\\mapCoreDrones\\wasp\\src\\store\\interceptor.js":"5","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\actionTypes.js":"6","C:\\mapCoreDrones\\wasp\\src\\components\\LoaderAlt\\LoaderAlt.js":"7","C:\\mapCoreDrones\\wasp\\src\\App.js":"8","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\index.js":"9","C:\\mapCoreDrones\\wasp\\src\\components\\Error\\Error.js":"10","C:\\mapCoreDrones\\wasp\\src\\components\\Popup\\Popup.js":"11","C:\\mapCoreDrones\\wasp\\src\\components\\Clock\\Clock.js":"12","C:\\mapCoreDrones\\wasp\\src\\components\\ContextMenu\\ContextMenu.js":"13","C:\\mapCoreDrones\\wasp\\src\\components\\GlobalMessage\\GlobalMessage.js":"14","C:\\mapCoreDrones\\wasp\\src\\components\\Main\\Main.js":"15","C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\MissionPlanner.js":"16","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Select\\Select.js":"17","C:\\mapCoreDrones\\wasp\\src\\utils\\geoCalculations.js":"18","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\index.js":"19","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\outputReducer.js":"20","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\videoReducer.js":"21","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\layoutReducer.js":"22","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\plannerReducer.js":"23","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\mapReducer.js":"24","C:\\mapCoreDrones\\wasp\\src\\components\\Popup\\PopupChildren.js":"25","C:\\mapCoreDrones\\wasp\\src\\components\\FlightTelemetry\\FlightTelemetry.js":"26","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Select\\reactSelectStyles.js":"27","C:\\mapCoreDrones\\wasp\\src\\components\\ActionButtons\\ActionButtons.js":"28","C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\MissionPlanStages\\MissionPlanStages.js":"29","C:\\mapCoreDrones\\wasp\\src\\components\\MapContainer\\MapContainer.js":"30","C:\\mapCoreDrones\\wasp\\src\\components\\Video\\Video.js":"31","C:\\mapCoreDrones\\wasp\\src\\components\\OutputTabs\\OutputTabs.js":"32","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\mapActions.js":"33","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\plannerActions.js":"34","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\outputActions.js":"35","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\layoutActions.js":"36","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\videoActions.js":"37","C:\\mapCoreDrones\\wasp\\src\\components\\SingleInputForm\\SingleInputForm.js":"38","C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\AddMissionPlanStageForm\\AddMissionPlanStageForm.js":"39","C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\MissionPlanStages\\MissionPlanStage.js":"40","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Slider\\Slider.js":"41","C:\\mapCoreDrones\\wasp\\src\\components\\SwitchMapForm\\SwitchMapForm.js":"42","C:\\mapCoreDrones\\wasp\\src\\utils\\imageUtils.js":"43","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Input\\Input.js":"44","C:\\mapCoreDrones\\wasp\\src\\services\\index.js":"45","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\RadioGroup\\RadioGroup.js":"46","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Radio\\Radio.js":"47"},{"size":1859,"mtime":1622559477716,"results":"48","hashOfConfig":"49"},{"size":335,"mtime":1621491965925,"results":"50","hashOfConfig":"49"},{"size":3095,"mtime":1623135421016,"results":"51","hashOfConfig":"49"},{"size":1730,"mtime":1623069135339,"results":"52","hashOfConfig":"49"},{"size":680,"mtime":1621491966469,"results":"53","hashOfConfig":"49"},{"size":2982,"mtime":1622548234764,"results":"54","hashOfConfig":"49"},{"size":779,"mtime":1621491966258,"results":"55","hashOfConfig":"49"},{"size":11205,"mtime":1623069135317,"results":"56","hashOfConfig":"49"},{"size":474,"mtime":1621491966471,"results":"57","hashOfConfig":"49"},{"size":215,"mtime":1621491966219,"results":"58","hashOfConfig":"49"},{"size":5636,"mtime":1621491966355,"results":"59","hashOfConfig":"49"},{"size":979,"mtime":1621491966178,"results":"60","hashOfConfig":"49"},{"size":3388,"mtime":1622548234716,"results":"61","hashOfConfig":"49"},{"size":2172,"mtime":1621491966233,"results":"62","hashOfConfig":"49"},{"size":1573,"mtime":1622548193106,"results":"63","hashOfConfig":"49"},{"size":10808,"mtime":1622548234732,"results":"64","hashOfConfig":"49"},{"size":676,"mtime":1621491966415,"results":"65","hashOfConfig":"49"},{"size":2288,"mtime":1622988692740,"results":"66","hashOfConfig":"49"},{"size":358,"mtime":1621491966453,"results":"67","hashOfConfig":"49"},{"size":1404,"mtime":1621491966474,"results":"68","hashOfConfig":"49"},{"size":557,"mtime":1621491966475,"results":"69","hashOfConfig":"49"},{"size":3220,"mtime":1622548234780,"results":"70","hashOfConfig":"49"},{"size":3975,"mtime":1622548234780,"results":"71","hashOfConfig":"49"},{"size":3776,"mtime":1623069135409,"results":"72","hashOfConfig":"49"},{"size":295,"mtime":1621491966359,"results":"73","hashOfConfig":"49"},{"size":1256,"mtime":1621491966224,"results":"74","hashOfConfig":"49"},{"size":3031,"mtime":1621491966425,"results":"75","hashOfConfig":"49"},{"size":4527,"mtime":1621491966173,"results":"76","hashOfConfig":"49"},{"size":1354,"mtime":1621491966324,"results":"77","hashOfConfig":"49"},{"size":95938,"mtime":1623141865741,"results":"78","hashOfConfig":"49"},{"size":8453,"mtime":1622988692733,"results":"79","hashOfConfig":"49"},{"size":9793,"mtime":1623143583536,"results":"80","hashOfConfig":"49"},{"size":720,"mtime":1622548234772,"results":"81","hashOfConfig":"49"},{"size":4955,"mtime":1622548234772,"results":"82","hashOfConfig":"49"},{"size":175,"mtime":1621491966466,"results":"83","hashOfConfig":"49"},{"size":425,"mtime":1621491966454,"results":"84","hashOfConfig":"49"},{"size":9896,"mtime":1623146084630,"results":"85","hashOfConfig":"49"},{"size":1450,"mtime":1621491966361,"results":"86","hashOfConfig":"49"},{"size":5296,"mtime":1622548234724,"results":"87","hashOfConfig":"49"},{"size":5423,"mtime":1622548234724,"results":"88","hashOfConfig":"49"},{"size":2732,"mtime":1621491966435,"results":"89","hashOfConfig":"49"},{"size":2919,"mtime":1621491966399,"results":"90","hashOfConfig":"49"},{"size":826,"mtime":1621491966478,"results":"91","hashOfConfig":"49"},{"size":3580,"mtime":1621491966406,"results":"92","hashOfConfig":"49"},{"size":4776,"mtime":1623145722052,"results":"93","hashOfConfig":"49"},{"size":912,"mtime":1621491966411,"results":"94","hashOfConfig":"49"},{"size":1153,"mtime":1621491966408,"results":"95","hashOfConfig":"49"},{"filePath":"96","messages":"97","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},"axarfz",{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"107","messages":"108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"111","messages":"112","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"113","usedDeprecatedRules":"98"},{"filePath":"114","messages":"115","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"116","messages":"117","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"118","messages":"119","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"120","usedDeprecatedRules":"98"},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"123","messages":"124","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"125","messages":"126","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"127","usedDeprecatedRules":"98"},{"filePath":"128","messages":"129","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"130","messages":"131","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"132","usedDeprecatedRules":"98"},{"filePath":"133","messages":"134","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"135","messages":"136","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"137","messages":"138","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"139","messages":"140","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"141","messages":"142","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"143","messages":"144","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"145","usedDeprecatedRules":"98"},{"filePath":"146","messages":"147","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"148","messages":"149","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"150","usedDeprecatedRules":"98"},{"filePath":"151","messages":"152","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"153","messages":"154","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"155","messages":"156","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"157","messages":"158","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"159","messages":"160","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"161","messages":"162","errorCount":0,"warningCount":80,"fixableErrorCount":0,"fixableWarningCount":7,"source":"163","usedDeprecatedRules":"98"},{"filePath":"164","messages":"165","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"166","usedDeprecatedRules":"98"},{"filePath":"167","messages":"168","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"169","usedDeprecatedRules":"98"},{"filePath":"170","messages":"171","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"172","messages":"173","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"174","messages":"175","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"176","messages":"177","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"178","messages":"179","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"180","messages":"181","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"182","messages":"183","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"184","usedDeprecatedRules":"98"},{"filePath":"185","messages":"186","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"187","usedDeprecatedRules":"98"},{"filePath":"188","messages":"189","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"190","messages":"191","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"192","messages":"193","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"194","messages":"195","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"196","usedDeprecatedRules":"98"},{"filePath":"197","messages":"198","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"199","messages":"200","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},{"filePath":"201","messages":"202","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"98"},"C:\\mapCoreDrones\\wasp\\src\\index.js",[],["203","204"],"C:\\mapCoreDrones\\wasp\\src\\ExternalConfigurationHandler.js",[],"C:\\mapCoreDrones\\wasp\\src\\rosWebsocket.js",[],"C:\\mapCoreDrones\\wasp\\src\\config.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\interceptor.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\actionTypes.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\LoaderAlt\\LoaderAlt.js",[],"C:\\mapCoreDrones\\wasp\\src\\App.js",["205","206","207","208","209"],"import React, { PureComponent, Component } from 'react';\r\nimport logo from '../src/assets/images/newLogo.svg';\r\nimport classNames from './App.module.css';\r\nimport Loader from './components/LoaderAlt/LoaderAlt';\r\nimport Clock from './components/Clock/Clock';\r\nimport Select from './components/controls/Select/Select';\r\nimport Popup from './components/Popup/Popup';\r\nimport Error from './components/Error/Error';\r\nimport GlobalMessage from './components/GlobalMessage/GlobalMessage';\r\nimport actionTypes from './store/actions/actionTypes';\r\nimport { connect } from 'react-redux';\r\nimport ContextMenu from './components/ContextMenu/ContextMenu';\r\nimport externalConfig from './ExternalConfigurationHandler';\r\nimport { Switch, Route, withRouter } from 'react-router-dom';\r\nimport Main from './components/Main/Main';\r\nimport MissionPlanner from './components/MissionPlanner/MissionPlanner';\r\nimport * as geoCalculations from './utils/geoCalculations';\r\n\r\nclass App extends Component {\r\n\r\n    disableZoomInTouchScreen = e => {\r\n        if (e.touches.length > 1) {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        window.MapCore.SetStartCallbackFunction(this.props.setMapCoreSDKLoadedFlag);\r\n\r\n        const defaultGroup = externalConfig.getConfiguration().streamingLayers[0];\r\n        this.props.setMapToShow(defaultGroup);\r\n\r\n        //Disable zoom in touch\r\n        window.addEventListener('touchstart', this.disableZoomInTouchScreen, { passive: false });\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('touchstart', this.disableZoomInTouchScreen);\r\n    }\r\n\r\n    closeErrorPopup = () => {\r\n        this.setState({\r\n            generalErrorMessage: false,\r\n        });\r\n    };\r\n\r\n    getGeneralErrorPopup() {\r\n        if (false) {\r\n            return (\r\n                <Popup\r\n                    buttonOk='OK'\r\n                    header={''}\r\n                    hideXButton\r\n                    onOk={this.closeErrorPopup}>\r\n                    <Error errorMsg={''} />\r\n                </Popup>\r\n            );\r\n        }\r\n        return null;\r\n    }\r\n\r\n    getClock() {\r\n        return <Clock />;\r\n    }\r\n\r\n    formatPosition(value) {\r\n        if (value === null || value === undefined) return null;\r\n        return Math.round(value);\r\n    }\r\n    renderDroneSelect() {\r\n        const droneList = externalConfig.getConfiguration().DRONES_DATA.dronesList; \r\n        const options = droneList.map(number => ({label: number}))\r\n        const dropDownData = {\r\n            defaultValue: {label: droneList[0]},\r\n            options,\r\n            onChange: droneNumber => this.handleTypeChange(droneNumber)\r\n        };\r\n\r\n        return (\r\n            <div className={classNames.Row}>\r\n                <Select {...dropDownData} />\r\n            </div>\r\n        )\r\n    }\r\n\r\n\r\n    handleTypeChange = (droneNumber) => {\r\n        this.props.selectDrone(droneNumber.label);\r\n    }\r\n\r\n    getMainHeader() {\r\n        const dronePosition = this.props.dronesPositions[this.props.selectedDrone];\r\n        let droneOffset = null;\r\n        let coordinateWithOffset = null;\r\n        if(dronePosition && dronePosition.offset){\r\n            droneOffset = geoCalculations.roundCoordinate(dronePosition.offset);\r\n            coordinateWithOffset = geoCalculations.getMapCoordinate(dronePosition.workingOrigin , dronePosition.offset);\r\n        }\r\n\r\n        let droneColor = \"#2ce5f6\";\r\n        const droneList = externalConfig.getConfiguration().DRONES_DATA.dronesList; \r\n        if(droneList.indexOf(this.props.selectedDrone) == 1){\r\n            droneColor = \"green\";\r\n        }\r\n        else if (droneList.indexOf(this.props.selectedDrone) == 2){\r\n            droneColor = \"orange\";\r\n        }\r\n        return (\r\n            <header className={classNames.AppHeader} style={{borderBottomColor : droneColor }} >\r\n                <div className={classNames.LogoWrapper} onClick={() => this.props.history.push('/')}>\r\n                    <img src={logo} alt='logo' />\r\n                    <span className={classNames.VersionText}>version: 21.05.26 </span>\r\n                </div>\r\n                <div className={classNames.HeaderLeftWrapper}>\r\n                    <span className={classNames.HeaderItem}>\r\n                        <span style={{backgroundColor : droneColor }} className={`${classNames.Icon} ${classNames.DroneIcon}`}></span>\r\n                        <span className={classNames.DroneSelectionWrapper}>\r\n                            {this.renderDroneSelect()}\r\n                        </span>\r\n                    </span>\r\n                    <span className={classNames.HeaderItem}>\r\n                        <span className={classNames.LongLatWrapper}>\r\n                            <span className={classNames.MissionWrapper}>\r\n                                <span className={classNames.lonLatLabel}>Mission:</span>\r\n                            </span>\r\n                            <span className={classNames.MissionValueWrapper}>\r\n                                <span className={classNames.MissionValue}>{this.props.missionState}</span>\r\n                            </span>\r\n                        </span>\r\n                    </span>\r\n                    <span className={classNames.HeaderItem}>\r\n                        <span className={`${classNames.Icon} ${classNames.PositionIcon}`}></span>\r\n                        <span className={classNames.LongLatWrapper}>\r\n                            <span>\r\n                                <span className={classNames.lonLatLabel}>X:</span>\r\n                                <span className={classNames.lonLatValue}>{coordinateWithOffset ? this.formatPosition(coordinateWithOffset.x) : \"N/A\"}</span>\r\n                            </span>\r\n                            <span>\r\n                                <span className={classNames.lonLatLabel}>Y:</span>\r\n                                <span className={classNames.lonLatValue}>{coordinateWithOffset ? this.formatPosition(coordinateWithOffset.y) : \"N/A\"}</span>\r\n                            </span>\r\n                            <span>\r\n                                <span className={classNames.lonLatLabel}>Z:</span>\r\n                                <span className={classNames.lonLatValue}>{coordinateWithOffset ? this.formatPosition(coordinateWithOffset.z) : \"N/A\"}</span>\r\n                            </span>\r\n                        </span>\r\n                    </span>\r\n                    <span className={classNames.HeaderItem}>\r\n                        <span className={`${classNames.Icon} ${classNames.CompassIcon}`}></span>\r\n                        <span className={classNames.LongLatWrapper}>\r\n                            <span>\r\n                                <span className={classNames.lonLatLabel}>X:</span>\r\n                                <span className={classNames.lonLatValue}>{droneOffset ? droneOffset.x : \"N/A\"}</span>\r\n                            </span>\r\n                            <span>\r\n                                <span className={classNames.lonLatLabel}>Y:</span>\r\n                                <span className={classNames.lonLatValue}>{droneOffset ? droneOffset.y : \"N/A\"}</span>\r\n                            </span>\r\n                            <span>\r\n                                <span className={classNames.lonLatLabel}>Z:</span>\r\n                                <span className={classNames.lonLatValue}>{droneOffset ? droneOffset.z : \"N/A\"}</span>\r\n                            </span>\r\n                        </span>\r\n                    </span>\r\n                    <span className={classNames.HeaderItem}><span className={`${classNames.Icon} ${classNames.WifiIcon}`}></span></span>\r\n                    <span className={classNames.HeaderItem}>\r\n                        <span className={`${classNames.Icon} ${classNames.BatteryIcon}`}></span>\r\n                        <span className={classNames.BatteryValue}>59%</span>\r\n                    </span>\r\n                    <div className={classNames.HeaderItem}>{this.getClock()}</div>\r\n                    <button className={classNames.MenuBtn}\r\n                        onClick={this.props.dronesPositions[this.props.selectedDrone] &&\r\n                            this.props.dronesPositions[this.props.selectedDrone].workingOrigin ?\r\n                            this.props.toggleMissionPlannerScreen :\r\n                            () => alert(\"Need to select working origin first.\")}>\r\n                        <span className={`${classNames.Icon} ${classNames.MissionPlannerIcon}`}></span>\r\n                    </button>\r\n                </div>\r\n            </header>\r\n        );\r\n    }\r\n\r\n    //  onMoreActionsClick = (e) => {\r\n    //      e.preventDefault();\r\n    //      e.stopPropagation();\r\n\r\n    //      const menuItemsList = [\r\n    //          {\r\n    //              name: \"Mission Planner Page\",\r\n    //              func: this.props.showMissionPlannerScreen,\r\n    //              iconCss: \"MissionPlannerIcon\"\r\n    //          }\r\n    //      ];\r\n\r\n    //      this.props.showContextMenu(e.clientX, e.clientY, menuItemsList);\r\n    //  }\r\n\r\n    render() {\r\n\r\n        if (this.props.isLoading) {\r\n            return <Loader loadingMessage={'initializing...'} />;\r\n        }\r\n\r\n        const plannerHiddenClass = this.props.isMissionPlanScreenHidden ? ` ${classNames.MissionPlannerHidden}` : '';\r\n\r\n        return (\r\n            <div className={classNames.App}>\r\n                <GlobalMessage />\r\n                {this.props.popupDetails ? <Popup popupDetails={this.props.popupDetails} /> : null}\r\n                {this.props.contextMenu ? <ContextMenu contextMenu={this.props.contextMenu} /> : null}\r\n                {this.getGeneralErrorPopup()}\r\n                {this.getMainHeader()}\r\n                <Main isMissionPlanScreenHidden={this.props.isMissionPlanScreenHidden} />\r\n                <div className={`${classNames.MissionPlannerOverlay}${plannerHiddenClass}`}>\r\n                    <MissionPlanner />\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        contextMenu: state.layout.contextMenu,\r\n        popupDetails: state.layout.popupDetails,\r\n        missionState: state.output.missionState || 'N/A',\r\n        isMissionPlanScreenHidden: state.layout.isMissionPlanScreenHidden,\r\n        dronesPositions: state.map.dronesPositions,\r\n        selectedDrone: state.map.selectedDrone\r\n    }\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        setMapCoreSDKLoadedFlag: () => dispatch({ type: actionTypes.SET_MAPCORE_SDK_LOADED_FLAG }),\r\n        setMapToShow: groupNode => dispatch({ type: actionTypes.SET_MAP_TO_SHOW, payload: groupNode }),\r\n        showContextMenu: (x, y, items) => dispatch({ type: actionTypes.SHOW_CONTEXT_MENU, payload: { x, y, items } }),\r\n        toggleMissionPlannerScreen: () => dispatch({ type: actionTypes.TOGGLE_MISSION_PLANNER_SCREEN }),\r\n        selectDrone: (droneNumber) => dispatch({ type: actionTypes.SELECT_DRONE, payload: { droneNumber } }),\r\n    };\r\n};\r\n\r\nexport default withRouter(connect(mapStateToProps, mapDispachToProps)(App));\r\n\r\n//export default connect(mapStateToProps, mapDispachToProps)(App);\r\n","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\index.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\Error\\Error.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\Popup\\Popup.js",["210","211"],"import React, { PureComponent } from 'react';\r\nimport cn from './Popup.module.css';\r\nimport closeImg from '../../assets/images/close.svg';\r\nimport PopupChildren from './PopupChildren';\r\nimport { connect } from 'react-redux';\r\nimport actionTypes from '../../store/actions/actionTypes';\r\n\r\nclass Popup extends PureComponent {\r\n    EscKey = 27;\r\n    EnterKey = 13;\r\n\r\n    componentDidMount() {\r\n        document.addEventListener('keydown', this.handleKeyDown);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        document.removeEventListener('keydown', this.handleKeyDown);\r\n    }\r\n\r\n    handleKeyDown = (e) => {\r\n        if (e.keyCode === this.EscKey) {\r\n            this.closePopup();\r\n        } else if ((e.keyCode === this.EnterKey) && this.props.popupDetails.primayButton && this.props.popupDetails.primayButton.callback) {\r\n            this.props.popupDetails.primayButton.callback();\r\n            this.closePopup();\r\n        }\r\n    }\r\n\r\n    closePopup = () => {\r\n        if (this.props.popupDetails && this.props.popupDetails.onCloseButtonClick) {\r\n            this.props.popupDetails.onCloseButtonClick();\r\n        }\r\n        this.props.hidePopup();\r\n    }\r\n\r\n    onCloseBtnClick = e => {\r\n        e.preventDefault();\r\n        this.closePopup()\r\n    }\r\n\r\n    getXBtn() {\r\n        return (\r\n            this.props.hideXButton ? null :\r\n                <a className={cn.Close} href=\"#\" onClick={this.onCloseBtnClick}>\r\n                    <img className={cn.closeBtn} src={closeImg} />\r\n                </a>\r\n        );\r\n    }\r\n    closePopup() {\r\n        if (this.props.popupDetails && this.props.popupDetails.onCloseButtonClick) {\r\n            this.props.popupDetails.onCloseButtonClick();\r\n        }\r\n        this.props.hidePopup();\r\n    }\r\n\r\n    onPrimaryBtnClick = e => {\r\n        e.preventDefault();\r\n        if (this.props.popupDetails.primayButton && this.props.popupDetails.primayButton.callback) {\r\n            this.props.popupDetails.primayButton.callback();\r\n        }\r\n        this.closePopup();\r\n    }\r\n\r\n    onSecondaryBtnClick = e => {\r\n        e.preventDefault();\r\n        if (this.props.popupDetails.secondaryButton && this.props.popupDetails.secondaryButton.callback) {\r\n            this.props.popupDetails.secondaryButton.callback();\r\n        }\r\n        this.closePopup();\r\n    }\r\n\r\n    renderButtons() {\r\n        //default primary button in case no other button was injected as props\r\n        let primaryButton = <button type=\"button\" className={`${cn.Btn} ${cn.BtnPrimary}`} onClick={this.onPrimaryBtnClick}>Close</button>;\r\n        let secondaryButton = null;\r\n        const popupDetails = this.props.popupDetails;\r\n\r\n        if (popupDetails.primayButton) {\r\n            let disabled = popupDetails.primayButton.disabled;\r\n            primaryButton =\r\n                <button type=\"button\"\r\n                    className={`${cn.FormButton} ${cn.Apply} ${disabled ? cn.Disabled : \"\"}`}\r\n                    onClick={disabled ? undefined : this.onPrimaryBtnClick}>\r\n                    {popupDetails.primayButton.title}\r\n                </button>;\r\n        }\r\n\r\n        if (popupDetails.secondaryButton) {\r\n            let disabled = popupDetails.secondaryButton.disabled;\r\n            secondaryButton =\r\n                <button type=\"button\"\r\n                    className={`${cn.FormButton}   ${disabled ? cn.Disabled : \"\"}`}\r\n                    onClick={disabled ? undefined : this.onSecondaryBtnClick}>\r\n                    {popupDetails.secondaryButton.title}\r\n                </button>\r\n        }\r\n\r\n        return (\r\n            <>\r\n                {secondaryButton}\r\n                {primaryButton}\r\n            </>\r\n        )\r\n    }\r\n\r\n    getFooter() {\r\n        return (\r\n\r\n            <div className={cn.PopupFooter}>\r\n                <div>\r\n                    {this.renderButtons()}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    getHeader() {\r\n        return (\r\n            <div className={cn.PopupHeader}>\r\n                <div className={cn.PopupHeaderWrapper}>\r\n                    <h2 className={cn.h2}>{this.props.popupDetails.title}</h2>\r\n                    {this.getXBtn()}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n    renderChild() {\r\n        const Child = PopupChildren[this.props.popupDetails.modalChild];\r\n        return <Child {...this.props.popupDetails.modalChildProps} />;\r\n    }\r\n\r\n    getBody() {\r\n        const noBodyOverflowClass = this.props.noBodyOverflow ? cn.NoBodyOverFlow : '';\r\n\r\n        const body =\r\n            <div className={`${cn.PopupBody} ${noBodyOverflowClass}`}>\r\n                {this.props.popupDetails.modalChild ? this.renderChild() : null}\r\n            </div>;\r\n        return body;\r\n    }\r\n\r\n    render() {\r\n        if (!this.props.popupDetails) return null;\r\n        let visibility = this.props.isPointSelectionMode ? { visibility: \"hidden\" } : {};\r\n        const size = this.props.popupDetails.size ? cn[this.props.popupDetails.size] : '';\r\n        return (\r\n            <div className={cn.Overlay} >\r\n                <div className={`${cn.Popup} ${size}`} style={visibility}>\r\n                    {this.getHeader()}\r\n                    {this.getBody()}\r\n                    {this.getFooter()}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst mapStateToProps = state => {\r\n    return {\r\n        isPointSelectionMode: state.layout.isPointSelectionMode\r\n    }\r\n};\r\n\r\nconst mapDispachToProps = dispatch => {\r\n    return {\r\n        hidePopup: () => dispatch({ type: actionTypes.HIDE_POPUP })\r\n\r\n    }\r\n}\r\n\r\nexport default connect(\r\n    mapStateToProps,\r\n    mapDispachToProps\r\n)(Popup)","C:\\mapCoreDrones\\wasp\\src\\components\\Clock\\Clock.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\ContextMenu\\ContextMenu.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\GlobalMessage\\GlobalMessage.js",["212"],"import React,{ PureComponent } from 'react';\r\nimport classNames from './GlobalMessage.module.css';\r\nimport infoIcon from '../../assets/images/infoFull.svg';\r\nimport successIcon from '../../assets/images/success.svg';\r\nimport errorIcon from '../../assets/images/errorIcon.svg';\r\nimport warnIcon from '../../assets/images/warnIcon.svg';\r\nimport { connect } from 'react-redux';\r\nimport { logSeverities } from '../../config';\r\n\r\nclass GlobalMessage extends PureComponent {    \r\n    \r\n    renderIcon() {\r\n        let icon;\r\n        switch (this.props.appGlobalMessage.type) {\r\n            case logSeverities.info:\r\n                icon = infoIcon;\r\n                break;\r\n            case logSeverities.success:\r\n                icon = successIcon;\r\n                break;\r\n            case logSeverities.warn:\r\n                icon = warnIcon;\r\n                break;\r\n            case logSeverities.error:\r\n                icon = errorIcon;\r\n                break;        \r\n            default:\r\n                icon = infoIcon;\r\n                break;\r\n        }\r\n        return <img className={classNames.Icon} src={icon}></img>\r\n    }\r\n    renderText(text) {\r\n        return <div className={classNames.Text}>{text}</div>\r\n    }\r\n\r\n    renderNotification(notification) {\r\n        const missionPlannerOpenClass = this.props.isMissionPlanScreenHidden ? '' : ` ${classNames.MissionPlannerOpen}`;\r\n\r\n        return (\r\n            <div className={`${classNames.Wrapper}${missionPlannerOpenClass}`}>\r\n                {this.renderIcon()}\r\n                {this.renderText(notification.text)}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    render() {      \r\n        const {appGlobalMessage} = this.props;\r\n        return appGlobalMessage && appGlobalMessage.text ? this.renderNotification(appGlobalMessage) : null\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        appGlobalMessage: state.layout.appGlobalMessage,\r\n        isMissionPlanScreenHidden: state.layout.isMissionPlanScreenHidden\r\n    };\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        \r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(GlobalMessage);","C:\\mapCoreDrones\\wasp\\src\\components\\Main\\Main.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\MissionPlanner.js",["213","214"],"import React, { Component } from 'react'\r\nimport cn from './MissionPlanner.module.css';\r\nimport { connect } from 'react-redux';\r\nimport actionTypes from '../../store/actions/actionTypes';\r\nimport actions from '../../store/actions';\r\nimport MissionPlanStages from './MissionPlanStages/MissionPlanStages';\r\nimport { withRouter } from 'react-router-dom';\r\nimport { logSeverities } from '../../config';\r\nimport { viewerStates } from '../../store/reducers/plannerReducer';\r\n\r\nclass MissionPlanner extends Component {\r\n\r\n    inputRef = React.createRef();\r\n\r\n    addMissionPlanStageFormPopupOkBtnClick = () => {\r\n        const addStageState = this.getAddMissionPlanStageFormState();\r\n        if (addStageState && addStageState.selectedStageType) {\r\n            this.props.addNewStage(addStageState)\r\n        }\r\n    }\r\n\r\n    onStartNewMissionClick = () => {\r\n        const popupDetails = {\r\n            title: 'Add First Stage',\r\n            modalChild: 'AddMissionPlanStageForm',\r\n            modalChildProps: {\r\n                size: 'small',\r\n                onPopupInitalLoad: getChildState => this.getAddMissionPlanStageFormState = getChildState,\r\n                selectPointFromMap: this.selectPointFromMap,\r\n            },\r\n            onCloseButtonClick: () => {\r\n            },\r\n            primayButton: {\r\n                title: 'Add',\r\n                disabled: false,\r\n                callback: this.addMissionPlanStageFormPopupOkBtnClick\r\n            },\r\n            secondaryButton: {\r\n                title: 'Cancel',\r\n                callback: () => { }\r\n            }\r\n        };\r\n        this.props.showPopup(popupDetails);\r\n    }\r\n\r\n    renderStartNewMissionButton() {\r\n        return (\r\n            <button className={cn.StartNewBtn} onClick={this.onStartNewMissionClick}>Start New Mission Plan</button>\r\n        )\r\n    }\r\n\r\n\r\n    renderMissionPlanStages() {\r\n\r\n\r\n        const { viewerState, draftMissionStages, savedMissionPlan } = this.props;\r\n        if (viewerState === viewerStates.draft) {\r\n            return (\r\n                draftMissionStages.length ?\r\n                    <MissionPlanStages\r\n                        missionStages={viewerState === viewerStates.draft ? draftMissionStages : savedMissionPlan}\r\n                        isReadOnly={viewerState === viewerStates.savedMission}\r\n                    /> :\r\n                    this.renderStartNewMissionButton()\r\n            )\r\n        } else {\r\n            // saved mission plan flow\r\n            return (\r\n                savedMissionPlan.length > 0 ?\r\n                    <MissionPlanStages\r\n                        missionStages={viewerState === viewerStates.draft ? draftMissionStages : savedMissionPlan}\r\n                        isReadOnly={viewerState === viewerStates.savedMission}\r\n                    /> :\r\n                    <div className={cn.EmptyPlanStagesMessage}>\r\n                        No Saved Plan in Memory\r\n                </div>\r\n            )\r\n        }\r\n    }\r\n\r\n    selectPointFromMap = () => {\r\n        this.props.togglePointSelectionMode();\r\n    }\r\n\r\n    onBackBtnClick = () => {\r\n        this.props.toggleMissionPlannerScreen();\r\n    }\r\n\r\n    onSaveBtnClick = () => {\r\n        this.props.saveMissionPlan();\r\n        this.props.toggleViewerState();\r\n        this.props.showGlobalMessage('Draft Successfuly Saved');\r\n    }\r\n\r\n    onClearDraftBtnClick = () => {\r\n        this.props.removeDraftPlan();\r\n    }\r\n\r\n    onRemoveSavedPlanBtnClick = () => {\r\n        this.props.removeSavedPlan();\r\n        this.props.showGlobalMessage('Mission Plan Successfuly Removed');\r\n    }\r\n\r\n    onLoadMissionFromDroneBtnClick = () => {\r\n        this.props.importMissionFromDroneFile();\r\n    }\r\n\r\n    onLoadMissionFromPcBtnClick = () => {\r\n        this.inputRef.current.click();\r\n\r\n    }\r\n\r\n    parseConfigurationFile = (e) => {\r\n        const fileReader = new FileReader();\r\n        if (e.target.files && e.target.files[0]) {\r\n            console.log(\"Reading file: \" + e.target.files[0]);\r\n            fileReader.readAsText(e.target.files[0], \"UTF-8\");\r\n            fileReader.onload = e => {\r\n                const missionData = JSON.parse(e.target.result);\r\n                this.props.importMissionFromPcFile(missionData);\r\n            };\r\n            fileReader.onerror = e => {\r\n                console.log(\"parseConfigurationFile: error reading file\");\r\n            };\r\n        }\r\n    }\r\n\r\n\r\n    onExportMissionBtnClick = () => {\r\n        const { draftMissionStages, savedMissionPlan, viewerState } = this.props;\r\n        const plan = viewerState === viewerStates.draft ? draftMissionStages : savedMissionPlan;\r\n        this.props.exportPlanToFile(plan, viewerState);\r\n    }\r\n\r\n\r\n    onLoadMissionBtnClick = e => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        const menuItemsList = [\r\n            {\r\n                name: \"Load From PC\",\r\n                func: this.onLoadMissionFromPcBtnClick,\r\n                iconCss: \"PcIcon\"\r\n            },\r\n            {\r\n                name: \"Load From Drone\",\r\n                func: this.onLoadMissionFromDroneBtnClick,\r\n                iconCss: \"DroneIcon\"\r\n            },\r\n        ];\r\n\r\n        this.props.showContextMenu(e.clientX, e.clientY, { side: 'left' }, menuItemsList);\r\n    }\r\n\r\n\r\n    renderDraftButtons(draftMissionStages) {\r\n        const buttons = [];\r\n\r\n        if (draftMissionStages.length > 0) {\r\n            buttons.push(<button title='Save Plan' className={`${cn.SideBarBtn} ${cn.Save}`} onClick={this.onSaveBtnClick} />)\r\n            buttons.push(<button title='Clear Draft Stages' className={`${cn.SideBarBtn} ${cn.ClearStages}`} onClick={this.onClearDraftBtnClick} />)\r\n            buttons.push(<button title='Download Draft' className={`${cn.SideBarBtn} ${cn.Export}`} onClick={this.onExportMissionBtnClick} />)\r\n        }\r\n        buttons.push(<button title='Load Mission Plan' className={`${cn.SideBarBtn} ${cn.Import}`} onClick={e => this.onLoadMissionBtnClick(e)} />)\r\n\r\n        return buttons;\r\n    }\r\n\r\n    renderSavedPlanButtons(savedMissionPlan) {\r\n        const buttons = [];\r\n\r\n        if (savedMissionPlan.length > 0) {\r\n            buttons.push(<button title='Remove Saved Plan' className={`${cn.SideBarBtn} ${cn.Remove}`} onClick={this.onRemoveSavedPlanBtnClick} />)\r\n            buttons.push(<button title='Download Saved Plan' className={`${cn.SideBarBtn} ${cn.Export}`} onClick={this.onExportMissionBtnClick} />)\r\n        }\r\n        buttons.push(<button title='Load Mission Plan From File' className={`${cn.SideBarBtn} ${cn.Import}`} onClick={this.onLoadMissionBtnClick} />)\r\n\r\n        return buttons;\r\n    }\r\n\r\n\r\n    renderSideBar() {\r\n        const { draftMissionStages, savedMissionPlan, viewerState } = this.props;\r\n        let buttons = [<button title='Back to Main' className={`${cn.SideBarBtn} ${cn.ClosePlanner}`} onClick={this.onBackBtnClick} />];\r\n        ;\r\n        if (viewerState === viewerStates.draft) {\r\n            buttons.push(...this.renderDraftButtons(draftMissionStages));\r\n        } else {\r\n            buttons.push(...this.renderSavedPlanButtons(savedMissionPlan));\r\n        }\r\n\r\n        return (\r\n            <div className={cn.SideBar}>\r\n                <div className={cn.SideBarButtons}>\r\n                    {buttons}\r\n                </div>\r\n                <span className={cn.SidebarLabel}>Mission Planner</span>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    onSwitchViewStateClick = e => {\r\n        e.preventDefault();\r\n        this.props.toggleViewerState();\r\n    }\r\n\r\n    getSwithBtnTitle(viewerState) {\r\n        return `View ${viewerState === viewerStates.draft ? 'Saved Mission' : 'Draft Mission'}`;\r\n    }\r\n\r\n    renderHeader() {\r\n        const { viewerState } = this.props;\r\n        const icon = viewerState === viewerStates.draft ? ` ${cn.DraftIcon}` : ` ${cn.SavedPlanIcon}`\r\n        return (\r\n            <div className={cn.Header}>\r\n                <span></span>\r\n                <span className={cn.HeaderTextWrapper}>\r\n                    <span className={cn.HeaderTextState}>{viewerState === viewerStates.draft ? 'Mission Draft' : 'Saved Mission'}</span>\r\n                    <a href={'#'} className={cn.HeaderBtnWrapper} onClick={this.onSwitchViewStateClick} title={this.getSwithBtnTitle(viewerState)}>\r\n                        <span className={cn.HeaderBtn}></span>\r\n                    </a>\r\n                </span>\r\n            </div>\r\n        )\r\n    }\r\n\r\n\r\n    render() {\r\n        const centerClass = !this.props.draftMissionStages.length ? cn.Center : '';\r\n        return (\r\n            <>\r\n                {this.renderSideBar()}\r\n                <div className={`${cn.Wrapper} ${centerClass}`}>\r\n                    {this.renderHeader()}\r\n                    {this.renderMissionPlanStages()}\r\n                </div>\r\n                <input type=\"file\" style={{ display: 'none' }} accept={\"application/json\"} ref={this.inputRef} onChange={(e) => this.parseConfigurationFile(e)} />\r\n            </>)\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        draftMissionStages: state.planner.draftMissionStages,\r\n        savedMissionPlan: state.planner.savedMissionPlan,\r\n        viewerState: state.planner.viewerState\r\n    }\r\n};\r\n\r\nconst mapDispachToProps = dispatch => {\r\n    return {\r\n        showPopup: details => dispatch({ type: actionTypes.SHOW_POPUP, payload: details }),\r\n        showGlobalMessage: text => dispatch(actions.showGlobalMessage({ text, type: logSeverities.success, isRemoved: true })),\r\n        addNewStage: stage => dispatch({ type: actionTypes.ADD_NEW_MISSION_PLAN_STAGE, payload: stage }),\r\n        toggleMissionPlannerScreen: () => dispatch({ type: actionTypes.TOGGLE_MISSION_PLANNER_SCREEN }),\r\n        saveMissionPlan: () => dispatch({ type: actionTypes.SAVE_MISSION_PLAN }),\r\n        removeDraftPlan: () => dispatch({ type: actionTypes.REMOVE_DRAFT_MISSION_PLAN }),\r\n        removeSavedPlan: () => dispatch({ type: actionTypes.REMOVE_SAVED_MISSION_PLAN }),\r\n        toggleViewerState: () => dispatch({ type: actionTypes.TOGGLE_MISSION_PLAN_VIEWER_STATE }),\r\n        importMissionFromDroneFile: () => dispatch(actions.importMissionFromDroneFile()),\r\n        importMissionFromPcFile: (missionData) => dispatch(actions.importMissionFromPcFile(missionData)),\r\n        exportPlanToFile: (plan, viewerState) => dispatch(actions.exportPlanToFile(plan, viewerState)),\r\n        togglePointSelectionMode: () => dispatch({ type: actionTypes.TOGGLE_POINT_SELECTION_MODE }),\r\n        showContextMenu: (x, y, options, items) => dispatch({ type: actionTypes.SHOW_CONTEXT_MENU, payload: { x, y, options, items } }),\r\n    }\r\n}\r\n\r\nexport default withRouter(connect(mapStateToProps, mapDispachToProps)(MissionPlanner));\r\n\r\n// export default connect(\r\n//     mapStateToProps,\r\n//     mapDispachToProps\r\n// )(MissionPlanner)\r\n","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Select\\Select.js",[],"C:\\mapCoreDrones\\wasp\\src\\utils\\geoCalculations.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\index.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\outputReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\videoReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\layoutReducer.js",["215"],"import actionTypes from '../actions/actionTypes';\r\nimport externalConfig from '../../ExternalConfigurationHandler';\r\n\r\nconst initialState = {\r\n    appGlobalMessage: null,\r\n    isRosWebsocketConncted: false,\r\n    contextMenu: null,    //{x,y,menuItems}\r\n    popupDetails: null,\r\n    imageSentToDroneData: null,\r\n    isMissionPlanScreenHidden: true,\r\n    isPointSelectionMode: false,\r\n};\r\n\r\nconst layoutReducer = (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case actionTypes.SHOW_GLOBAL_MESSAGE:\r\n            return {\r\n                ...state,\r\n                appGlobalMessage: { text: action.payload.text, type: action.payload.type }\r\n            }\r\n        case actionTypes.REMOVE_GLOBAL_MESSAGE:\r\n            return {\r\n                ...state,\r\n                appGlobalMessage: null\r\n            }\r\n        case actionTypes.ROSS_WEBSOCKET_CONNECTION_SUCCESS: {\r\n            return {\r\n                ...state,\r\n                isRosWebsocketConncted: true\r\n            }\r\n        }\r\n        case actionTypes.ROSS_WEBSOCKET_CONNECTION_FAILED: {\r\n            return {\r\n                ...state,\r\n                isRosWebsocketConncted: false\r\n            }\r\n        }\r\n        case actionTypes.ROSS_WEBSOCKET_CONNECTION_CLOSED: {\r\n            return {\r\n                ...state,\r\n                isRosWebsocketConncted: false\r\n            }\r\n        }\r\n        case actionTypes.SHOW_CONTEXT_MENU: {\r\n            const contextMenu = {\r\n                x: action.payload.x,\r\n                y: action.payload.y,\r\n                options: action.payload.options,\r\n                items: action.payload.items\r\n            };\r\n            return {\r\n                ...state,\r\n                contextMenu\r\n            }\r\n        }\r\n        case actionTypes.CLOSE_CONTEXT_MENU: {\r\n            return {\r\n                ...state,\r\n                contextMenu: null\r\n            }\r\n        }\r\n        case actionTypes.SHOW_POPUP: {\r\n            return {\r\n                ...state,\r\n                popupDetails: { ...action.payload }\r\n            }\r\n        }\r\n        case actionTypes.HIDE_POPUP: {\r\n            return {\r\n                ...state,\r\n                popupDetails: null\r\n            }\r\n        }\r\n        case actionTypes.SELECT_POINT_FROM_MAP: {\r\n            let popupDetails = {...state.popupDetails};\r\n            popupDetails.modalChildProps.pointFromMap = action.payload.pointFromMap;\r\n            return {\r\n                ...state,\r\n                popupDetails\r\n            }\r\n        }\r\n        case actionTypes.TOGGLE_POINT_SELECTION_MODE: {\r\n            return {\r\n                ...state,\r\n                isPointSelectionMode: !state.isPointSelectionMode\r\n            }\r\n        }\r\n        case actionTypes.IMAGE_SENT_TO_DRONE: {\r\n            return {\r\n                ...state,\r\n                imageSentToDroneData: action.payload\r\n            }\r\n        }\r\n        case actionTypes.TOGGLE_MISSION_PLANNER_SCREEN: {\r\n            return {\r\n                ...state,\r\n                isMissionPlanScreenHidden: !state.isMissionPlanScreenHidden\r\n            }\r\n        }\r\n\r\n        \r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\nexport default layoutReducer;","C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\plannerReducer.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\reducers\\mapReducer.js",["216"],"import actionTypes from '../actions/actionTypes';\r\nimport * as geoCalculations from '../../utils/geoCalculations';\r\nimport externalConfig from '../../ExternalConfigurationHandler';\r\nimport config from '../../config';\r\nconst initialState = {\r\n    isMapCoreSDKLoaded: false,\r\n    mapToShow: null,\r\n    enemyPositionOffset: null,\r\n    dronesPositions: {},\r\n    selectedDrone: null\r\n};\r\n\r\nconst mapReducer = (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case actionTypes.SET_MAPCORE_SDK_LOADED_FLAG:\r\n            return {\r\n                ...state,\r\n                isMapCoreSDKLoaded: true\r\n            }\r\n        case actionTypes.SET_MAP_TO_SHOW:\r\n            return {\r\n                ...state,\r\n                mapToShow: action.payload\r\n            }\r\n        case actionTypes.GET_DRONE_POSITION_OFFSET: {\r\n            let dronePosition = { ...state.dronesPositions[action.payload.droneNumber] };\r\n            dronePosition.angle = geoCalculations.quaternionToYaw(action.payload.droneRotationQuaternion);\r\n            dronePosition.offset = action.payload.dronePositionOffset;\r\n            return {\r\n                ...state,\r\n                dronesPositions: {\r\n                    ...state.dronesPositions,\r\n                    [action.payload.droneNumber]: dronePosition\r\n                },\r\n            }\r\n        }\r\n        case actionTypes.GET_ENEMY_POSITION: {\r\n            let range = action.payload.range;\r\n            let droneNumber = action.payload.droneNumber;\r\n            const droneAngleRadians = (360 - state.dronesPositions[droneNumber].angle) * Math.PI / 180;\r\n\r\n            let enemyOffsetFromDrone = {\r\n                x: range * Math.cos(droneAngleRadians) ,\r\n                y: range * Math.sin(droneAngleRadians) ,\r\n                z: 0\r\n            }\r\n            let enemyOffset = geoCalculations.addCoordinates(state.dronesPositions[droneNumber].offset, enemyOffsetFromDrone);\r\n\r\n            let dronePosition = { ...state.dronesPositions[action.payload.droneNumber] };\r\n\r\n            if (dronePosition.enemyOffsets &&\r\n                dronePosition.enemyOffsets.some(offset => (geoCalculations.calculateDistanceBetween2Points(offset, enemyOffset) < config.MIN_ENEMY_RADIUS))) {\r\n                //enemy already exists in this radius\r\n                return state;\r\n            }\r\n            dronePosition.enemyOffsets = dronePosition.enemyOffsets ? [...dronePosition.enemyOffsets, enemyOffset] : [enemyOffset];\r\n\r\n            return {\r\n                ...state,\r\n                dronesPositions: {\r\n                    ...state.dronesPositions,\r\n                    [action.payload.droneNumber]: dronePosition\r\n                },\r\n            }\r\n        }\r\n        case actionTypes.SELECT_DRONE: {\r\n            return {\r\n                ...state,\r\n                selectedDrone: action.payload.droneNumber\r\n            }\r\n        }\r\n        case actionTypes.DELETE_DRONE_POSITION: {\r\n            return {\r\n                ...state,\r\n                dronesPositions: {\r\n                    ...state.dronesPositions,\r\n                    [state.selectedDrone]: null\r\n                },\r\n            }\r\n        }\r\n        case actionTypes.SAVE_ORIGIN_COORDINATE: {\r\n            let droneData = { ...state.dronesPositions[state.selectedDrone] };\r\n            droneData.workingOrigin = {\r\n                coordinate: action.payload.coordinate,\r\n                angle: action.payload.angle\r\n            };\r\n\r\n            return {\r\n                ...state,\r\n                dronesPositions: {\r\n                    ...state.dronesPositions,\r\n                    [state.selectedDrone]: droneData\r\n                },\r\n            }\r\n        }\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n\r\nexport default mapReducer;","C:\\mapCoreDrones\\wasp\\src\\components\\Popup\\PopupChildren.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\FlightTelemetry\\FlightTelemetry.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Select\\reactSelectStyles.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\ActionButtons\\ActionButtons.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\MissionPlanStages\\MissionPlanStages.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\MapContainer\\MapContainer.js",["217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296"],"import React, { PureComponent, Component } from 'react';\r\nimport cn from './MapContainer.module.css';\r\nimport axios from 'axios';\r\nimport config from '../../config';\r\nimport { connect } from 'react-redux';\r\nimport externalConfig from '../../ExternalConfigurationHandler';\r\nimport actionTypes from '../../store/actions/actionTypes';\r\nimport actions from '../../store/actions';\r\nimport SwitchMapForm from '../SwitchMapForm/SwitchMapForm';\r\nimport * as geoCalculations from '../../utils/geoCalculations';\r\nimport { viewerStates } from '../../store/reducers/plannerReducer';\r\n\r\nclass SLayerGroup {\r\n    constructor(coordSystemString, bShowGeoInMetricProportion, bSetTerrainBoxByStaticLayerOnly, InitialScale2D) {\r\n        this.aLayerCreateStrings = [];\r\n        this.coordSystemString = coordSystemString;\r\n        this.bShowGeoInMetricProportion = bShowGeoInMetricProportion;\r\n        this.bSetTerrainBoxByStaticLayerOnly = bSetTerrainBoxByStaticLayerOnly;\r\n        this.InitialScale2D = InitialScale2D;\r\n    }\r\n}\r\n\r\nclass SViewportData {\r\n    constructor(_viewport, _editMode) {\r\n        this.viewport = _viewport;\r\n        this.editMode = _editMode;\r\n        this.canvas = _viewport.GetWindowHandle();\r\n        let aViewportTerrains = _viewport.GetTerrains();\r\n        this.aLayers = (aViewportTerrains != null && aViewportTerrains.length > 0 ? aViewportTerrains[0].GetLayers() : null);\r\n        this.terrainBox = null;\r\n        this.terrainCenter = null;\r\n        this.rotationCenter = null;\r\n        this.bCameraPositionSet = false;\r\n        this.bSetTerrainBoxByStaticLayerOnly = false;\r\n    }\r\n}\r\n\r\nclass MapContainer extends PureComponent {\r\n\r\n    state = {\r\n        mapLayerGroups: new Map(),\r\n        lastTerrainConfiguration: null,\r\n        lastViewportConfiguration: null /*  2D/3D, 3D/2D, 2D, 3D */,\r\n        bSameCanvas: true,\r\n        isDTMClicked: false,\r\n        is3DClicked: false,\r\n        isSwitchMapFormOpen: false,\r\n        isOriginSelectionMode: false\r\n    }\r\n\r\n    mapTerrains = new Map;\r\n    device = null\r\n    //callbacks classes from mapCore\r\n    CLayerReadCallback;\r\n    CCameraUpdateCallback;\r\n    CAsyncQueryCallback;\r\n    viewportData = null;\r\n    uCameraUpdateCounter = 0;\r\n    aLastTerrainLayers = [];\r\n    lastCoordSys = null;\r\n    overlayManager = null;\r\n    activeViewport = -1;\r\n    aViewports = [];\r\n    viewport;\r\n    editMode;\r\n    lastRenderTime = (new Date).getTime();\r\n    lastMemUsageLogTime = (new Date).getTime();\r\n    uMemUsageLoggingFrequency = 0;\r\n    nMousePrevX = 0;\r\n    nMousePrevY = 0;\r\n    mouseDownButtons = 0;\r\n    bEdit = false;\r\n    layerCallback = null;\r\n    requestAnimationFrameId = -1;\r\n    aPositions = [];\r\n    aObjects = [];\r\n    lineScheme = null;\r\n    textScheme = null;\r\n\r\n    TempOriginAngle = 0;\r\n\r\n    MapObjects = {};\r\n\r\n    EnemyPositions = [];\r\n\r\n    SelectedMissionPointObject = null;\r\n    MissionPointsObjects = [];\r\n\r\n    componentDidMount() {\r\n        window.addEventListener('resize', this.resizeCanvases);\r\n        //this.callGetCapabilitiesApi();\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        //Todo -> un-register events and all the map core object\r\n        window.removeEventListener('resize', this.resizeCanvases);\r\n        cancelAnimationFrame(this.requestAnimationFrameId);\r\n        this.requestAnimationFrameId = null;\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        // first time map load or channing from map a to map b\r\n        if ((!prevProps.isMapCoreSDKLoaded && this.props.isMapCoreSDKLoaded) ||\r\n            (this.props.isMapCoreSDKLoaded && prevProps.mapToShow !== this.props.mapToShow)) {\r\n            this.openMap(this.props.mapToShow.groupName, false);\r\n            console.log('mapCore version: ', window.MapCore.IMcMapDevice.GetVersion());\r\n            this.CreateMapcoreObjects();\r\n            this.RemoveDroneData();\r\n        }\r\n\r\n        const dronesPositions = this.props.dronesPositions;\r\n        if (dronesPositions &&\r\n            (prevProps.dronesPositions != dronesPositions)) {\r\n            Object.keys(dronesPositions).forEach(droneNumber => {\r\n                if (dronesPositions[droneNumber] && dronesPositions[droneNumber].offset) {\r\n                    if (!prevProps.dronesPositions[droneNumber] ||  // first position\r\n                        (dronesPositions[droneNumber].offset != prevProps.dronesPositions[droneNumber].offset)) {  // cahnged position\r\n                        this.MoveDrone(droneNumber);\r\n                    }\r\n                    else if (dronesPositions[droneNumber].enemyOffsets != prevProps.dronesPositions[droneNumber].enemyOffsets) {\r\n                        this.UpdateEnemyPosition(droneNumber);\r\n                    }\r\n                }\r\n            })\r\n        }\r\n\r\n        if (this.props.isPointSelectionMode && !prevProps.isPointSelectionMode && !this.SelectedMissionPointObject) {\r\n            this.selectMissionPointFromMap();\r\n        }\r\n\r\n        if (this.props.selectedDrone != prevProps.selectedDrone) {\r\n            Object.keys(dronesPositions).forEach(droneNumber => {\r\n                if (this.MapObjects[droneNumber] && this.MapObjects[droneNumber].WorkingOrigin) {\r\n                    this.SetOpacityToDroneObjects(droneNumber, droneNumber == this.props.selectedDrone);\r\n                }\r\n            })\r\n\r\n        }\r\n\r\n        const { viewerState, savedMissionPlan, draftMissionStages } = this.props;\r\n\r\n        if (viewerState == viewerStates.savedMission &&\r\n            (viewerState != prevProps.viewerState || savedMissionPlan != prevProps.savedMissionPlan)) {\r\n            this.DrawMissionWayPoints(savedMissionPlan);\r\n        }\r\n        else if (viewerState == viewerStates.draft &&\r\n            (viewerState != prevProps.viewerState || draftMissionStages != prevProps.draftMissionStages)) {\r\n            this.DrawMissionWayPoints(draftMissionStages);\r\n        }\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    RemoveDroneData = (droneNumber) => {\r\n        if (this.MapObjects[droneNumber]) {\r\n            if (this.MapObjects[droneNumber].WorkingOrigin) {\r\n                this.MapObjects[droneNumber].WorkingOrigin.Remove();\r\n                this.MapObjects[droneNumber].WorkingOrigin = null;\r\n                this.props.deleteDronePosition();\r\n            }\r\n            if (this.MapObjects[droneNumber].Drone) {\r\n                this.MapObjects[droneNumber].Drone.Remove();\r\n                this.MapObjects[droneNumber].Drone = null;\r\n            }\r\n            if (this.MapObjects[droneNumber].Route) {\r\n                this.MapObjects[droneNumber].Route.Remove();\r\n                this.MapObjects[droneNumber].Route = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    CreateMapcoreObjects = () => {\r\n        this.LoadMapcoreObject(\"lineScheme\", \"LineScheme.json\");\r\n        this.LoadMapcoreObject(\"ScreenPictureClick\", \"ScreenPictureClick.json\");\r\n        this.LoadMapcoreObject(\"ScreenPictureDrone\", \"ScreenPictureDrone.json\");\r\n        this.LoadMapcoreObject(\"WorldPictureScheme\", \"WorldPicture3.json\");\r\n        this.LoadMapcoreObject(\"textScheme\", \"TextScheme.m\");\r\n    }\r\n\r\n    LoadMapcoreObject(objectName, schemeName) {\r\n        if (this[objectName] == null) {\r\n            this.FetchFileToByteArray(\"http:ObjectWorld/Schemes/\" + schemeName).then(\r\n                bytes => {\r\n                    if (bytes != null) {\r\n                        this[objectName] = this.overlayManager.LoadObjectSchemes(bytes)[0];\r\n                        this[objectName].AddRef();\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    StartEditMode = (ID) => {\r\n        if (this.ScreenPictureClick != null) {\r\n            // find item marked for editing (e.g. by setting ID = 1000)\r\n            let pItem = this.ScreenPictureClick.GetNodeByID(1000);\r\n            if (pItem == null) {\r\n                alert(\"There is no item marked for editing (with ID = 1000)\");\r\n                return null;\r\n            }\r\n            // create object\r\n            let pObject = window.MapCore.IMcObject.Create(this.overlay, this.ScreenPictureClick);\r\n            // ID !== null && ID !== undefined && pObject.SetID(ID);\r\n            // start EditMode action\r\n            this.editMode.StartInitObject(pObject, pItem);\r\n\r\n            return pObject;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n\r\n\r\n    DrawMissionWayPoints = (missionStages) => {\r\n        let index = 1;\r\n        this.MissionPointsObjects.forEach(wayPoint => wayPoint.Remove());\r\n        this.MissionPointsObjects = [];\r\n        for (const stage of missionStages) {\r\n\r\n            const { rossService } = stage.selectedStageType;\r\n\r\n            if (rossService && rossService == 'addMissionWP') {\r\n                const [x, y, z] = stage.stageParamsInput.split(',');\r\n                let wayPoint = window.MapCore.IMcObject.Create(this.overlay, this.ScreenPictureClick, [{ x: parseFloat(x), y: parseFloat(y), z: parseFloat(z) }]);\r\n                wayPoint.SetTextureProperty(1, window.MapCore.IMcImageFileTexture.Create(window.MapCore.SMcFileSource(\"http:ObjectWorld/Images/pinPoint.png\", false), false));\r\n                if (this.props.viewerState == viewerStates.draft) {\r\n                    wayPoint.SetBColorProperty(3, new window.MapCore.SMcBColor(255, 255, 255, 100));\r\n                }\r\n                this.MissionPointsObjects.push(wayPoint);\r\n\r\n                index++;\r\n            }\r\n        }\r\n    }\r\n\r\n    selectMissionPointFromMap = () => {\r\n        this.SelectedMissionPointObject = this.StartEditMode();\r\n    }\r\n\r\n    SetWorkingOrigin = () => {\r\n        this.RemoveDroneData(this.props.selectedDrone);\r\n        if (!this.MapObjects[this.props.selectedDrone]) {\r\n            this.MapObjects[this.props.selectedDrone] = {\r\n                WorkingOrigin: null,\r\n                Drone: null,\r\n                Route: null\r\n            };\r\n        }\r\n        this.MapObjects[this.props.selectedDrone].WorkingOrigin = this.StartEditMode();\r\n\r\n        this.MapObjects[this.props.selectedDrone].WorkingOrigin.SetTextureProperty(1, window.MapCore.IMcImageFileTexture.Create(window.MapCore.SMcFileSource(\"http:ObjectWorld/Images/location4.png\", false), false));\r\n        this.MapObjects[this.props.selectedDrone].WorkingOrigin.SetDrawPriority(1);\r\n        this.setState({ isOriginSelectionMode: true });\r\n    }\r\n\r\n\r\n    DrawDroneMapImage = () => {\r\n        const { DRONES_DATA } = externalConfig.getConfiguration();\r\n        const ip = `//${DRONES_DATA.segment}.${this.props.selectedDrone}:${DRONES_DATA.port}`;\r\n        const mapImageStream = `${ip}${config.urls.mapImageStream}`;\r\n\r\n        if (this.DroneMapImage) {\r\n            this.DroneMapImage.GetTextureProperty(1).SetImageFile(window.MapCore.SMcFileSource(mapImageStream, true));\r\n        }\r\n        else {\r\n            this.DroneMapImage = window.MapCore.IMcObject.Create(this.overlay, this.WorldPictureScheme, [this.MapObjects[this.props.selectedDrone].WorkingOrigin.GetLocationPoints()[0]]);\r\n            this.DroneMapImage.SetTextureProperty(1, window.MapCore.IMcImageFileTexture.Create(window.MapCore.SMcFileSource(mapImageStream, true), false));\r\n            this.DroneMapImage.SetBColorProperty(4, new window.MapCore.SMcBColor(255, 255, 255, 100));\r\n        }\r\n\r\n      //  setTimeout(this.DrawDroneMapImage, 3000);\r\n    }\r\n\r\n\r\n    UpdateEnemyPosition(droneNumber) {\r\n        let dronePosition = this.props.dronesPositions[droneNumber];\r\n        const coordinateWithOffset = geoCalculations.getMapCoordinate(dronePosition.workingOrigin, dronePosition.enemyOffsets[dronePosition.enemyOffsets.length - 1]);\r\n        this.EnemyObject = window.MapCore.IMcObject.Create(this.overlay, this.ScreenPictureClick, [coordinateWithOffset]);\r\n        this.EnemyObject.SetTextureProperty(1, window.MapCore.IMcImageFileTexture.Create(window.MapCore.SMcFileSource(\"http:ObjectWorld/Images/enemy.png\", false), false));\r\n        this.EnemyObject.SetFloatProperty(2, 0.5);\r\n    }\r\n\r\n    DrawDroneObjects(droneNumber) {\r\n        const droneList = externalConfig.getConfiguration().DRONES_DATA.dronesList; \r\n        const originCoordinate = this.MapObjects[droneNumber].WorkingOrigin.GetLocationPoints()[0];\r\n        this.MapObjects[droneNumber].Drone = window.MapCore.IMcObject.Create(this.overlay, this.ScreenPictureDrone, [originCoordinate]);\r\n        this.MapObjects[droneNumber].Drone.SetTextureProperty(1, window.MapCore.IMcImageFileTexture.Create(window.MapCore.SMcFileSource(`http:ObjectWorld/Images/droneNew${droneList.indexOf(droneNumber)+1}.png`, false), false));\r\n        this.MapObjects[droneNumber].Drone.SetFloatProperty(2, 0.9);\r\n        this.MapObjects[droneNumber].Drone.SetFloatProperty(4, this.props.dronesPositions[droneNumber].workingOrigin.angle);\r\n        this.MapObjects[droneNumber].Drone.SetDrawPriority(2);\r\n\r\n        this.MapObjects[droneNumber].Route = window.MapCore.IMcObject.Create(this.overlay, this.lineScheme, [originCoordinate]);\r\n        this.MapObjects[droneNumber].Route.SetFloatProperty(2, 3);\r\n\r\n        let lineColor = new window.MapCore.SMcBColor(44, 229, 246, 255);\r\n        if(droneList.indexOf(this.props.selectedDrone) == 1){\r\n            lineColor = new window.MapCore.SMcBColor(0, 128, 0, 255);\r\n        }\r\n        else if (droneList.indexOf(this.props.selectedDrone) == 2){\r\n            lineColor = new window.MapCore.SMcBColor(255,165,0, 255)\r\n        }\r\n\r\n        this.MapObjects[droneNumber].Route.SetBColorProperty(1, lineColor);\r\n\r\n\r\n        this.SetOpacityToDroneObjects(droneNumber, droneNumber == this.props.selectedDrone);\r\n\r\n    }\r\n\r\n    SetOpacityToDroneObjects = (droneNumber, isSelected) => {\r\n        this.MapObjects[droneNumber].WorkingOrigin && this.MapObjects[droneNumber].WorkingOrigin.SetBColorProperty(3, new window.MapCore.SMcBColor(255, 255, 255, isSelected ? 255 : 100));\r\n        this.MapObjects[droneNumber].Drone && this.MapObjects[droneNumber].Drone.SetBColorProperty(3, new window.MapCore.SMcBColor(255, 255, 255, isSelected ? 255 : 150));\r\n       // this.MapObjects[droneNumber].Route && this.MapObjects[droneNumber].Route.SetBColorProperty(1, new window.MapCore.SMcBColor(255, 255, 255, isSelected ? 255 : 100));\r\n    }\r\n\r\n    MoveDrone = (droneNumber) => {\r\n        if (!this.MapObjects[droneNumber] || !this.MapObjects[droneNumber].WorkingOrigin) {\r\n            console.log(\"No Working Origin Selected!!\");\r\n            return;\r\n        }\r\n\r\n        if (!this.MapObjects[droneNumber].Drone || !this.MapObjects[droneNumber].Route) {\r\n            this.DrawDroneObjects(droneNumber);\r\n            return;\r\n        }\r\n\r\n        const coordinateWithOffset = geoCalculations.getMapCoordinate(this.props.dronesPositions[droneNumber].workingOrigin, this.props.dronesPositions[droneNumber].offset);\r\n        let routeCoordinates = this.MapObjects[droneNumber].Route.GetLocationPoints();\r\n        if (routeCoordinates.length > 0) {\r\n            let prevCoordinate = routeCoordinates[routeCoordinates.length - 1];\r\n            if (geoCalculations.calculateDistanceBetween2Points(prevCoordinate, coordinateWithOffset) < config.MIN_DRONE_DISTANCE_MOVE) { //too small distance , not importent\r\n                return;\r\n            }\r\n        }\r\n        this.MapObjects[droneNumber].Drone.UpdateLocationPoints([coordinateWithOffset]);\r\n        this.MapObjects[droneNumber].Drone.SetFloatProperty(4, this.props.dronesPositions[droneNumber].workingOrigin.angle + this.props.dronesPositions[droneNumber].angle);\r\n\r\n\r\n        routeCoordinates.push(coordinateWithOffset);\r\n        this.MapObjects[droneNumber].Route.SetLocationPoints(routeCoordinates);\r\n        this.SetOpacityToDroneObjects(droneNumber, droneNumber == this.props.selectedDrone);\r\n    }\r\n\r\n\r\n    // function fetching a file from server to byte-array\r\n    FetchFileToByteArray(uri) {\r\n        return fetch(uri)\r\n            .then(response => (response.ok ? response.arrayBuffer() : null))\r\n            .then(\r\n                arrayBuffer => {\r\n                    if (arrayBuffer != null) {\r\n                        return new Uint8Array(arrayBuffer);\r\n                    }\r\n                    else {\r\n                        alert(\"Cannot fetch \" + uri);\r\n                        return null;\r\n                    }\r\n                },\r\n                error => {\r\n                    alert(\"Network error in fetching \" + uri);\r\n                    return null;\r\n                }\r\n            );\r\n    }\r\n\r\n    OnEditClickWorkingOrigin = (droneNumber) => {\r\n\r\n        if (this.MapObjects[droneNumber].WorkingOrigin && this.MapObjects[droneNumber].WorkingOrigin.GetLocationPoints().length > 0) {\r\n            //    this.WorkingOrigin.SetFloatProperty(2, 1);\r\n            const originCoordinate = geoCalculations.roundCoordinate(this.MapObjects[droneNumber].WorkingOrigin.GetLocationPoints()[0], config.COORDINATE_DECIMALS_PRECISION);\r\n            this.props.saveOriginCoordinate(originCoordinate, 360 - this.TempOriginAngle);\r\n        }\r\n        this.setState({ isOriginSelectionMode: false });\r\n    }\r\n    OnEditClickMissionPoint = () => {\r\n        if (this.SelectedMissionPointObject && this.SelectedMissionPointObject.GetLocationPoints().length > 0) {\r\n            this.props.togglePointSelectionMode();\r\n            //this.SelectedMissionPointObject.SetFloatProperty(2, 0.8);\r\n            let locationPoints = this.SelectedMissionPointObject.GetLocationPoints()[0];\r\n            locationPoints.z = config.DEFAULT_MISSION_POINT_HEIGHT;\r\n            this.props.selectPointFromMap(geoCalculations.roundCoordinate(locationPoints, config.COORDINATE_DECIMALS_PRECISION));\r\n            this.SelectedMissionPointObject.Remove();\r\n        }\r\n\r\n        this.SelectedMissionPointObject = null;\r\n    }\r\n\r\n\r\n    parseLayersConfiguration(jsonLayerGroups) {\r\n        try {\r\n            for (let jsonGroup of jsonLayerGroups) {\r\n                // coordinate system creation string: MapCore.IMcGridCoordSystemGeographic.Create(MapCore.IMcGridCoordinateSystem.EDatumType.EDT_WGS84) etc.\r\n                let coordSystemString = \"MapCore.\" + jsonGroup.coordSystemType + \".Create(\" + jsonGroup.coordSystemParams + \")\";\r\n                let layerGroup = new SLayerGroup(coordSystemString, jsonGroup.showGeoInMetricProportion, jsonGroup.centerByStaticObjectsLayerOnly, jsonGroup.InitialScale2D);\r\n\r\n                if (jsonGroup.layers) {\r\n                    for (let layer of jsonGroup.layers) {\r\n                        let layerCreateString = null;\r\n                        const protocol = window.location.protocol;\r\n                        switch (layer.type) {\r\n                            case \"WMSRaster\":\r\n                                // WMS raster layer creation string: CreateWMSRasterLayer('http://wmtsserver/wmts?request=GetCapabilities', 'layer', 'EPSG:4326', 'jpeg') etc.\r\n                                layerCreateString = \"Create\" + layer.type + \"Layer('\" + layer.path + \"'\" + (layer.params ? \", \" + layer.params : \"\") + \")\";\r\n                                break;\r\n                            case \"IMcNativeRasterMapLayer\":\r\n                                layerCreateString = \"MapCore.IMcNativeRasterMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"MapCore.UINT_MAX, false, 0, false\") + \", this.layerCallback)\";\r\n                                break;\r\n                            case \"IMcNativeDtmMapLayer\":\r\n                                layerCreateString = \"MapCore.IMcNativeDtmMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"0\") + \", this.layerCallback)\";\r\n                                break;\r\n                            case \"IMcNativeVectorMapLayer\":\r\n                                layerCreateString = \"MapCore.IMcNativeVectorMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"\") + \"this.layerCallback)\";\r\n                                break;\r\n                            case \"IMcNative3DModelMapLayer\":\r\n                                layerCreateString = \"MapCore.IMcNative3DModelMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"0\") + \", this.layerCallback)\";\r\n                                break;\r\n                            case \"IMcNativeVector3DExtrusionMapLayer\":\r\n                                layerCreateString = \"MapCore.IMcNativeVector3DExtrusionMapLayer.Create('\" + protocol + layer.path + \"', \" + (layer.params ? layer.params : \"0, 10\") + \", this.layerCallback)\";\r\n                                break;\r\n                            default:\r\n                                alert(\"Invalid type of server layer\");\r\n                                return;\r\n                        }\r\n                        layerGroup.aLayerCreateStrings.push(layerCreateString);\r\n                    }\r\n                }\r\n                if (jsonGroup.groupName != undefined) {\r\n\r\n                    this.setState({ mapLayerGroups: new Map(this.state.mapLayerGroups.set(jsonGroup.groupName, layerGroup)) });\r\n\r\n                }\r\n                // we should not get here...\r\n                else if (jsonGroup.wmtsServerURL != undefined) {\r\n\r\n                    // layerGroup.wmtsServerURL = jsonGroup.wmtsServerURL;\r\n                    // if (jsonGroup.tileMatrixSetFilter != undefined) {\r\n\r\n                    //     layerGroup.tileMatrixSetFilter = jsonGroup.tileMatrixSetFilter;\r\n                    // }\r\n                    // aWmtsAdditionalLayerGroups.push(layerGroup);\r\n                }\r\n            }\r\n        }\r\n        catch (e) {\r\n            alert(\"Invalid configuration JSON file\");\r\n        }\r\n    }\r\n\r\n    parseCapabilitiesXML(xmlDoc, capabilitiesURL, bMapCoreLayerServer = true, wmtsAdditionalLayerGroup) {\r\n        class CXmlNode {\r\n            constructor(node) {\r\n                this.node = node;\r\n            }\r\n            GetFirstChild(tagName) {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                for (let child of children) {\r\n                    if (child.parentNode == this.node) {\r\n                        return new CXmlNode(child);\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            GetFirstChildText(tagName) {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                for (let child of children) {\r\n                    if (child.parentNode == this.node) {\r\n                        return child.textContent;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            GetFirstChildAttribute(tagName, attributeName) {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                for (let child of children) {\r\n                    if (child.parentNode == this.node) {\r\n                        return child.attributes.getNamedItem(attributeName).value;\r\n                    }\r\n                }\r\n                return null;\r\n            }\r\n            GetChildren(tagName) {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                let aNodes = [];\r\n                for (let child of children) {\r\n                    if (child.parentNode == this.node) {\r\n                        aNodes.push(new CXmlNode(child));\r\n                    }\r\n                }\r\n                return aNodes;\r\n            }\r\n            GetChildrenTexts(tagName) {\r\n                let children = this.node.getElementsByTagName(tagName);\r\n                let aTexts = [];\r\n                for (let child of children) {\r\n                    if (child.parentNode == this.node) {\r\n                        aTexts.push(child.textContent);\r\n                    }\r\n                }\r\n                return aTexts;\r\n            }\r\n        }\r\n\r\n        if (xmlDoc != null) {\r\n            try {\r\n                let capabilities = new CXmlNode(xmlDoc).GetFirstChild(\"Capabilities\");\r\n                let MapLayerServerURL = capabilities.GetFirstChildAttribute(\"ServiceMetadataURL\", \"xlink:href\");\r\n                if (MapLayerServerURL == null || MapLayerServerURL == \"\") {\r\n                    MapLayerServerURL = capabilitiesURL;\r\n                }\r\n                let lastSlashIndex = MapLayerServerURL.lastIndexOf(\"?\");\r\n                if (lastSlashIndex < 0) {\r\n                    lastSlashIndex = MapLayerServerURL.lastIndexOf(\"/\");\r\n                }\r\n                if (lastSlashIndex < 0) {\r\n                    alert(\"Invalid Capabilities file\");\r\n                    return;\r\n                }\r\n                let TrimmedMapLayerServerURL = MapLayerServerURL.substring(0, lastSlashIndex);\r\n\r\n                let contents = capabilities.GetFirstChild(\"Contents\");\r\n                let aTileMatrixSets = contents.GetChildren(\"TileMatrixSet\");\r\n                let mapTileMatrixSets = new Map();\r\n                for (let matrixSet of aTileMatrixSets) {\r\n                    let id = matrixSet.GetFirstChildText(\"ows:Identifier\");\r\n                    let crs = matrixSet.GetFirstChildText(\"ows:SupportedCRS\");\r\n                    if (id != null && crs != null) {\r\n                        mapTileMatrixSets.set(matrixSet.GetFirstChildText(\"ows:Identifier\"), { coordSystem: crs, tileMatrixSet: id });\r\n                    }\r\n                }\r\n\r\n                let aLayers = contents.GetChildren(\"Layer\");\r\n                for (let layer of aLayers) {\r\n                    // check here if its single layer preview. if yes put only this layer in the hashMap                    \r\n                    let layerID = layer.GetFirstChildText(\"ows:Identifier\");\r\n                    if (this.context.mapToPreview.type === config.nodesLevel.layer &&\r\n                        (this.context.mapToPreview.data.LayerId !== layerID && this.context.mapToPreview.dtmLayerId !== layerID))\r\n                        continue;\r\n\r\n                    let aFormats = layer.GetChildrenTexts(\"Format\");\r\n                    let aTileMatrixSetLinks = layer.GetChildren(\"TileMatrixSetLink\");\r\n                    if (aTileMatrixSetLinks.length == 0) {\r\n                        aTileMatrixSetLinks.push(null);\r\n                    }\r\n\r\n                    for (let tileMatrixSetLink of aTileMatrixSetLinks) {\r\n                        let coordSystem = null;\r\n                        let tileMatrixSet = null;\r\n                        if (tileMatrixSetLink != null) {\r\n                            let tileMatrixSetParams = mapTileMatrixSets.get(tileMatrixSetLink.GetFirstChildText(\"TileMatrixSet\"));\r\n                            coordSystem = tileMatrixSetParams.coordSystem;\r\n                            tileMatrixSet = tileMatrixSetParams.tileMatrixSet;\r\n                            if (wmtsAdditionalLayerGroup && wmtsAdditionalLayerGroup.tileMatrixSetFilter && tileMatrixSet != wmtsAdditionalLayerGroup.tileMatrixSetFilter) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        if (coordSystem == null) {\r\n                            let boundingBox = layer.GetFirstChild(\"ows:BoundingBox\");\r\n                            if (boundingBox) {\r\n                                coordSystem = boundingBox.GetFirstChildText(\"ows:crs\");\r\n                            }\r\n                        }\r\n                        let prefix = \"urn:ogc:def:crs:\";\r\n                        if (coordSystem.indexOf(prefix) == 0) {\r\n                            coordSystem = coordSystem.substring(prefix.length).replace(\"::\", \":\");\r\n                            let aGroups = [];\r\n                            if (bMapCoreLayerServer) {\r\n                                aGroups = layer.GetFirstChildText(\"Group\").split(\",\");\r\n                                for (let i = 0; i < aGroups.length; ++i) {\r\n                                    aGroups[i] = aGroups[i] + \" (server \" + coordSystem + \")\";\r\n                                }\r\n                            }\r\n                            else {\r\n                                let groupName = layer.GetFirstChildText(\"ows:Title\");\r\n                                if (groupName == null) {\r\n                                    groupName = layerID;\r\n                                }\r\n\r\n                                for (let i = 0; i < aFormats.length; ++i) {\r\n                                    aFormats[i] = aFormats[i].replace(\"image/\", \"\");\r\n                                    aGroups[i] = groupName + \" (WMTS \" + aFormats[i] + \" \" + tileMatrixSet + \")\";\r\n                                }\r\n                            }\r\n                            for (let i = 0; i < aGroups.length; ++i) {\r\n                                let group = aGroups[i];\r\n\r\n                                // coordinate system creation string: MapCore.IMcGridGeneric.Create('EPSG:4326') etc.\r\n                                let coordSystemString = \"MapCore.IMcGridGeneric.Create('\" + coordSystem + \"')\";\r\n                                let layerGroup = this.state.mapLayerGroups.get(group);\r\n                                if (layerGroup == undefined) {\r\n                                    layerGroup = new SLayerGroup(coordSystemString, true); // for MapCoreLayerServer only: bShowGeoInMetricProportion is true\r\n                                    this.setState({ mapLayerGroups: new Map(this.state.mapLayerGroups.set(group, layerGroup)) });\r\n                                }\r\n                                else if (coordSystemString != layerGroup.coordSystemString) {\r\n                                    alert(\"Layers' coordinate systems do not match\");\r\n                                    return;\r\n                                }\r\n                                let layerCreateString;\r\n                                if (bMapCoreLayerServer) {\r\n                                    layerCreateString = aFormats[0].replace(\"MapCore\", \"MapCore.IMcNative\").replace(\"DTM\", \"Dtm\") + \"MapLayer\" + \".Create('\" + TrimmedMapLayerServerURL + \"/\" + layerID + \"')\";\r\n                                    layerGroup.aLayerCreateStrings.push(layerCreateString);\r\n                                }\r\n                                else {\r\n                                    // WMTS raster layer creation string: CreateWMTSRasterLayer('http://wmtsserver/wmts?request=GetCapabilities', 'layer', 'EPSG:4326', 'jpeg') etc.\r\n                                    layerCreateString = \"CreateWMTSRasterLayer('\" + capabilitiesURL + \"', '\" + layerID + \"', '\" + tileMatrixSet + \"', '\" + aFormats[i] + \"')\";\r\n                                    layerGroup.aLayerCreateStrings.push(layerCreateString);\r\n                                    if (wmtsAdditionalLayerGroup) {\r\n                                        layerGroup.aLayerCreateStrings = layerGroup.aLayerCreateStrings.concat(wmtsAdditionalLayerGroup.aLayerCreateStrings);\r\n                                        layerGroup.bSetTerrainBoxByStaticLayerOnly = wmtsAdditionalLayerGroup.bSetTerrainBoxByStaticLayerOnly;\r\n                                        layerGroup.bShowGeoInMetricProportion = wmtsAdditionalLayerGroup.bShowGeoInMetricProportion;\r\n                                        layerGroup.InitialScale2D = wmtsAdditionalLayerGroup.InitialScale2D;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            catch (e) {\r\n                alert(\"Invalid Capabilities file\");\r\n            }\r\n        }\r\n    }\r\n\r\n    createCallbackClasses() {\r\n        this.CLayerReadCallback = window.MapCore.IMcMapLayer.IReadCallback.extend(\"IMcMapLayer.IReadCallback\", {\r\n            // mandatory\r\n            OnInitialized: function (pLayer, eStatus, strAdditionalDataString) {\r\n                if (eStatus == window.MapCore.IMcErrors.ECode.SUCCESS) {\r\n                    //this.trySetTerainBox();\r\n                    // if (pLayer.GetLayerType() ==  window.MapCore.IMcNativeStaticObjectsMapLayer.LAYER_TYPE && !pLayer.IsBuiltOfContoursExtrusion())\r\n                    // {\r\n                    //     pLayer.SetDisplayingItemsAttachedToTerrain(true);\r\n                    //     pLayer.SetDisplayingDtmVisualization(true);\r\n                    // }\r\n                }\r\n                else if (eStatus != window.MapCore.IMcErrors.ECode.NATIVE_SERVER_LAYER_NOT_VALID) {\r\n                    alert(\"Layer initialization: \" + window.MapCore.IMcErrors.ErrorCodeToString(eStatus) + \" (\" + strAdditionalDataString + \")\");\r\n                }\r\n            },\r\n            // mandatory\r\n            OnReadError: function (pLayer, eErrorCode, strAdditionalDataString) {\r\n                alert(\"Layer read error: \" + window.MapCore.IMcErrors.ErrorCodeToString(eErrorCode) + \" (\" + strAdditionalDataString + \")\");\r\n            },\r\n            // mandatory\r\n            OnNativeServerLayerNotValid: function (pLayer, bLayerVersionUpdated) {/*TBD*/ },\r\n            // optional, needed if to be deleted by MapCore when no longer used\r\n            // optional\r\n            OnRemoved(pLayer, eStatus, strAdditionalDataString) {\r\n                alert(\"Map layer has been removed\");\r\n            },\r\n\r\n            // optional\r\n            OnReplaced(pOldLayer, pNewLayer, eStatus, strAdditionalDataString) {\r\n                alert(\"Map layer has been replaced\");\r\n            },\r\n            Release: function () { this.delete(); },\r\n        });\r\n\r\n        this.CCameraUpdateCallback = window.MapCore.IMcMapViewport.ICameraUpdateCallback.extend(\"IMcMapViewport.ICameraUpdateCallback\", {\r\n            // mandatory\r\n            OnActiveCameraUpdated: function (pViewport) {\r\n                ++this.uCameraUpdateCounter\r\n            },\r\n            // optional\r\n            Release: function () {\r\n                this.delete()\r\n            }\r\n        });\r\n\r\n        this.CAsyncQueryCallback = window.MapCore.IMcSpatialQueries.IAsyncQueryCallback.extend(\"IMcSpatialQueries.IAsyncQueryCallback\", {\r\n            // optional\r\n            __construct: function (viewportData) {\r\n                this.__parent.__construct.call(this);\r\n                this.viewportData = viewportData;\r\n            },\r\n\r\n            OnTerrainHeightResults: function (bHeightFound, height, normal) {\r\n                if (this.viewportData.viewport != null) {\r\n                    this.viewportData.terrainCenter.z = height + 20;\r\n                    if (this.viewportData.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n                        this.viewportData.viewport.SetCameraPosition(this.viewportData.terrainCenter);\r\n                    }\r\n                }\r\n                this.delete();\r\n            },\r\n            OnTerrainHeightMatrixResults: function (uNumHorizontalPoints, uNumVerticalPoints, adHeightMatrix) { },\r\n            OnTerrainHeightsAlongLineResults: function (aPointsWithHeights, aSlopes, pSlopesData) { },\r\n            OnExtremeHeightPointsInPolygonResults: function (bPointsFound, pHighestPoint, pLowestPoint) { },\r\n            OnTerrainAnglesResults: function (dPitch, dRoll) { },\r\n\r\n            // OnRayIntersectionResults\r\n            OnLineOfSightResults: function (aPoints, dCrestClearanceAngle, dCrestClearanceDistance) { },\r\n            OnPointVisibilityResults: function (bIsTargetVisible, pdMinimalTargetHeightForVisibility, pdMinimalScouterHeightForVisibility) { },\r\n            OnAreaOfSightResults: function (pAreaOfSight, aLinesOfSight, pSeenPolygons, pUnseenPolygons, aSeenStaticObjects) { },\r\n            OnLocationFromTwoDistancesAndAzimuthResults: function (Target) { },\r\n\r\n            // mandatory\r\n            OnError: function (eErrorCode) {\r\n                alert('error ' + eErrorCode);\r\n                this.delete();\r\n            },\r\n        });\r\n\r\n        let CUserData = window.MapCore.IMcUserData.extend(\"IMcUserData\", {\r\n            // optional\r\n            __construct: function (bToBeDeleted) {\r\n                this.__parent.__construct.call(this);\r\n                this.bToBeDeleted = bToBeDeleted;\r\n                // ...\r\n            },\r\n\r\n            // optional\r\n            __destruct: function () {\r\n                this.__parent.__destruct.call(this);\r\n                // ...\r\n            },\r\n\r\n            // mandatory\r\n            Release: function () {\r\n                if (this.bToBeDeleted) {\r\n                    this.delete();\r\n                }\r\n            },\r\n\r\n            // optional\r\n            Clone: function () {\r\n                if (this.bToBeDeleted) {\r\n                    return new CUserData(this.bToBeDeleted);\r\n                }\r\n                return this;\r\n            },\r\n        });\r\n        this.layerCallback = new this.CLayerReadCallback();\r\n    }\r\n\r\n    renderMapContinuously = () => {\r\n        if (!this.requestAnimationFrameId) return;\r\n        this.trySetTerainBox();\r\n        let currtRenderTime = (new Date).getTime();\r\n\r\n        // render viewport(s)\r\n        if (!this.state.bSameCanvas) {\r\n            window.MapCore.IMcMapViewport.RenderAll();\r\n        } else if (this.viewport != null) {\r\n            this.viewport.Render();\r\n        }\r\n\r\n        // move objects if they exist\r\n        this.lastRenderTime = currtRenderTime;\r\n\r\n        // log memory usage and heap size\r\n        if (this.uMemUsageLoggingFrequency != 0 && currtRenderTime >= this.lastMemUsageLogTime + this.uMemUsageLoggingFrequency * 1000) {\r\n            let usage = window.MapCore.IMcMapDevice.GetMaxMemoryUsage();\r\n            console.log(\"Max mem = \" + window.MapCore.IMcMapDevice.GetMaxMemoryUsage().toLocaleString() + \", heap = \" + window.MapCore.IMcMapDevice.GetHeapSize().toLocaleString() + \" B\");\r\n            this.lastMemUsageLogTime = currtRenderTime;\r\n        }\r\n\r\n        // ask the browser to render again\r\n        this.requestAnimationFrameId = requestAnimationFrame(this.renderMapContinuously);\r\n    }\r\n\r\n    trySetTerainBox = () => {\r\n        for (let j = 0; j < this.aViewports.length; j++) {\r\n            if (this.aViewports[j].terrainBox == null) {\r\n                let aViewportLayers = this.aViewports[j].aLayers;\r\n                if (aViewportLayers.length != 0) {\r\n                    this.aViewports[j].terrainBox = new window.MapCore.SMcBox(-window.MapCore.DBL_MAX, -window.MapCore.DBL_MAX, 0, window.MapCore.DBL_MAX, window.MapCore.DBL_MAX, 0);\r\n                    for (let i = 0; i < aViewportLayers.length; ++i) {\r\n                        if (this.aViewports[j].bSetTerrainBoxByStaticLayerOnly && aViewportLayers[i].GetLayerType() != window.MapCore.IMcNativeStaticObjectsMapLayer.LAYER_TYPE) {\r\n                            continue;\r\n                        }\r\n\r\n                        if (!aViewportLayers[i].IsInitialized()) {\r\n                            this.aViewports[j].terrainBox = null;\r\n                            return;\r\n                        }\r\n\r\n                        let layerBox = aViewportLayers[i].GetBoundingBox();\r\n                        if (layerBox.MinVertex.x > this.aViewports[j].terrainBox.MinVertex.x) {\r\n                            this.aViewports[j].terrainBox.MinVertex.x = layerBox.MinVertex.x;\r\n                        }\r\n                        if (layerBox.MaxVertex.x < this.aViewports[j].terrainBox.MaxVertex.x) {\r\n                            this.aViewports[j].terrainBox.MaxVertex.x = layerBox.MaxVertex.x;\r\n                        }\r\n                        if (layerBox.MinVertex.y > this.aViewports[j].terrainBox.MinVertex.y) {\r\n                            this.aViewports[j].terrainBox.MinVertex.y = layerBox.MinVertex.y;\r\n                        }\r\n                        if (layerBox.MaxVertex.y < this.aViewports[j].terrainBox.MaxVertex.y) {\r\n                            this.aViewports[j].terrainBox.MaxVertex.y = layerBox.MaxVertex.y;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    this.aViewports[j].terrainBox = new window.MapCore.SMcBox(0, 0, 0, 0, 0, 0);\r\n                }\r\n\r\n                this.aViewports[j].terrainCenter = window.MapCore.SMcVector3D((this.aViewports[j].terrainBox.MinVertex.x + this.aViewports[j].terrainBox.MaxVertex.x) / 2, (this.aViewports[j].terrainBox.MinVertex.y + this.aViewports[j].terrainBox.MaxVertex.y) / 2, 0);\r\n                this.aViewports[j].terrainCenter.z = 10000;\r\n            }\r\n\r\n            if (!this.aViewports[j].bCameraPositionSet) {\r\n                if (this.aViewports[j].viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_2D) {\r\n                    this.aViewports[j].viewport.SetCameraPosition(this.aViewports[j].terrainCenter);\r\n                    this.aViewports[j].bCameraPositionSet = true;\r\n                }\r\n                else // 3D\r\n                {\r\n                    let height = {};\r\n                    this.aViewports[j].terrainCenter.z = 100;\r\n                    this.aViewports[j].viewport.SetCameraPosition(this.aViewports[j].terrainCenter);\r\n                    let params = new window.MapCore.IMcSpatialQueries.SQueryParams();\r\n                    params.eTerrainPrecision = window.MapCore.IMcSpatialQueries.EQueryPrecision.EQP_HIGH;\r\n                    this.aViewports[j].bCameraPositionSet = true;\r\n                    params.pAsyncQueryCallback = new this.CAsyncQueryCallback(this.aViewports[j]);\r\n                    this.aViewports[j].viewport.GetTerrainHeight(this.aViewports[j].terrainCenter, height, null, params); // async, wait for OnTerrainHeightResults()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    resizeCanvases = () => {\r\n        if (this.aViewports.length == 0) {\r\n            return;\r\n        }\r\n\r\n        let CanvasesInRow, CanvasesInColumn;\r\n        if (!this.state.bSameCanvas) {\r\n            CanvasesInRow = Math.ceil(Math.sqrt(this.aViewports.length));\r\n            CanvasesInColumn = Math.ceil(this.aViewports.length / CanvasesInRow);\r\n        }\r\n        else {\r\n            CanvasesInRow = 1;\r\n            CanvasesInColumn = 1;\r\n        }\r\n        //todo: use this instead: document.getElementById('id').getBoundingClientRect()\r\n        //    let width =  (window.innerWidth - 40) / CanvasesInRow - 10;\r\n        //    let height = (window.innerHeight - 80) / CanvasesInColumn - 15;\r\n        let width = document.getElementById('canvasesContainer').getBoundingClientRect().width;\r\n        let height = document.getElementById('canvasesContainer').getBoundingClientRect().height;\r\n\r\n        for (let i = 0; i < this.aViewports.length; i++) {\r\n            this.aViewports[i].canvas.width = width;\r\n            this.aViewports[i].canvas.height = height;\r\n            this.aViewports[i].viewport.ViewportResized();\r\n        }\r\n    }\r\n\r\n    calcMinMaxHeights() {\r\n        let minHeight = 0;\r\n        let maxHeight = 700;\r\n        let fp = this.viewport.GetCameraFootprint();\r\n\r\n        if (fp.bUpperLeftFound && fp.bUpperRightFound && fp.bLowerRightFound && fp.bLowerLeftFound) {\r\n            let minPoint = {}, maxPoint = {};\r\n            if (this.viewport.GetExtremeHeightPointsInPolygon([fp.UpperLeft, fp.UpperRight, fp.LowerRight, fp.LowerLeft], maxPoint, minPoint)) {\r\n                minHeight = minPoint.Value.z;\r\n                maxHeight = maxPoint.Value.z;\r\n            }\r\n        }\r\n        return { minHeight, maxHeight };\r\n    }\r\n\r\n    // function switching DTM-visualization (height map) on/off\r\n    doDtmVisualization = () => {\r\n        if (!this.viewport.GetDtmVisualization()) {\r\n            let result = this.calcMinMaxHeights();\r\n            let DtmVisualization = new window.MapCore.IMcMapViewport.SDtmVisualizationParams();\r\n            window.MapCore.IMcMapViewport.SDtmVisualizationParams.SetDefaultHeightColors(DtmVisualization, result.minHeight, result.maxHeight);\r\n            DtmVisualization.bDtmVisualizationAboveRaster = true;\r\n            DtmVisualization.uHeightColorsTransparency = 120;\r\n            DtmVisualization.uShadingTransparency = 255;\r\n            this.viewport.SetDtmVisualization(true, DtmVisualization);\r\n        } else {\r\n            this.viewport.SetDtmVisualization(false);\r\n        }\r\n    }\r\n\r\n    mouseWheelHandler = e => {\r\n        let bHandled = {};\r\n        let eCursor = {};\r\n        let wheelDelta = - e.deltaY;\r\n        this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_WHEEL, window.MapCore.SMcPoint(0, 0), e.ctrlKey, wheelDelta, bHandled, eCursor);\r\n        if (bHandled.Value) {\r\n            return;\r\n        }\r\n\r\n        let factor = (e.shiftKey ? 10 : 1);\r\n\r\n        if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n            this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(0, 0, wheelDelta / 8.0 * factor), true);\r\n        } else {\r\n            let fScale = this.viewport.GetCameraScale();\r\n            if (wheelDelta > 0) {\r\n                this.viewport.SetCameraScale(fScale / 1.25);\r\n            } else {\r\n                this.viewport.SetCameraScale(fScale * 1.25);\r\n            }\r\n\r\n            if (this.viewport.GetDtmVisualization()) {\r\n                this.doDtmVisualization();\r\n                this.doDtmVisualization();\r\n            }\r\n        }\r\n\r\n        e.preventDefault();\r\n        e.cancelBubble = true;\r\n        if (e.stopPropagation) e.stopPropagation();\r\n    }\r\n\r\n\r\n    mouseMoveHandler = (e, isTouch = false) => {\r\n        if (this.viewport.GetWindowHandle() != e.target) {\r\n            return;\r\n        }\r\n\r\n        let EventPixel = null;\r\n        if (isTouch) {\r\n            const rect = e.target.getBoundingClientRect();\r\n            const offsetX = e.targetTouches[0].pageX - rect.left;\r\n            const offsetY = e.targetTouches[0].pageY - rect.top;\r\n            EventPixel = window.MapCore.SMcPoint(offsetX, offsetY);\r\n        } else {\r\n            EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        }\r\n\r\n        if (e.buttons <= 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent((e.buttons == 1 || isTouch) ?\r\n                window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_MOVED_BUTTON_DOWN :\r\n                window.MapCore.IMcEditMode.EMouseEvent.EME_MOUSE_MOVED_BUTTON_UP,\r\n                EventPixel,\r\n                e.ctrlKey,\r\n                0,\r\n                bHandled,\r\n                eCursor\r\n            );\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (e.buttons == 1 || isTouch) {\r\n            if (this.nMousePrevX != 0) {\r\n                let factor = (e.shiftKey ? 10 : 1);\r\n                if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n                    if (e.ctrlKey) {\r\n                        this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D((this.nMousePrevX - EventPixel.x) / 2.0 * factor, - (this.nMousePrevY - EventPixel.y) / 2.0 * factor, 0), false);\r\n                    }\r\n                    else {\r\n                        this.viewport.RotateCameraRelativeToOrientation((this.nMousePrevX - EventPixel.x) / 2.0, - (this.nMousePrevY - EventPixel.y) / 2.0, 0);\r\n                    }\r\n                } else {\r\n                    if (e.ctrlKey) {\r\n                        this.viewport.SetCameraOrientation((this.nMousePrevX - EventPixel.x) / 2.0, window.MapCore.FLT_MAX, window.MapCore.FLT_MAX, true);\r\n                    }\r\n                    else {\r\n                        this.viewport.ScrollCamera((this.nMousePrevX - EventPixel.x) * factor, (this.nMousePrevY - EventPixel.y) * factor);\r\n                    }\r\n                }\r\n\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n            }\r\n        }\r\n\r\n        this.nMousePrevX = EventPixel.x;\r\n        this.nMousePrevY = EventPixel.y;\r\n    }\r\n\r\n\r\n\r\n\r\n    mouseDownHandler = e => {\r\n        if (this.editMode.IsEditingActive()) {\r\n            // EditMode is active: don't change active viewport, but ignore click on non-active one\r\n            if (this.viewport.GetWindowHandle() != e.target) {\r\n                return;\r\n            }\r\n        } else if (!this.state.bSameCanvas) {\r\n            for (let i = 0; i < this.aViewports.length; i++) {\r\n                if (e.target == this.aViewports[i].viewport.GetWindowHandle()) {\r\n                    this.activeViewport = i;\r\n                    this.updateActiveViewport();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        const rect = e.target.getBoundingClientRect();\r\n        let EventPixel = e.type == 'touchend' ?\r\n            window.MapCore.SMcPoint(e.changedTouches[0].pageX - rect.left, e.changedTouches[0].pageY - rect.top) :\r\n            window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n\r\n        this.mouseDownButtons = e.buttons;\r\n        if (e.type == 'touchend' || e.buttons == 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_PRESSED, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (this.props.isPointSelectionMode) {\r\n                this.OnEditClickMissionPoint();\r\n            }\r\n            else if (this.state.isOriginSelectionMode) {\r\n                this.OnEditClickWorkingOrigin(this.props.selectedDrone);\r\n            }\r\n\r\n\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n\r\n            this.nMousePrevX = EventPixel.x;\r\n            this.nMousePrevY = EventPixel.y;\r\n        }\r\n\r\n\r\n        e.preventDefault();\r\n        e.cancelBubble = true;\r\n        if (e.stopPropagation) e.stopPropagation();\r\n    }\r\n    mouseUpHandler = e => {\r\n        this.props.closeContextMenu();\r\n        if (this.viewport.GetWindowHandle() != e.target) {\r\n            return;\r\n        }\r\n\r\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        let buttons = this.mouseDownButtons & ~e.buttons;\r\n        if (buttons == 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_RELEASED, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n        }\r\n\r\n\r\n\r\n    }\r\n    mouseDblClickHandler = e => {\r\n        if (this.viewport.GetWindowHandle() != e.target) {\r\n            return;\r\n        }\r\n        let EventPixel = window.MapCore.SMcPoint(e.offsetX, e.offsetY);\r\n        let buttons = this.mouseDownButtons & ~e.buttons;\r\n        let aTargets = this.viewport.ScanInGeometry(new window.MapCore.SMcScanPointGeometry(window.MapCore.EMcPointCoordSystem.EPCS_SCREEN, window.MapCore.SMcVector3D(EventPixel.x, EventPixel.y, 0), 20), false);\r\n\r\n        if (this.bEdit) {\r\n            for (let i = 0; i < aTargets.length; ++i) {\r\n                if (aTargets[i].eTargetType == window.MapCore.IMcSpatialQueries.EIntersectionTargetType.EITT_OVERLAY_MANAGER_OBJECT) {\r\n                    if (this.bEdit) {\r\n                        this.editMode.StartEditObject(aTargets[i].ObjectItemData.pObject, aTargets[i].ObjectItemData.pItem);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            this.bEdit = false;\r\n            e.preventDefault();\r\n            e.cancelBubble = true;\r\n            if (e.stopPropagation) e.stopPropagation();\r\n            return;\r\n        }\r\n\r\n        if (buttons == 1) {\r\n            let bHandled = {};\r\n            let eCursor = {};\r\n            this.editMode.OnMouseEvent(window.MapCore.IMcEditMode.EMouseEvent.EME_BUTTON_DOUBLE_CLICK, EventPixel, e.ctrlKey, 0, bHandled, eCursor);\r\n            if (bHandled.Value) {\r\n                e.preventDefault();\r\n                e.cancelBubble = true;\r\n                if (e.stopPropagation) e.stopPropagation();\r\n                return;\r\n            }\r\n        }\r\n        for (let i = 0; i < aTargets.length; ++i) {\r\n            if (aTargets[i].eTargetType == window.MapCore.IMcSpatialQueries.EIntersectionTargetType.EITT_OVERLAY_MANAGER_OBJECT) {\r\n                const ID = aTargets[i].ObjectItemData.pObject.GetID();\r\n                ID !== null && ID !== undefined && this.props.showContextMenu(EventPixel.x + 5, EventPixel.y + 5, [{ name: ID == 0 ? \"Working Origin\" : \"WayPoint \" + ID }]);\r\n                break;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    stopEvent = (e) => {\r\n        e.preventDefault();\r\n        e.cancelBubble = true;\r\n        e.stopPropagation && e.stopPropagation();\r\n    }\r\n\r\n    touchStartHandler = (e) => {\r\n        const rect = e.target.getBoundingClientRect();\r\n        this.nMousePrevX = this._onMouseDownX = e.targetTouches[0].pageX - rect.left;\r\n        this.nMousePrevY = this._onMouseDownY = e.targetTouches[0].pageY - rect.top;\r\n        //this.stopEvent(e);        \r\n    }\r\n\r\n    screenToWorld = (x, y, options) => {\r\n        const screenPoint = new window.MapCore.SMcVector3D(x, y, 0);\r\n        const worldPoint = {};\r\n        if (!this.viewport.ScreenToWorldOnTerrain(screenPoint, worldPoint)) {\r\n            this.viewport.ScreenToWorldOnPlane(screenPoint, worldPoint);\r\n        }\r\n        let ret = worldPoint;\r\n        if (!options || !options.withoutConvert) {\r\n            //   const worldPointGeo = this.gridConverter.ConvertAtoB(worldPoint.Value);\r\n            //   const worldPointGeoConverted = ConvertGEOPartial.geoPartialCoordsToGeoPartial(new geo.coordinate(worldPointGeo.x / DEG_TO_MC, worldPointGeo.y / DEG_TO_MC, worldPointGeo.z));\r\n            //   const worldPointGrid = worldPoint.Value;\r\n            //   ret = {worldPointGeo, worldPointGeoConverted, worldPointGrid};\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    worldToScreen = (coordinate, options) => {\r\n        let srcCoords = coordinate;\r\n        if (!options || !options.native) {\r\n            //srcCoords = this._transformCoordinateToNative(coordinate);\r\n        }\r\n        const screenPoint = this.viewport.WorldToScreen(srcCoords);\r\n        let inScreen = true;\r\n        if (screenPoint.x < 0 || screenPoint.x > this._canvas.width ||\r\n            screenPoint.y < 0 || screenPoint.y > this._canvas.height) {\r\n            inScreen = false;\r\n        }\r\n        return { x: screenPoint.x, y: screenPoint.y, inScreen };\r\n    }\r\n\r\n    moveCameraRelativeToOrientation = (moveX, moveY, ignorePitch = true, useHeightFactor = false) => {\r\n        let factor = 1;\r\n        if (useHeightFactor) {\r\n            const currentPosition = this.viewport.GetCameraPosition();\r\n            let height = {};\r\n            let heightDiff = Math.abs(currentPosition.z);\r\n            if (this.viewport.GetTerrainHeight(currentPosition, height)) {\r\n                heightDiff = currentPosition.z - height.Value;\r\n            }\r\n\r\n            //   if (this.moveCameraRelativeToOrientationFactor) {\r\n            //     const heightFactorNameToUse = useHeightFactor ? useHeightFactor : 'other';\r\n            //     const heightFactorToUse = this.moveCameraRelativeToOrientationFactor[heightFactorNameToUse];\r\n            //     if (heightFactorToUse) {              \r\n            //       for (let i = 0; i < heightFactorToUse.length; i++) {\r\n            //         if (!heightFactorToUse[i].max) {\r\n            //           factor = heightFactorToUse[i].factor;\r\n            //         }\r\n            //         if (heightDiff < heightFactorToUse[i].max) {\r\n            //           factor = heightFactorToUse[i].factor;\r\n            //           break;\r\n            //         }\r\n            //       }\r\n            //     }\r\n            //   }\r\n            // }\r\n\r\n            if (useHeightFactor === 'mouse') {\r\n                factor = 600;\r\n                if (heightDiff < 10) {\r\n                    factor = 1;\r\n                } else if (heightDiff < 30) {\r\n                    factor = 3;\r\n                } else if (heightDiff < 100) {\r\n                    factor = 6;\r\n                } else if (heightDiff < 200) {\r\n                    factor = 12;\r\n                } else if (heightDiff < 300) {\r\n                    factor = 20;\r\n                } else if (heightDiff < 500) {\r\n                    factor = 35;\r\n                } else if (heightDiff < 1000) {\r\n                    factor = 100;\r\n                } else if (heightDiff < 2000) {\r\n                    factor = 200;\r\n                } else if (heightDiff < 5000) {\r\n                    factor = 400;\r\n                }\r\n            } else if (useHeightFactor === 'touch') {\r\n                factor = 600;\r\n                if (heightDiff < 10) {\r\n                    factor = 2;\r\n                } else if (heightDiff < 30) {\r\n                    factor = 6;\r\n                } else if (heightDiff < 100) {\r\n                    factor = 9;\r\n                } else if (heightDiff < 200) {\r\n                    factor = 12;\r\n                } else if (heightDiff < 300) {\r\n                    factor = 20;\r\n                } else if (heightDiff < 500) {\r\n                    factor = 35;\r\n                } else if (heightDiff < 1000) {\r\n                    factor = 100;\r\n                } else if (heightDiff < 2000) {\r\n                    factor = 200;\r\n                } else if (heightDiff < 5000) {\r\n                    factor = 400;\r\n                }\r\n                factor *= 2;\r\n            } else {\r\n                factor = 150;\r\n                if (heightDiff < 10) {\r\n                    factor = 1;\r\n                } else if (heightDiff < 30) {\r\n                    factor = 4;\r\n                } else if (heightDiff < 100) {\r\n                    factor = 8;\r\n                } else if (heightDiff < 200) {\r\n                    factor = 12;\r\n                } else if (heightDiff < 300) {\r\n                    factor = 30;\r\n                } else if (heightDiff < 500) {\r\n                    factor = 50;\r\n                } else if (heightDiff < 1000) {\r\n                    factor = 100;\r\n                }\r\n            }\r\n        }\r\n        this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(moveX * factor, moveY * factor, 0), ignorePitch);\r\n    }\r\n\r\n    getCameraOrientation = () => {\r\n        let ret = { azimuth: 0, pitch: 0 };\r\n        const azimuthOrientation = {};\r\n        const pitchOrientation = {};\r\n        this.viewport.GetCameraOrientation(azimuthOrientation, pitchOrientation, null);\r\n        if (azimuthOrientation) {\r\n            ret.azimuth = azimuthOrientation.Value;\r\n        }\r\n        if (pitchOrientation) {\r\n            ret.pitch = pitchOrientation.Value;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    setCameraOrientation = (cameraOrientationAzimuth, cameraOrientationPitch, stopDrag = true) => {\r\n        const azimuthOrientation = {};\r\n        const pitchOrientation = {};\r\n        const rollOrientation = {};\r\n        this.viewport.GetCameraOrientation(azimuthOrientation, pitchOrientation, rollOrientation);\r\n        const azimuthToSet = cameraOrientationAzimuth !== undefined ? cameraOrientationAzimuth : azimuthOrientation.Value;\r\n        const pitchToSet = cameraOrientationPitch !== undefined ? cameraOrientationPitch : pitchOrientation.Value;\r\n        this.viewport.SetCameraOrientation(azimuthToSet, pitchToSet, 0);\r\n    }\r\n\r\n    isGeoCoordValid = (coord, isNative = true) => {\r\n        const DEG_TO_MC = 100000;\r\n\r\n        let isValid = true;\r\n        const coordFactor = isNative ? DEG_TO_MC : 1;\r\n        if (coord.x < -180 * coordFactor || coord.y < -89.5 * coordFactor || coord.y === 0) {\r\n            isValid = false;\r\n        } else if (coord.x > 180 * coordFactor || coord.y > 89.5 * coordFactor || coord.z > Number.MAX_VALUE) {\r\n            isValid = false;\r\n        }\r\n        return isValid;\r\n    }\r\n\r\n    rotateCameraAroundWorldPoint = (coord, azimuthDelta, azimuthPitch, watchRoll) => {\r\n        const currentAzimuth = {};\r\n        const currentPitch = {};\r\n        const currentRoll = {};\r\n        let currentPosition;\r\n        if (watchRoll) {\r\n            this.viewport.GetCameraOrientation(currentAzimuth, currentPitch, currentRoll);\r\n            currentPosition = this.viewport.GetCameraPosition();\r\n        }\r\n\r\n        this.viewport.RotateCameraAroundWorldPoint(coord, azimuthDelta, azimuthPitch);\r\n\r\n        if (watchRoll) {\r\n            const newAzimuth = {};\r\n            const newPitch = {};\r\n            const newRoll = {};\r\n            this.viewport.GetCameraOrientation(newAzimuth, newPitch, newRoll);\r\n            if (Math.abs(newRoll.Value) === 180) {\r\n                this.viewport.SetCameraOrientation(currentAzimuth.Value, currentPitch.Value, currentRoll.Value, false);\r\n                this.viewport.SetCameraPosition(currentPosition);\r\n            } else {\r\n                //this.mapMngr.notifyGeneralEvent('maporientationchanged', newAzimuth.Value, this.elementId);\r\n            }\r\n        }\r\n    }\r\n\r\n    rotateCameraRelativeToOrientation = (moveX, moveY, factor) => {\r\n        this.viewport.RotateCameraRelativeToOrientation(moveX * factor, moveY * factor, 0);\r\n        const azimuthChange = {};\r\n        this.viewport.GetCameraOrientation(azimuthChange, null, null);\r\n        //this.mapMngr.notifyGeneralEvent('maporientationchanged', azimuthChange.Value, this.elementId);\r\n    }\r\n\r\n    getCameraScale = (convertToMeters = false) => {\r\n        let ret;\r\n        if (!this.state.is3DClicked) {\r\n            ret = this.viewport.GetCameraScale();\r\n            if (convertToMeters) {\r\n                ret /= this.viewport.GetPixelPhysicalHeight();\r\n                ret = (ret * 10).toFixed(2);\r\n                ret = parseInt(ret);\r\n            }\r\n        } else {\r\n            ret = this.viewport.GetCameraPosition().z;\r\n        }\r\n\r\n        return ret;\r\n    }\r\n    setCameraScale = (scale, factorFor3D = 1, notifyFpAndScale) => {\r\n        if (!this.state.is3DClicked) {\r\n            const mapScaleTopLimit = this.mapScaleTopLimit || 200000;\r\n            this.cameraScaleChanged = true;\r\n            const pixelPhysicalHeight = this.viewport.GetPixelPhysicalHeight();\r\n            const ratio = scale / pixelPhysicalHeight;\r\n            if (ratio < 25) {\r\n                scale = pixelPhysicalHeight * 25;\r\n            } else if (ratio > mapScaleTopLimit) {\r\n                scale = pixelPhysicalHeight * mapScaleTopLimit;\r\n            }\r\n            this.viewport.SetCameraScale(scale);\r\n        } else {\r\n            const camPosition = this.viewport.GetCameraPosition();\r\n            let zoomSign = 1;\r\n            if (scale > camPosition.z) {\r\n                zoomSign = -1;\r\n            }\r\n            const factor = factorFor3D * camPosition.z / 100;\r\n            this.viewport.MoveCameraRelativeToOrientation(window.MapCore.SMcVector3D(0, zoomSign * factor, 0), false);\r\n        }\r\n\r\n        // if (notifyFpAndScale) {\r\n        //   let fpToUpdate;\r\n        //   let scaleToUpdate;\r\n        //   if (!this.state.is3DClicked) {\r\n        //     // Notify scale change if needed (only in 2d viewport)\r\n        //     let currentScale = this.viewport.GetCameraScale() / this.viewport.GetPixelPhysicalHeight();\r\n        //     currentScale = (currentScale * 10).toFixed(2);\r\n        //     currentScale = parseInt(currentScale);\r\n\r\n        //     fpToUpdate = this.viewport.GetCameraFootprint();\r\n        //     scaleToUpdate = currentScale;\r\n        //   } else {\r\n        //     const footPrint = this.calculate3DFootPrint();\r\n        //     fpToUpdate = footPrint.fp;\r\n        //     scaleToUpdate = footPrint.scale;\r\n        //   }\r\n        //   if (fpToUpdate && fpToUpdate.bUpperLeftFound && fpToUpdate.bUpperRightFound &&\r\n        //     fpToUpdate.bLowerRightFound && fpToUpdate.bLowerLeftFound) {\r\n\r\n        //     this.notifyCameraMove(fpToUpdate, scaleToUpdate, this.elementId);\r\n        //   }\r\n        // }\r\n    }\r\n\r\n    updatePositionText = (x, y, z, updateHeight = true) => {\r\n        let height;\r\n        try {\r\n            //when updating position height displayed, use default precision\r\n            const heightForQuery = {};\r\n            const lonNew = (Math.abs(x) > 100000) ? x : x * 100000;\r\n            const latNew = (Math.abs(y) > 100000) ? y : y * 100000;\r\n            const positionToCheck = new window.MapCore.SMcVector3D(lonNew, latNew, 0);\r\n            if (this.viewport.GetTerrainHeight(positionToCheck, heightForQuery)) {\r\n                height = heightForQuery.Value;\r\n            }\r\n        } catch (exp) { }\r\n\r\n        // Update context with new height\r\n        if (updateHeight) {\r\n            this.lastUpdatedHeight = height;\r\n            console.log('mapheightchanged', height);\r\n        }\r\n\r\n        // Update context with new position\r\n        // const point = new geo.coordinate(x, y, height);\r\n        // this.mapMngr.notifyGeneralEvent('mappositionchanged', point, this.elementId);\r\n    }\r\n\r\n    zoomIn = (amount, duration) => {\r\n        const currentScale = this.getCameraScale();\r\n        this.setCameraScale(currentScale / (amount || 1.5));\r\n        if (this.lastClickPos) {\r\n            this.updatePositionText(this.lastClickPos.x, this.lastClickPos.y, this.lastClickPos.z);\r\n        }\r\n    }\r\n\r\n    zoomOut = (amount, duration) => {\r\n        const currentScale = this.getCameraScale();\r\n        this.setCameraScale(currentScale * (amount || 1.5));\r\n        if (this.lastClickPos) {\r\n            this.updatePositionText(this.lastClickPos.x, this.lastClickPos.y, this.lastClickPos.z);\r\n        }\r\n    }\r\n\r\n    handleZoomOrRotate = e => {\r\n\r\n        const xDistance = e.touches[0].screenX - e.touches[1].screenX;\r\n        const yDistance = e.touches[0].screenY - e.touches[1].screenY;\r\n\r\n        const currentDistance = Math.abs((xDistance * xDistance) + (yDistance * yDistance));\r\n\r\n        if (!this.lastTouchDistance) {\r\n            this.lastTouchDistance = currentDistance;\r\n        } else {\r\n            const zoomIn = currentDistance - this.lastTouchDistance > 0;\r\n            const difDistance = Math.abs(currentDistance - this.lastTouchDistance);\r\n\r\n            // Calculate the average position(screen and geo) of the touches\r\n            const rect = e.target.getBoundingClientRect();\r\n\r\n            const firstTouchX = e.targetTouches[0].pageX - rect.left;\r\n            const firstTouchY = e.targetTouches[0].pageY - rect.top;\r\n\r\n            const secondTouchX = e.targetTouches[1].pageX - rect.left;\r\n            const secondTouchY = e.targetTouches[1].pageY - rect.top;\r\n\r\n            const averageX = (firstTouchX + secondTouchX) / 2;\r\n            const averageY = (firstTouchY + secondTouchY) / 2;\r\n\r\n            const averageWorldPosition = this.screenToWorld(averageX, averageY, { withoutConvert: true });\r\n\r\n            let prevAverageX;\r\n            let prevAverageY;\r\n\r\n            if (!this.pinchStatus) {\r\n                this.pinchStatus = { averageX, averageY, averageWorldPosition };\r\n            } else {\r\n                prevAverageX = this.pinchStatus.averageX;\r\n                prevAverageY = this.pinchStatus.averageY;\r\n\r\n                this.pinchStatus.averageX = averageX;\r\n                this.pinchStatus.averageY = averageY;\r\n            }\r\n\r\n            if (!this.state.is3DClicked) {\r\n                if (difDistance > 10000) {\r\n                    //The distance between the touches is big\\small enough for zooming in\\out.\r\n                    if (zoomIn) {\r\n                        this.zoomIn(1.05);\r\n                    } else {\r\n                        this.zoomOut(1.05);\r\n                    }\r\n                    this.lastTouchDistance = currentDistance;\r\n                }\r\n            } else if (!this.pinchStatus.coordToRotateAround3D) {\r\n                if (difDistance > 1000) {\r\n                    //The distance between the touches is big\\small enough for zooming in\\out.\r\n                    const zoomFactor = difDistance / 5000;\r\n                    if (zoomIn) {\r\n                        this.moveCameraRelativeToOrientation(0, zoomFactor, false, true);\r\n                    } else {\r\n                        this.moveCameraRelativeToOrientation(0, -zoomFactor, false, true);\r\n                    }\r\n                    this.lastTouchDistance = currentDistance;\r\n                    prevAverageX = undefined;\r\n                    prevAverageY = undefined;\r\n                    this.pinchStatus.zooming3D = true;\r\n                } else {\r\n                    this.pinchStatus.zooming3D = false;\r\n                }\r\n            }\r\n\r\n            if (!this.state.is3DClicked) {\r\n                // Calculating the angle between the touches for orientation setting\r\n                const currentRotation = Math.atan2(firstTouchY - secondTouchY, firstTouchX - secondTouchX) * 180 / Math.PI;\r\n                let difRotation = 0;\r\n                if (this.lastTouchRotation === undefined) {\r\n                    //first series of rotations\r\n                    this.lastTouchRotation = currentRotation;\r\n                } else {\r\n                    difRotation = Math.abs(currentRotation - this.lastTouchRotation);\r\n                    if (difRotation > 0.5) {\r\n                        const currentCameraOrientation = this.getCameraOrientation().azimuth;\r\n                        this.setCameraOrientation(currentCameraOrientation + this.lastTouchRotation - currentRotation);\r\n                        this.lastTouchRotation = currentRotation;\r\n                    }\r\n                }\r\n\r\n                if (this.pinchStatus) {\r\n                    // After zooming or changing orientation, set the map so the previous screen position with be placed on\r\n                    // the same geo position as it was before.\r\n                    const averageScreenAfterZoom = this.worldToScreen(this.pinchStatus.averageWorldPosition.Value, { native: true });\r\n                    const scrollX = averageScreenAfterZoom.x - this.pinchStatus.averageX;\r\n                    const scrollY = averageScreenAfterZoom.y - this.pinchStatus.averageY;\r\n                    try {\r\n                        this.viewport.ScrollCamera(scrollX, scrollY);\r\n                    } catch (exp) {\r\n                    }\r\n                }\r\n            } else {\r\n                //handle 3d rotating\r\n                if (prevAverageX || prevAverageY) {\r\n                    const currentRotation = Math.atan2(firstTouchY - secondTouchY, firstTouchX - secondTouchX) * 180 / Math.PI;\r\n                    let difRotation = 0;\r\n                    if (this.lastTouchRotation === undefined) {\r\n                        //first series of rotations\r\n                        this.lastTouchRotation = currentRotation;\r\n                    } else {\r\n                        difRotation = Math.abs(currentRotation - this.lastTouchRotation);\r\n                        if (!this.pinchStatus.zooming3D && (difRotation > 2.5 || this.pinchStatus.coordToRotateAround3D)) {\r\n                            this.pinchStatus.coordToRotateAround3D = this.pinchStatus.coordToRotateAround3D || averageWorldPosition.Value;\r\n                            const nativeCoord = this.pinchStatus.coordToRotateAround3D;\r\n                            if (this.isGeoCoordValid(nativeCoord)) {\r\n                                const rotateSign = Math.sign(this.lastTouchRotation - currentRotation);\r\n                                this.rotateCameraAroundWorldPoint(nativeCoord, rotateSign * 2, 0, true);\r\n                            }\r\n                        } else {\r\n                            this.cameraMoved = true;\r\n                            const offsetX = prevAverageX - this.pinchStatus.averageX;\r\n                            const offsetY = this.pinchStatus.averageY - prevAverageY;\r\n                            this.rotateCameraRelativeToOrientation(offsetX, offsetY, 0.1);\r\n                        }\r\n                        this.lastTouchRotation = currentRotation;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    touchMoveHandler = e => {\r\n        const isTouch = true;\r\n        if (e.touches.length === 1) {\r\n            this.mouseMoveHandler(e, isTouch);\r\n        } else {\r\n            this.handleZoomOrRotate(e);\r\n        }\r\n        e.preventDefault();\r\n    }\r\n\r\n    touchEndHandler = (e) => {\r\n        this.isTouch = false;\r\n        this.pinchStatus = undefined;\r\n        if (e.touches && e.touches.length) {\r\n            // Removing only one touch while there is more touches enabled\r\n            this.disableMoveAfterMultiTouches = true;\r\n            setTimeout(() => {\r\n                this.disableMoveAfterMultiTouches = false;\r\n            }, 200);\r\n        }\r\n        if (!e.touches.length) {\r\n            this.isMouseDown = false;\r\n            this.lastTouchDistance = 0;\r\n            this.lastTouchRotation = undefined;\r\n\r\n            // Cancel long click listening\r\n            //clearTimeout(longClick);\r\n            // Not in edit mode\r\n            this.dbclickHandled = true;\r\n\r\n            // canvas.clickCount++;\r\n            // if (canvas.clickCount === 1) {\r\n            //     singleClick = setTimeout(e => {\r\n            //     canvas.clickCount = 0;\r\n            //     this.onLeftClick(e) || this.stopEvent(e);\r\n            //     }, 200, e);\r\n            // } else if (canvas.clickCount === 2) {\r\n            //     clearTimeout(singleClick);\r\n            //     canvas.clickCount = 0;\r\n            //     this.onLeftDoubleClick(e);\r\n            // }\r\n        }\r\n\r\n        // if (this.props.isPointSelectionMode || !this.props.workingOrigin || !this.MapObjects[droneNumber].WorkingOrigin.GetLocationPoints()[0]) {\r\n        //     this.mouseDownHandler(e);\r\n        // }\r\n        e.preventDefault();\r\n        e.target.focus()\r\n    }\r\n\r\n    touchCancelHandler = (e) => { }\r\n\r\n    createViewport(terrain, eMapTypeToOpen) {\r\n        // create canvas if needed\r\n        let currCanvas;\r\n        if (!this.state.bSameCanvas || this.aViewports.length == 0) {\r\n            // create canvas\r\n            currCanvas = document.createElement('canvas');\r\n            //currCanvas.style.border = \"thick solid #FFFFFF\"; \r\n\r\n            currCanvas.addEventListener(\"wheel\", this.mouseWheelHandler, false);\r\n            currCanvas.addEventListener(\"mousemove\", this.mouseMoveHandler, false);\r\n            currCanvas.addEventListener(\"mousedown\", this.mouseDownHandler, false);\r\n            currCanvas.addEventListener(\"mouseup\", this.mouseUpHandler, false);\r\n            currCanvas.addEventListener(\"dblclick\", this.mouseDblClickHandler, false);\r\n\r\n            currCanvas.addEventListener(\"touchstart\", this.touchStartHandler, false);\r\n            currCanvas.addEventListener(\"touchend\", this.touchEndHandler, false);\r\n            currCanvas.addEventListener(\"touchend\", this.mouseDownHandler, false);\r\n            currCanvas.addEventListener(\"touchmove\", this.touchMoveHandler, false);\r\n            currCanvas.addEventListener(\"touchcancel\", this.touchCancelHandler, false);\r\n        }\r\n        else {\r\n            // use existing canvas\r\n            currCanvas = this.aViewports[0].canvas;\r\n        }\r\n\r\n        // create viewport\r\n        let layerGroup = this.state.mapLayerGroups.get(this.state.lastTerrainConfiguration);\r\n        let vpCreateData = new window.MapCore.IMcMapViewport.SCreateData(eMapTypeToOpen);\r\n        vpCreateData.pDevice = this.device;\r\n        vpCreateData.pCoordinateSystem = (terrain != null ? terrain.GetCoordinateSystem() : this.overlayManager.GetCoordinateSystemDefinition());\r\n        vpCreateData.pOverlayManager = this.overlayManager;\r\n        vpCreateData.hWnd = currCanvas;\r\n        if (layerGroup.bShowGeoInMetricProportion) {\r\n            vpCreateData.bShowGeoInMetricProportion = true;\r\n        }\r\n        this.viewport = window.MapCore.IMcMapViewport.Create(/*Camera*/null, vpCreateData, terrain != null ? [terrain] : null);\r\n        this.editMode = window.MapCore.IMcEditMode.Create(this.viewport);\r\n\r\n        // add camera-update callback\r\n        let callback = new this.CCameraUpdateCallback();\r\n        this.viewport.AddCameraUpdateCallback(callback);\r\n\r\n        if (this.viewport.GetMapType() == window.MapCore.IMcMapCamera.EMapType.EMT_3D) {\r\n            this.viewport.SetScreenSizeTerrainObjectsFactor(1.5);\r\n            this.viewport.SetCameraRelativeHeightLimits(3, 10000, true);            \r\n        }\r\n        else {\r\n            this.viewport.SetStaticObjectsVisibilityMaxScale(50);\r\n            if (layerGroup.InitialScale2D) {\r\n                this.viewport.SetCameraScale(layerGroup.InitialScale2D);\r\n            }\r\n        }\r\n\r\n        this.viewport.SetBackgroundColor(window.MapCore.SMcBColor(70, 70, 70, 255));\r\n\r\n        // set object delays for optimazing rendering objects\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_UPDATE, true, 50);\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_CONDITION, true, 50);\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_SIZE, true, 5);\r\n        this.viewport.SetObjectsDelay(window.MapCore.IMcMapViewport.EObjectDelayType.EODT_VIEWPORT_CHANGE_OBJECT_HEIGHT, true, 50);\r\n\r\n        // set objects movement threshold\r\n        this.viewport.SetObjectsMovementThreshold(1);\r\n\r\n        // set terrain cache\r\n        if (terrain != null) {\r\n            this.viewport.SetTerrainNumCacheTiles(terrain, false, 300);\r\n            this.viewport.SetTerrainNumCacheTiles(terrain, true, 300);\r\n        }\r\n\r\n        let viewportData = new SViewportData(this.viewport, this.editMode);\r\n        viewportData.terrain = terrain;\r\n        if (layerGroup.bSetTerrainBoxByStaticLayerOnly) {\r\n            viewportData.bSetTerrainBoxByStaticLayerOnly = true;\r\n        }\r\n\r\n        this.aViewports.push(viewportData);\r\n        const canvasParent = document.getElementById('canvasesContainer')\r\n        canvasParent.appendChild(currCanvas);\r\n        this.activeViewport = this.aViewports.length - 1;\r\n\r\n        this.updateActiveViewport();\r\n        this.resizeCanvases();\r\n        this.trySetTerainBox();\r\n    }\r\n\r\n    // function updating active viewport / Edit Mode and canvas borders\r\n    updateActiveViewport() {\r\n        if (this.activeViewport >= 0) {\r\n            for (let i = 0; i < this.aViewports.length; ++i) {\r\n                if (i == this.activeViewport) {\r\n                    this.viewport = this.aViewports[i].viewport;\r\n                    this.editMode = this.aViewports[i].editMode;\r\n                    if (!this.state.bSameCanvas) {\r\n                        //this.aViewports[i].canvas.style.borderColor = \"blue\";\r\n                    }\r\n                }\r\n                else {\r\n                    //this.aViewports[i].canvas.style.borderColor = \"white\";\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    doPrevViewport() {\r\n        if (this.aViewports.length > 1) {\r\n            this.activeViewport = (this.activeViewport + this.aViewports.length - 1) % this.aViewports.length;\r\n            this.updateActiveViewport();\r\n        }\r\n    }\r\n\r\n    doNextViewport() {\r\n        if (this.aViewports.length > 1) {\r\n            this.activeViewport = (this.activeViewport + 1) % this.aViewports.length;\r\n            this.updateActiveViewport();\r\n        }\r\n    }\r\n\r\n    // function creating terrain overlayManager and viewport, starting rendering\r\n    initializeViewports() {\r\n        let terrain = this.mapTerrains.get(this.state.lastTerrainConfiguration);\r\n        if (terrain == undefined) {\r\n            if (this.aLastTerrainLayers.length > 0) {\r\n                terrain = window.MapCore.IMcMapTerrain.Create(this.lastCoordSys, this.aLastTerrainLayers);\r\n                terrain.AddRef();\r\n            }\r\n            else {\r\n                terrain = null;\r\n            }\r\n            this.mapTerrains.set(this.state.lastTerrainConfiguration, terrain);\r\n        }\r\n\r\n        // create overlay manager\r\n        if (this.overlayManager == null) {\r\n            if (this.lastCoordSys == null) {\r\n                this.lastCoordSys = window.MapCore.IMcGridUTM.Create(36, window.MapCore.IMcGridCoordinateSystem.EDatumType.EDT_ED50_ISRAEL);\r\n                this.lastCoordSys.AddRef();\r\n            }\r\n            this.overlayManager = window.MapCore.IMcOverlayManager.Create(this.lastCoordSys);\r\n            this.overlayManager.AddRef();\r\n\r\n            // create overlay for objects\r\n            this.overlay = window.MapCore.IMcOverlay.Create(this.overlayManager);\r\n\r\n        }\r\n\r\n        // create map viewports\r\n        switch (this.state.lastViewportConfiguration) {\r\n            case \"2D/3D\":\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                this.DoPrevViewport();\r\n                break;\r\n            case \"3D/2D\":\r\n                if (this.state.bSameCanvas) {\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                }\r\n                else {\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);\r\n                    this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                    this.doPrevViewport();\r\n                }\r\n                break;\r\n            case \"2D\":\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_2D);\r\n                break;\r\n            case \"3D\":\r\n                this.createViewport(terrain, window.MapCore.IMcMapCamera.EMapType.EMT_3D);                                \r\n                break;\r\n        }\r\n\r\n        // example of try-catch MapCoreError\r\n        try {\r\n            // MapCore API function call\r\n            this.viewport.SetDtmTransparencyWithoutRaster(true);\r\n        }\r\n        catch (ex) {\r\n            if (ex instanceof window.MapCoreError) {\r\n                alert(\"MapCore Error #\" + ex.name + \": \" + ex.message);\r\n            }\r\n            else {\r\n                throw ex;\r\n            }\r\n        }\r\n\r\n        // ask the browser to render once\r\n        requestAnimationFrame(this.renderMapContinuously);\r\n    }\r\n\r\n    createMapLayersAndViewports() {\r\n        // if this terrain has not been created yet\r\n        if (this.mapTerrains.get(this.state.lastTerrainConfiguration) == undefined) {\r\n            this.aLastTerrainLayers = [];\r\n            let group = this.state.mapLayerGroups.get(this.state.lastTerrainConfiguration);\r\n            // create coordinate system by running a code string prepared during parsing configuration files (JSON configuration file and capabilities XML of MapCoreLayerServer)\r\n            // e.g. MapCore.IMcGridCoordSystemGeographic.Create(MapCore.IMcGridCoordinateSystem.EDatumType.EDT_WGS84)\r\n            this.lastCoordSys = eval(group.coordSystemString);\r\n\r\n            for (let i = 0; i < group.aLayerCreateStrings.length; ++i) {\r\n                // create map layer by running code string prepared during parsing configuration files (JSON configuration file and capabilities XML of MapCoreLayerServer)\r\n                // e.g. MapCore.IMcNativeRasterMapLayer.Create('http:Maps/Raster/SwissOrtho-GW') or CreateWMTSRasterLayer(...) or CreateWMSRasterLayer(...)\r\n                const layer = eval(group.aLayerCreateStrings[i]);\r\n                this.aLastTerrainLayers.push(layer);\r\n                if (layer instanceof window.MapCore.IMc3DModelMapLayer) {\r\n\r\n                    layer.SetDisplayingItemsAttachedToTerrain(true);\r\n                    layer.SetDisplayingDtmVisualization(true);\r\n                    layer.SetResolvingConflictsWithDtmAndRaster(true);\r\n                }\r\n            }\r\n            this.lastCoordSys.AddRef();\r\n        }\r\n\r\n        this.initializeViewports();\r\n    }\r\n\r\n    // async callGetCapabilitiesApi() {\r\n    //     try {\r\n    //         const response = await axios.get(config.urls.getCapabilities);\r\n    //         const capabilitiesXMLDoc =  new DOMParser().parseFromString(response.data, \"text/xml\");\r\n    //         this.parseCapabilitiesXML(capabilitiesXMLDoc, config.urls.getCapabilities);\r\n    //         this.openMap(this.context.mapToPreview.title);\r\n\r\n    //     } catch (e) {\r\n    //         \r\n    //     }\r\n    // }\r\n\r\n    async openMap(title, is3d) {\r\n        const serverUrl = externalConfig.getConfiguration().MAPCORE_LAYER_SERVER_URL;\r\n        if (serverUrl) {\r\n            try {\r\n                const response = await axios.get(serverUrl + config.urls.getCapabilities);\r\n                const capabilitiesXMLDoc = new DOMParser().parseFromString(response.data, \"text/xml\");\r\n                this.parseCapabilitiesXML(capabilitiesXMLDoc, config.urls.getCapabilities);\r\n            } catch (e) {\r\n            }\r\n        } else {\r\n            this.parseLayersConfiguration([this.props.mapToShow])\r\n        }\r\n\r\n\r\n        this.state.mapLayerGroups.forEach((value, key) => {\r\n            if (key === title) {\r\n\r\n                this.setState({\r\n                    lastTerrainConfiguration: key,\r\n                    lastViewportConfiguration: is3d ? \"3D\" : \"2D\"\r\n                }, () => {\r\n                    if (this.device === null) {\r\n                        // create map device (MapCore initialization)\r\n                        let init = new window.MapCore.IMcMapDevice.SInitParams();\r\n                        init.uNumTerrainTileRenderTargets = 100;\r\n\r\n                        const device = window.MapCore.IMcMapDevice.Create(init);\r\n                        device.AddRef();\r\n                        this.device = device;\r\n\r\n                        // create callback classes\r\n                        this.createCallbackClasses();\r\n                    }\r\n                    this.createMapLayersAndViewports();\r\n                });\r\n            }\r\n        })\r\n    }\r\n\r\n    doDtmVisualization() {\r\n        if (!this.viewport.GetDtmVisualization()) {\r\n            let result = this.calcMinMaxHeights();\r\n            let DtmVisualization = new window.MapCore.IMcMapViewport.SDtmVisualizationParams();\r\n            window.MapCore.IMcMapViewport.SDtmVisualizationParams.SetDefaultHeightColors(DtmVisualization, result.minHeight, result.maxHeight);\r\n            DtmVisualization.bDtmVisualizationAboveRaster = true;\r\n            DtmVisualization.uHeightColorsTransparency = 120;\r\n            DtmVisualization.uShadingTransparency = 255;\r\n            this.viewport.SetDtmVisualization(true, DtmVisualization);\r\n        }\r\n        else {\r\n            this.viewport.SetDtmVisualization(false);\r\n        }\r\n    }\r\n\r\n    // function closing active viewport\r\n    closeMap() {\r\n        if (this.activeViewport < 0) {\r\n            return;\r\n        }\r\n        // delete Edit Mode\r\n        this.editMode.Destroy();\r\n        // delete viewport\r\n        this.viewport.Release();\r\n        if (!this.bSameCanvas || this.aViewports.length == 1) {\r\n            // delete canvas\r\n            let currCanvas = this.aViewports[this.activeViewport].canvas;\r\n            currCanvas.removeEventListener(\"wheel\", this.mouseWheelHandler, false);\r\n            currCanvas.removeEventListener(\"mousemove\", this.mouseMoveHandler, false);\r\n            currCanvas.removeEventListener(\"mousedown\", this.mouseDownHandler, false);\r\n            currCanvas.removeEventListener(\"mouseup\", this.mouseUpHandler, false);\r\n            currCanvas.removeEventListener(\"dblclick\", this.mouseDblClickHandler, false);\r\n            currCanvas.removeEventListener(\"touchstart\", this.touchStartHandler, false);\r\n            currCanvas.removeEventListener(\"touchend\", this.touchEndHandler, false);\r\n            currCanvas.removeEventListener(\"touchmove\", this.touchMoveHandler, false);\r\n            currCanvas.removeEventListener(\"touchcancel\", this.touchCancelHandler, false);\r\n\r\n            let canvasParent = document.getElementById('canvasesContainer');\r\n            canvasParent.removeChild(this.aViewports[this.activeViewport].canvas);\r\n        }\r\n        // remove viewport from viewport data array\r\n        //this.activeViewport.viewport = this.activeViewport.viewport ? null :;\r\n        this.aViewports.splice(this.activeViewport, 1);\r\n        if (this.aViewports.length == 0) {\r\n            // no more viewports\r\n            this.viewport = null;\r\n            this.editMode = null;\r\n            this.activeViewport = -1;\r\n            // delete terrain\r\n            this.mapTerrains.forEach(terrain => { terrain.Release(); });\r\n            this.mapTerrains.clear();\r\n            // delete overlay manager\r\n            this.overlayManager.Release();\r\n            this.overlayManager = null;\r\n\r\n        }\r\n        else {\r\n            // there are viewports: update active viewport\r\n            if (this.activeViewport >= this.aViewports.length) {\r\n                this.activeViewport = this.aViewports.length - 1;\r\n            }\r\n            this.updateActiveViewport();\r\n            this.resizeCanvases();\r\n        }\r\n\r\n\r\n        this.setState({\r\n            mapLayerGroups: new Map(),\r\n            lastTerrainConfiguration: null,\r\n            lastViewportConfiguration: null /*  2D/3D, 3D/2D, 2D, 3D */,\r\n            bSameCanvas: true\r\n        });\r\n\r\n        this.mapTerrains = new Map;\r\n        this.device = null\r\n        this.viewportData = null;\r\n        this.aLastTerrainLayers = [];\r\n        this.lastCoordSys = null;\r\n        this.overlayManager = null;\r\n        this.activeViewport = -1;\r\n        this.aViewports = [];\r\n        this.lastRenderTime = (new Date).getTime();\r\n        this.lastMemUsageLogTime = (new Date).getTime();\r\n        this.uMemUsageLoggingFrequency = 0;\r\n        this.nMousePrevX = 0;\r\n        this.nMousePrevY = 0;\r\n        this.mouseDownButtons = 0;\r\n        this.bEdit = false;\r\n\r\n    }\r\n\r\n    renderLoadingMessage() {\r\n        return (\r\n            <div className={cn.LoadingMessage}>\r\n                Map core SDK is Loading...\r\n            </div>\r\n        )\r\n    }\r\n\r\n    renderRow(label, value) {\r\n        return (\r\n            <div className={cn.DescRow}>\r\n                <span className={cn.DescLabel}>{label}:</span>\r\n                <span className={cn.DescValue}>{value}</span>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    onSelectOtherMapClicked = () => {\r\n        this.setState({ isSwitchMapFormOpen: true });\r\n    }\r\n\r\n    showHideDtmActionClicked = () => {\r\n        this.setState({ isDTMClicked: !this.state.isDTMClicked }, this.doDtmVisualization)\r\n    }\r\n\r\n    showHide3DActionClicked = () => {\r\n        this.setState(\r\n            {\r\n                is3DClicked: !this.state.is3DClicked\r\n            }, () => this.openMap(this.props.mapToShow.groupName, this.state.is3DClicked))\r\n    }\r\n    setTempAngle = (value) => {\r\n        this.TempOriginAngle = value;\r\n    }\r\n\r\n    setOriginAngle = () => {\r\n        const popupDetails = {\r\n            title: 'Set Origin Angle',\r\n            modalChild: 'SingleInputForm',\r\n            modalChildProps: {\r\n                size: 'small',\r\n                label: 'Set Angle(degrees ,North = 0):',\r\n                defaultValue: 0,\r\n                onValueChange: this.setTempAngle\r\n            },\r\n            onCloseButtonClick: () => {\r\n            },\r\n            primayButton: {\r\n                title: 'Set Origin',\r\n                callback: () => this.SetWorkingOrigin()\r\n            },\r\n            secondaryButton: {\r\n                title: 'Cancel',\r\n                callback: () => this.setTempAngle(0)\r\n            }\r\n        };\r\n        this.props.showPopup(popupDetails);\r\n    }\r\n\r\n    onMoreActionsClick = (e) => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        const selectOtherMapAction = {\r\n            name: \"Select Other Map\",\r\n            func: this.onSelectOtherMapClicked,\r\n            iconCss: \"Map\"\r\n        };\r\n\r\n        const menuItemsList = [];\r\n\r\n        const dtmLayer = this.props.mapToShow.layers.find(layer => layer.type.toLowerCase().includes('dtm'));\r\n\r\n        if (true) {\r\n            const showHideDtmAction = {\r\n                name: (this.state.isDTMClicked ? 'Hide' : 'Show') + \" DTM visualization\",\r\n                func: () => this.showHideDtmActionClicked(),\r\n                iconCss: \"DTM\"\r\n            }\r\n            const selectOrigin = {\r\n                name: \"Select Origin\",\r\n                func: () => this.setOriginAngle(),\r\n                iconCss: \"AddMapLocation\"\r\n            }\r\n            const showHide3DAction = {\r\n                name: 'Switch To ' + (this.state.is3DClicked ? '2D' : '3D'),\r\n                func: this.showHide3DActionClicked,\r\n                iconCss: \"ThreeD\"\r\n            }\r\n\r\n            menuItemsList.push(showHideDtmAction);\r\n            menuItemsList.push(showHide3DAction);\r\n            menuItemsList.push(selectOrigin);\r\n            menuItemsList.push(selectOtherMapAction);\r\n        }\r\n\r\n        this.props.showContextMenu(e.nativeEvent.x, e.nativeEvent.y, menuItemsList);\r\n    }\r\n\r\n    renderMapToolbox() {\r\n        return (\r\n            <div className={`${cn.MapToolbox}`}>\r\n                <div className={cn.Description}>\r\n                    {this.props.mapToShow.groupName}\r\n                </div>\r\n                <span className={cn.MoreActionsBtn} onClick={this.onMoreActionsClick}></span>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    renderSwitchMapForm() {\r\n        const isOpenClass = this.state.isSwitchMapFormOpen ? cn.Open : '';\r\n        return (\r\n            <div className={`${cn.SwitchMapForm} ${isOpenClass}`}>\r\n                {isOpenClass ? <SwitchMapForm onCancel={() => this.setState({ isSwitchMapFormOpen: false })} /> : null}\r\n            </div>\r\n        )\r\n    }\r\n\r\n    getCanvas() {\r\n        let zIndex = this.props.isPointSelectionMode ? { zIndex: 100, width: \"100%\" } : {};\r\n\r\n        return (\r\n            <div className={cn.MapWrapper} style={zIndex}>\r\n                <div className={cn.CanvasContainer} id='canvasesContainer'></div>\r\n                {this.renderMapToolbox()}\r\n                {this.renderSwitchMapForm()}\r\n            </div>\r\n        );\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={cn.Wrapper}>\r\n                {this.props.isMapCoreSDKLoaded ? this.getCanvas() : this.renderLoadingMessage()}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        isMapCoreSDKLoaded: state.map.isMapCoreSDKLoaded,\r\n        mapToShow: state.map.mapToShow,\r\n        dronesPositions: state.map.dronesPositions,\r\n        isPointSelectionMode: state.layout.isPointSelectionMode,\r\n        savedMissionPlan: state.planner.savedMissionPlan,\r\n        draftMissionStages: state.planner.draftMissionStages,\r\n        viewerState: state.planner.viewerState,\r\n        selectedDrone: state.map.selectedDrone\r\n    };\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        showContextMenu: (x, y, items) => dispatch({ type: actionTypes.SHOW_CONTEXT_MENU, payload: { x, y, items } }),\r\n        closeContextMenu: () => dispatch({ type: actionTypes.CLOSE_CONTEXT_MENU }),\r\n        showPopup: details => dispatch({ type: actionTypes.SHOW_POPUP, payload: details }),\r\n        saveOriginCoordinate: (coordinate, angle) => dispatch({ type: actionTypes.SAVE_ORIGIN_COORDINATE, payload: { coordinate, angle } }),\r\n        deleteDronePosition: () => dispatch({ type: actionTypes.DELETE_DRONE_POSITION }),\r\n        togglePointSelectionMode: () => dispatch({ type: actionTypes.TOGGLE_POINT_SELECTION_MODE }),\r\n        selectPointFromMap: (pointFromMap) => dispatch({ type: actionTypes.SELECT_POINT_FROM_MAP, payload: { pointFromMap } }),\r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(MapContainer);","C:\\mapCoreDrones\\wasp\\src\\components\\Video\\Video.js",["297","298"],"import React, { Component } from 'react';\r\nimport cn from './Video.module.css';\r\nimport { connect } from 'react-redux';\r\nimport actions from '../../store/actions';\r\nimport actionTypes from '../../store/actions/actionTypes';\r\nimport externalConfig from '../../ExternalConfigurationHandler';\r\nimport config, { devVideoSnapshotUrl, devVideoStreamUrl } from '../../config';\r\nimport targetIcon from '../../assets/images/target.svg';\r\nimport Slider from '../controls/Slider/Slider';\r\n\r\n\r\nclass Video extends Component {\r\n\r\n    state = {\r\n        isImageLoadingError: false,\r\n        isImageLoading: true,\r\n        isFullScreen: false,\r\n        targetPosition: null,\r\n        showTarget: true,\r\n        showExposure: false,\r\n        isRecording: false\r\n\r\n    }\r\n\r\n    componentDidMount() {\r\n        //window.addEventListener('resize', this.setTargetPosition)\r\n    }\r\n\r\n    getVideoSrc() {\r\n        console.log(\"render video\",this.props.selectedDrone );\r\n        const {DRONES_DATA} = externalConfig.getConfiguration();\r\n        const ip = `//${DRONES_DATA.segment}.${this.props.selectedDrone}:${DRONES_DATA.port}`;\r\n        const snapshotUrl = `${ip}${config.urls.videoSnapshot}`;\r\n        const streamUrl =`${ip}${config.urls.videoStream}`;\r\n\r\n        if (this.props.isPaused) {\r\n            return process.env.NODE_ENV === 'developments' ? devVideoSnapshotUrl : snapshotUrl;\r\n        } else {\r\n            return process.env.NODE_ENV === 'developments' ? devVideoStreamUrl : streamUrl;\r\n        }\r\n    }\r\n\r\n    onVideoError = (e) => {\r\n        console.log('error when trying to load camera video', e);\r\n        this.setState({\r\n            isImageLoadingError: true\r\n        })\r\n    }\r\n\r\n    setTargetPosition = () => {\r\n        const img = document.getElementById('droneImage');\r\n        if (!img) return;\r\n        const rect = img.getBoundingClientRect();\r\n        if (!rect) return;\r\n\r\n        this.setState({\r\n            targetPosition: {\r\n                top: rect.top + (rect.height / 2),\r\n                left: rect.left + (rect.width / 2)\r\n            }\r\n        })\r\n    }\r\n\r\n    onVideoLoaded = e => {\r\n        //this.setTargetPosition();\r\n        this.setState({\r\n            isImageLoading: false\r\n        })\r\n    }\r\n\r\n    onPauseOrPlayClick = e => {\r\n        e.stopPropagation();\r\n        this.props.isPaused ? this.props.resume() : this.props.pause()\r\n    }\r\n\r\n    onFullScreenClick = () => {\r\n        //const elem = document.querySelector('#droneImage');\r\n        const elem = document.querySelector('#videoWrapper');\r\n        if (elem.requestFullscreen) {\r\n            elem.requestFullscreen();\r\n        } else if (elem.webkitRequestFullscreen) { /* Safari */\r\n            elem.webkitRequestFullscreen();\r\n        } else if (elem.msRequestFullscreen) { /* IE11 */\r\n            elem.msRequestFullscreen();\r\n        }\r\n        this.setState({ isFullScreen: true })\r\n    }\r\n\r\n    onExitFullScreenClick = () => {\r\n        // bug when we are in full screen and click on ESC key\r\n        if (document.fullscreenElement === null) {\r\n            this.onFullScreenClick();\r\n        } else {\r\n            if (document.exitFullscreen) {\r\n                document.exitFullscreen();\r\n            } else if (document.webkitExitFullscreen) { /* Safari */\r\n                document.webkitExitFullscreen();\r\n            } else if (document.msExitFullscreen) { /* IE11 */\r\n                document.msExitFullscreen();\r\n            }\r\n            this.setState({ isFullScreen: false })\r\n        }\r\n    }\r\n\r\n    getPlayOrPauseButton() {\r\n        return this.props.isPaused ? cn.Play : cn.Pause\r\n    }\r\n\r\n    getPlayOrPauseTitle() {\r\n        return this.props.isPaused ? 'Play' : 'Pause'\r\n    }\r\n\r\n    getRecordButton = () => {\r\n        return this.state.isRecording ? cn.RecordindIcon : cn.RecordIcon\r\n    }\r\n\r\n    getRecordTitle = () => {\r\n        return this.state.isRecording ? 'Recording' : 'Start Recording'\r\n    }\r\n\r\n    renderVideoHeader() {\r\n        const hideTargetClass = this.state.showTarget ? '' : cn.HideTarget;\r\n        return (\r\n            <div className={`${cn.VideoHeader}`}>\r\n                <div className={cn.Description}>\r\n                    {this.props.isPaused ? 'Video paused' :\r\n                        <span className={cn.StreamingIconWrapper}>Video Feed<span className={cn.StreamingIcon} /></span>\r\n                    }\r\n                </div>\r\n                <span className={`${cn.Exposure}`}\r\n                    onClick={() => this.setState({ showExposure: !this.state.showExposure })}>\r\n                </span>\r\n                {this.props.weaponDetected && <span className={`${cn.ToggleTarget} ${hideTargetClass}`}\r\n                    onClick={() => this.setState({ showTarget: !this.state.showTarget })}>\r\n                </span>\r\n                }\r\n            </div>\r\n        )\r\n    }\r\n\r\n    renderVideoFooter() {\r\n        return (\r\n            <>\r\n                <button\r\n                    onClick={this.onPauseOrPlayClick}\r\n                    title={this.getPlayOrPauseTitle()}\r\n                    className={`${cn.ControlBtn} ${this.getPlayOrPauseButton()}`}>\r\n                </button>\r\n                <button\r\n                    onClick={() => this.setState({ isRecording: !this.state.isRecording })}\r\n                    title={this.getRecordTitle()}\r\n                    className={`${cn.ControlBtn} ${cn.RecordButton}`}>\r\n                    <span className={`${this.getRecordButton()}`} />\r\n                </button>\r\n                <button\r\n                    onClick={this.state.isFullScreen ? this.onExitFullScreenClick : this.onFullScreenClick}\r\n                    title={this.state.isFullScreen ? 'Exit Full Screen' : 'Full Screen'}\r\n                    className={`${cn.ControlBtn} ${this.state.isFullScreen ? cn.ExitFullScreen : cn.FullScreen}`}>\r\n                </button>\r\n            </>\r\n        )\r\n    }\r\n\r\n    updateExposure(sliderOffset) {\r\n        const exposureValue = config.EXPOSURE_MAX_LEVEL * (100 - sliderOffset) / 100;\r\n        console.log(\"new exposureValue is \", exposureValue);\r\n        this.setState({ sliderOffset });\r\n        this.props.setExposure(exposureValue)\r\n    }\r\n\r\n    renderImgElement() {\r\n\r\n        if (this.state.isImageLoadingError) {\r\n            return (\r\n                <div className={cn.ErrorMessage}><span className={cn.ErrorIcon}></span> Error loading video stream</div>\r\n            )\r\n        }\r\n        const largeTarget = this.state.isFullScreen ? ` ${cn.TargetLarge}` : '';\r\n        return (\r\n            <>\r\n                {this.renderVideoHeader()}\r\n\r\n                {this.state.showTarget && this.props.weaponDetected &&\r\n                    <img className={`${cn.TargetIcon}${largeTarget}`} style={this.state.targetPosition} src={targetIcon} />\r\n                }\r\n\r\n                {this.state.showExposure &&\r\n                    <Slider sliderOffset={this.state.sliderOffset} updatePosition={(offset) => this.updateExposure(offset)} />\r\n                }\r\n\r\n                <img\r\n                    key={this.props.selectedDrone}\r\n                    crossOrigin=\"anonymous\"\r\n                    onLoad={this.onVideoLoaded}\r\n                    className={cn.VideoImage}\r\n                    src={this.getVideoSrc()}\r\n                    id='droneImage'\r\n                    onClick={this.props.pointVideoImage}\r\n                //onTouchStart={this.props.pointVideoImage}\r\n                />\r\n                {this.renderVideoFooter()}\r\n            </>\r\n        )\r\n    }\r\n\r\n    render() {\r\n        const fullHeightClass = this.state.isImageLoadingError || this.state.isImageLoading ? cn.FullHeight : '';\r\n        return (\r\n            <div className={`${cn.Wrapper} ${fullHeightClass}`} id='videoWrapper'>\r\n                {this.renderImgElement()}\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        isPaused: state.video.isPaused,\r\n        weaponDetected: state.output.weaponDetected,\r\n        selectedDrone: state.map.selectedDrone\r\n    };\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        pointVideoImage: e => dispatch(actions.pointVideoImage(e)),\r\n        setExposure: exposureValue => dispatch(actions.setExposure(exposureValue)),\r\n        pause: () => dispatch({ type: actionTypes.PAUSE_VIDEO }),\r\n        resume: () => dispatch({ type: actionTypes.RESUME_VIDEO }),\r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(Video);\r\n\r\n\r\n","C:\\mapCoreDrones\\wasp\\src\\components\\OutputTabs\\OutputTabs.js",["299","300","301","302","303","304","305","306","307","308","309"],"import React, { Component } from 'react'\r\nimport cn from './OutputTabs.module.css'\r\nimport WeaponDetection from '../../assets/images/WeaponDetection.png';\r\nimport externalConfig from '../../ExternalConfigurationHandler';\r\nimport actions from '../../store/actions';\r\nimport config, { devVideoSnapshotUrl, devVideoStreamUrl } from '../../config';\r\nimport { connect } from 'react-redux';\r\nimport EnemySpottedSound from '../../assets/EnemySpotted.mp3';\r\nimport ArmedRed from '../../assets/images/armedRed.svg';\r\nimport rosWebSocket from '../../rosWebsocket';\r\n\r\nclass OutputTabs extends Component {\r\n\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            pointPosition: null,\r\n            showCapture: true,\r\n            selectedTab: \"WindowDetection\"\r\n        }\r\n        this.EnemySpotted = new Audio(EnemySpottedSound);\r\n\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        window.removeEventListener('resize', this.onImageLoaded())\r\n    }\r\n\r\n    onImageLoaded = (e) => {\r\n        if (!this.props.imageSentToDroneData || !this.props.imageSentToDroneData.point) {\r\n            console.log(\"Error, this.props.imageSentToDroneData.point as it is undefined\");\r\n            return;\r\n        }\r\n\r\n        const tabsWrapper = document.getElementById('tabs-wrapper');\r\n\r\n        const img = e.target;\r\n        const xFactor = img.naturalWidth / tabsWrapper.getBoundingClientRect().width;\r\n        const yFactor = img.naturalHeight / tabsWrapper.getBoundingClientRect().height;\r\n        const { roundedX, roundedY } = this.props.imageSentToDroneData.point;\r\n        this.setState({\r\n            pointPosition: {\r\n                top: roundedY / yFactor,\r\n                left: roundedX / xFactor,\r\n            }\r\n        })\r\n\r\n    }\r\n\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.imageSentToDroneData !== this.props.imageSentToDroneData) {\r\n            const img = document.createElement('img');\r\n            img.onload = this.onImageLoaded;\r\n            img.src = this.props.imageSentToDroneData.image;\r\n            window.addEventListener('resize', () => this.onImageLoaded({ target: img }))\r\n        }\r\n\r\n        if (prevProps.weaponDetected !== this.props.weaponDetected) {\r\n            this.EnemySpotted.play();\r\n            this.onToggleTabClick(\"Skeleton\");\r\n        }\r\n\r\n        if ((prevProps.skeletonRange === 'N/A' && this.props.skeletonRange !== 'N/A') ||\r\n            (!prevProps.indoorExplorationFlag && this.props.indoorExplorationFlag)) {\r\n            this.onToggleTabClick(\"Skeleton\");\r\n        }\r\n\r\n        if (this.props.selectedTab === 'Occupancy' && this.props.selectedDrone !== prevProps.selectedDrone) {\r\n            /*const viewer = new window.ROS2D.Viewer({\r\n                divID: 'occupancyTab',\r\n                width: 600,\r\n                height: 500\r\n            });\r\n            const gridClient =  new window.ROS2D.OccupancyGridClient({\r\n                ros: rosWebSocket.getRosWebsocketObject(this.props.selectedDrone),\r\n                rootObject: viewer.scene\r\n            });\r\n            gridClient.on('change', function () {\r\n                viewer.scaleToDimensions(gridClient.currentGrid.width, gridClient.currentGrid.height);\r\n            });*/\r\n        }\r\n    }\r\n\r\n    renderTabs() {\r\n\r\n        let imageElement = null;\r\n        let pointElement = null;\r\n\r\n        const imageDataUrl = this.props.imageSentToDroneData && this.props.imageSentToDroneData.image;\r\n        const point = this.props.imageSentToDroneData && this.props.imageSentToDroneData.point;\r\n        if (imageDataUrl && point) {\r\n            imageElement = <img className={cn.OutputImage} src={imageDataUrl} />\r\n            pointElement = <div className={cn.Point} style={this.state.pointPosition}></div>\r\n        }\r\n        return (<>\r\n            { imageElement}\r\n            { pointElement}\r\n        </>\r\n        );\r\n    }\r\n\r\n    renderNoOutputReceived() {\r\n        return <div className={cn.ErrorMessage}><span className={cn.ErrorIcon}></span> No output has been received yet</div>\r\n    }\r\n\r\n    onToggleTabClick = (selectedTab) => {\r\n        this.setState({ selectedTab });\r\n    }\r\n\r\n    renderTabsToggle = () => {\r\n        const selectedTab = this.state.selectedTab;\r\n        return (<>\r\n            <div className={cn.tabslidernav} >\r\n                <ul className={cn.tabslidertabs} >\r\n                    <li className={`${cn.tabslidertrigger} ${selectedTab == \"Capture\" ? cn.TabSelected : \"\"}`}\r\n                        onClick={() => this.onToggleTabClick(\"Capture\")}>\r\n                        Capture\r\n                    </li>\r\n                    <li className={`${cn.tabslidertrigger} ${selectedTab == \"Skeleton\" ? cn.TabSelected : \"\"}`}\r\n                        onClick={() => this.onToggleTabClick(\"Skeleton\")}>\r\n                        Skeleton\r\n                    </li>\r\n                    <li className={`${cn.tabslidertrigger} ${selectedTab == \"WindowDetection\" ? cn.TabSelected : \"\"}`}\r\n                        onClick={() => this.onToggleTabClick(\"WindowDetection\")}>\r\n                        Window\r\n                    </li>\r\n                    <li className={`${cn.tabslidertrigger} ${selectedTab == \"Occupancy\" ? cn.TabSelected : \"\"}`}\r\n                        onClick={() => this.onToggleTabClick(\"Occupancy\")}>\r\n                        Occupancy\r\n                    </li>\r\n                </ul>\r\n            </div>\r\n\r\n        </>)\r\n\r\n    }\r\n\r\n    getCaptureTab() {\r\n        return this.props.imageSentToDroneData ? this.renderTabs() : this.renderNoOutputReceived();\r\n    }\r\n\r\n    getSkeletonRange() {\r\n        if (this.props.skeletonRange && this.props.skeletonRange !== 'N/A') {\r\n            return `${this.props.skeletonRange} m`;\r\n        }\r\n        return this.props.skeletonRange;\r\n    }\r\n\r\n    getSkeletonTab() {\r\n        let weaponDetectedClass = this.props.weaponDetected ? cn.WeaponDetected : undefined;\r\n        return (<div className={`${cn.SkeletonTab} ${weaponDetectedClass}`} >\r\n            <img\r\n                key={\"skeleton\" + this.props.selectedDrone}\r\n                crossOrigin=\"anonymous\"\r\n                //    onLoad={this.onVideoLoaded}\r\n                //   onError={this.onVideoError}\r\n                className={cn.VideoImage}\r\n                src={this.getSkeletonVideoSrc()}\r\n                id='droneImage'\r\n            //    onClick={this.props.pointVideoImage}\r\n            />\r\n            {this.props.weaponDetected && <img className={`${cn.AlertIcon}`} src={ArmedRed} />}\r\n            { this.props.skeletonRange && <span className={`${cn.SkeletonRange}`} > {this.getSkeletonRange()} </span>}\r\n        </div>)\r\n    }\r\n\r\n    getWindowDetectionTab() {\r\n        return (<div className={`${cn.WindowTab}`} >\r\n            <img\r\n                key={\"window\" + this.props.selectedDrone}\r\n                crossOrigin=\"anonymous\"\r\n                //    onLoad={this.onVideoLoaded}\r\n                //   onError={this.onVideoError}\r\n                className={cn.VideoImage}\r\n                src={this.getWindowDetectionVideoSrc()}\r\n                id='droneImage'\r\n            //    onClick={this.props.pointVideoImage}\r\n            />\r\n            <span className={`${cn.AlertIcon}`} />\r\n        </div>)\r\n    }\r\n\r\n    getOccupancyTab() {\r\n        return (<div id=\"occupancyTab\"/>);\r\n    }\r\n\r\n    \r\n\r\n    getWindowDetectionVideoSrc() {\r\n        const { DRONES_DATA } = externalConfig.getConfiguration();\r\n        const ip = `//${DRONES_DATA.segment}.${this.props.selectedDrone}:${DRONES_DATA.port}`;\r\n        const snapshotUrl = `${ip}${config.urls.windowDetectionSnapshot}`;\r\n        const streamUrl = `${ip}${config.urls.windowDetectionStream}`;\r\n\r\n        if (this.props.isPaused) {\r\n            return process.env.NODE_ENV === 'developments' ? devVideoSnapshotUrl : snapshotUrl;\r\n        } else {\r\n            return process.env.NODE_ENV === 'developments' ? devVideoStreamUrl : streamUrl;\r\n        }\r\n    }\r\n    getSkeletonVideoSrc() {\r\n        const { DRONES_DATA } = externalConfig.getConfiguration();\r\n        const ip = `//${DRONES_DATA.segment}.${this.props.selectedDrone}:${DRONES_DATA.port}`;\r\n        const snapshotUrl = `${ip}${config.urls.skeletonSnapshot}`;\r\n        const streamUrl = `${ip}${config.urls.skeletonStream}`;\r\n\r\n        if (this.props.isPaused) {\r\n            return process.env.NODE_ENV === 'developments' ? devVideoSnapshotUrl : snapshotUrl;\r\n        } else {\r\n            return process.env.NODE_ENV === 'developments' ? devVideoStreamUrl : streamUrl;\r\n        }\r\n    }\r\n\r\n    getSelectedTab() {\r\n        switch (this.state.selectedTab) {\r\n            case \"Capture\":\r\n                return this.getCaptureTab();\r\n            case \"Skeleton\":\r\n                return this.getSkeletonTab();\r\n            case \"Occupancy\":\r\n                return this.getOccupancyTab();\r\n            case \"WindowDetection\":\r\n                return this.getWindowDetectionTab();\r\n            default:\r\n                return \"\";\r\n        }\r\n    }\r\n\r\n    render() {\r\n\r\n        return (\r\n            <div className={cn.Wrapper}>\r\n                {this.renderTabsToggle()}\r\n                <div className={cn.Tabs} id='tabs-wrapper'>\r\n                    {this.getSelectedTab()}\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        tabs: state.video.tabs,\r\n        imageSentToDroneData: state.layout.imageSentToDroneData,\r\n        skeletonRange: state.output.skeletonRange,\r\n        weaponDetected: state.output.weaponDetected,\r\n        indoorExplorationFlag: state.output.indoorExplorationFlag,\r\n        selectedDrone: state.map.selectedDrone\r\n    };\r\n};\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n\r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(OutputTabs);","C:\\mapCoreDrones\\wasp\\src\\store\\actions\\mapActions.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\plannerActions.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\outputActions.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\layoutActions.js",[],"C:\\mapCoreDrones\\wasp\\src\\store\\actions\\videoActions.js",["310","311"],"C:\\mapCoreDrones\\wasp\\src\\components\\SingleInputForm\\SingleInputForm.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\AddMissionPlanStageForm\\AddMissionPlanStageForm.js",["312","313","314","315","316","317","318","319"],"import React, { Component } from 'react'\r\nimport cn from './AddMissionPlanStageForm.module.css';\r\nimport Select from '../../controls/Select/Select';\r\nimport Input from '../../controls/Input/Input';\r\n\r\nexport default class AddMissionPlanStageForm extends Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.state = {\r\n            selectedStageType: props.stage && props.stage.selectedStageType || null,\r\n            stageParamsInput: props.stage && props.stage.stageParamsInput || '',\r\n            multiParamsInput: this.parseMultiParams() || {},\r\n            stageId: props.stage && props.stage.stageId || Math.round(Math.random() * 100000),\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        if (this.props.onPopupInitalLoad) {\r\n            this.props.onPopupInitalLoad(this.getMissionPlanState);\r\n        }\r\n    }\r\n    componentDidUpdate(prevProps) {\r\n        if (prevProps.pointFromMap != this.props.pointFromMap) {\r\n            const pointFromMap = this.props.pointFromMap;\r\n            const stageParamsInput = pointFromMap.x + \",\" +pointFromMap.y + \",\" + pointFromMap.z;\r\n            this.setState({ multiParamsInput: pointFromMap , stageParamsInput })\r\n        }\r\n    }\r\n    parseMultiParams = () => {\r\n        if (this.props.stage && this.props.stage.stageParamsInput!=\"\") {\r\n            const [x, y, z] = this.props.stage.stageParamsInput.split(',');\r\n            return {x,y,z};\r\n        }\r\n        else{\r\n            return null\r\n        }\r\n    }\r\n    getMissionPlanState = () => {\r\n        return this.state;\r\n    }\r\n\r\n    handleTypeChange(selectedStageType) {\r\n        this.setState({\r\n            selectedStageType,\r\n            stageParamsInput: '',\r\n            multiParamsInput: {}\r\n        });\r\n    }\r\n\r\n\r\n    renderStageType() {\r\n        const options = [\r\n            { label: 'Takeoff', params: { label: 'Height:', placeHolder: \"meters\" }, rossService: 'addMissionTakeoff' },\r\n            { label: 'Go To Waypoint', isMultiInputs: true, params: { label: 'Waypoint Coordinate:', }, rossService: 'addMissionWP' },\r\n            { label: 'Pause', params: { label: 'Pause for:', placeHolder: \"seconds\" } },\r\n            { label: 'Set Speed', params: { label: 'Speed Value:', placeHolder: \"km/h\" } },\r\n            { label: 'Set Waypoint Radius', params: { label: 'Radius Value:', placeHolder: \"meters\" } },\r\n        ]\r\n\r\n        const dropDownData = {\r\n            label: 'Select Stage Type:',\r\n            defaultValue: this.state.selectedStageType || { label: \"Select...\", value: \"Select...\" },\r\n            options,\r\n            onChange: selectedTypeValue => this.handleTypeChange(selectedTypeValue)\r\n        };\r\n\r\n\r\n        return (\r\n            <div className={cn.Row}>\r\n                <Select {...dropDownData} />\r\n            </div>\r\n        )\r\n    }\r\n    onInputChange(e, subField) {\r\n        let { stageParamsInput, multiParamsInput } = this.state;\r\n        if (subField) {\r\n\r\n            multiParamsInput[subField] = e.target.value;\r\n            stageParamsInput = multiParamsInput.x + \",\" + multiParamsInput.y + \",\" + multiParamsInput.z;\r\n        }\r\n        else {\r\n            stageParamsInput = e.target.value;\r\n        }\r\n        this.setState({ stageParamsInput, multiParamsInput });\r\n\r\n    }\r\n\r\n    renderStageInput() {\r\n        if (!this.state.selectedStageType ||\r\n            !this.state.selectedStageType.params) {\r\n            return;\r\n        }\r\n\r\n        const { selectedStageType, stageParamsInput, multiParamsInput } = this.state;\r\n\r\n\r\n        return (\r\n            <div className={cn.Row}>\r\n                <span className={`${cn.Label}`}>{this.state.selectedStageType.label + \":\"}</span>\r\n                <div className={cn.InputWrapper}>\r\n                    {selectedStageType.isMultiInputs ?\r\n                        <>\r\n                            <span className={`${cn.Icon} ${cn.PositionIcon}`} title=\"Select On Map\" onClick={this.props.selectPointFromMap} />\r\n                            {this.getInputField(multiParamsInput.x, 'x')}\r\n                            {this.getInputField(multiParamsInput.y, 'y')}\r\n                            {this.getInputField(multiParamsInput.z, 'z')}\r\n                        </>\r\n                        :\r\n                        this.getInputField(stageParamsInput)\r\n                    }\r\n                </div>\r\n            </div>\r\n        )\r\n\r\n    }\r\n\r\n    getInputField = (value, subField) => {\r\n        const selectedStageType = this.state.selectedStageType;\r\n        return (\r\n            <div className={cn.InnerInputWrapper}>\r\n                <Input\r\n                    parentRef={this.inputRef}\r\n                    value={value !== null && value !== undefined? value : \"\"}\r\n                    onChange={e => this.onInputChange(e, subField)}\r\n                    disabled={false}\r\n                    type={selectedStageType.params.type || \"\"}\r\n                    placeHolder={subField || selectedStageType.params.placeHolder || \"\"}\r\n                    button={selectedStageType.params.button || null}\r\n                />\r\n            </div>\r\n        )\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className={cn.Wrapper}>\r\n                {this.renderStageType()}\r\n                {this.renderStageInput()}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","C:\\mapCoreDrones\\wasp\\src\\components\\MissionPlanner\\MissionPlanStages\\MissionPlanStage.js",["320"],"import React, { Component } from 'react'\r\nimport { connect } from 'react-redux'\r\nimport cn from './MissionPlanStages.module.css';\r\nimport actionTypes from '../../../store/actions/actionTypes';\r\n\r\nclass MissionPlanStage extends Component {\r\n\r\n    renderMenuBtnIcon() {\r\n        return (\r\n            <span className={cn.BtnIconWrapper}>\r\n                <span className={cn.BtnIconBall}></span>\r\n                <span className={cn.BtnIconBall}></span>\r\n                <span className={cn.BtnIconBall}></span>\r\n            </span>\r\n        )\r\n    }\r\n\r\n    addOrEditMissionPlanStageFormPopupOkBtnClick = (isAddStage) => {\r\n        const addOrEditStageFormState = this.getAddMissionPlanStageFormState();\r\n        if (addOrEditStageFormState.selectedStageType) {\r\n            if (isAddStage) {\r\n                this.props.addNewStage(addOrEditStageFormState);\r\n            } else {\r\n                this.props.editStage(addOrEditStageFormState, this.props.stageIndex);\r\n            }\r\n        }\r\n    }\r\n\r\n    selectPointFromMap = () => {\r\n        this.props.togglePointSelectionMode();\r\n    }\r\n\r\n    onAddOrEditStageBtnClicked = (isAddStage = false) => {\r\n        const popupDetails = {\r\n            title: isAddStage ? 'Add New Stage' : `Edit Stage #${this.props.stageIndex + 1} `,\r\n            modalChild: 'AddMissionPlanStageForm',\r\n            modalChildProps: {\r\n                stage: isAddStage ? null : this.props.stage,\r\n                size: 'small',\r\n                onPopupInitalLoad: getChildState => this.getAddMissionPlanStageFormState = getChildState,\r\n                selectPointFromMap: this.selectPointFromMap,\r\n\r\n            },\r\n            onCloseButtonClick: () => { },\r\n            primayButton: {\r\n                title: 'Done',\r\n                callback: () => this.addOrEditMissionPlanStageFormPopupOkBtnClick(isAddStage)\r\n            },\r\n            secondaryButton: {\r\n                title: 'Cancel',\r\n                callback: () => { }\r\n            }\r\n        };\r\n        this.props.showPopup(popupDetails);\r\n    }\r\n\r\n    onMenuBtnClick = e => {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        const menuItemsList = [\r\n            {\r\n                name: \"Delete\",\r\n                func: () => this.props.deleteStage(this.props.stage.stageId),\r\n                iconCss: \"DeleteIcon\"\r\n            },\r\n            {\r\n                name: \"Edit\",\r\n                func: this.onAddOrEditStageBtnClicked,\r\n                iconCss: \"EditIcon\"\r\n            },\r\n            {\r\n                name: \"Move Back\",\r\n                func: () => this.props.moveStageDown(this.props.stageIndex),\r\n                iconCss: \"ArrowDownIcon\"\r\n            },\r\n            {\r\n                name: \"Move Forward\",\r\n                func: () => this.props.moveStageUp(this.props.stageIndex),\r\n                iconCss: \"ArrowUpIcon\"\r\n            },\r\n        ];\r\n\r\n        this.props.showContextMenu(e.clientX, e.clientY, { side: 'left' }, menuItemsList);\r\n    }\r\n\r\n    renderAddNewStageBtn() {\r\n        if (this.props.isShowAddStageBtn) {\r\n            return <button className={cn.AddNewStageBtn} onClick={() => this.onAddOrEditStageBtnClicked(true)}>+</button>\r\n        }\r\n        return false;\r\n    }\r\n\r\n    renderMenuBtn() {\r\n        const { isShowMenu } = this.props;\r\n        if (!isShowMenu) return null;\r\n        return (\r\n            <button className={cn.MenuBtn} onClick={this.onMenuBtnClick}>{this.renderMenuBtnIcon()}</button>\r\n        )\r\n    }\r\n\r\n    render() {\r\n        const { selectedStageType, stageParamsInput } = this.props.stage;\r\n        let params = stageParamsInput;\r\n        if (selectedStageType.label == \"Go To Waypoint\") {\r\n            const [x, y, z] = stageParamsInput.split(',');\r\n            params = `x: ${x.split(\".\")[0]}\\ny: ${y.split(\".\")[0]}\\nz: ${z.split(\".\")[0]}`\r\n        }\r\n        return (\r\n            <div className={cn.StageWrapper} style={this.props.isShowMenu ? {opacity: 0.6} : {}}>\r\n                {this.renderMenuBtn()}\r\n                <div className={cn.LabelsWrapper}>\r\n                    <div className={cn.StageTypeLabel}>{selectedStageType.label}</div>\r\n                    <div className={cn.StageParamsLabel}>{params}</div>\r\n                </div>\r\n                {this.renderAddNewStageBtn()}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nconst mapStateToProps = (state) => ({\r\n\r\n})\r\n\r\nconst mapDispachToProps = (dispatch) => {\r\n    return {\r\n        showPopup: details => dispatch({ type: actionTypes.SHOW_POPUP, payload: details }),\r\n        togglePointSelectionMode: () => dispatch({ type: actionTypes.TOGGLE_POINT_SELECTION_MODE }),\r\n        showContextMenu: (x, y, options, items) => dispatch({ type: actionTypes.SHOW_CONTEXT_MENU, payload: { x, y, options, items } }),\r\n        deleteStage: id => dispatch({ type: actionTypes.DELETE_MISSION_PLAN_STAGE, payload: { id } }),\r\n        editStage: (stage, index) => dispatch({ type: actionTypes.EDIT_MISSION_PLAN_STAGE, payload: { stage, stageIndex: index } }),\r\n        moveStageDown: (index) => dispatch({ type: actionTypes.MOVE_DOWN_MISSION_PLAN_STAGE, payload: index }),\r\n        moveStageUp: (index) => dispatch({ type: actionTypes.MOVE_UP_MISSION_PLAN_STAGE, payload: index }),\r\n        addNewStage: stage => dispatch({ type: actionTypes.ADD_NEW_MISSION_PLAN_STAGE, payload: stage }),\r\n    };\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispachToProps)(MissionPlanStage)\r\n","C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Slider\\Slider.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\SwitchMapForm\\SwitchMapForm.js",[],"C:\\mapCoreDrones\\wasp\\src\\utils\\imageUtils.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Input\\Input.js",["321","322","323","324","325","326"],"import React, { Component } from 'react'\r\nimport cn from './Input.module.css';\r\n//import validationX from '../../assets/images/close-red.svg';\r\n//import Tooltip from '../Tooltip/Tooltip';\r\n\r\nexport default class Input extends Component {\r\n    state = {\r\n        isShowInfoTooltip: false\r\n    }\r\n\r\n    showInfoTooltip = e => {\r\n        this.setState({ isShowInfoTooltip: true, clientX: e.target.getBoundingClientRect().left, clientY: e.target.getBoundingClientRect().top });\r\n    }\r\n\r\n    hideTooltip = () => this.setState({ isShowInfoTooltip: false, clientX: null, clientY: null })\r\n\r\n    renderInfo() {\r\n        if (this.props.info) {\r\n            return (\r\n                <span className={cn.InfoImage} onMouseEnter={this.showInfoTooltip} onMouseLeave={this.hideTooltip}>\r\n                    {/* {\r\n                        this.state.isShowInfoTooltip ? \r\n                            (<Tooltip \r\n                                title={this.props.info.title}\r\n                                text={this.props.info.text}\r\n                                x={this.state.clientX}\r\n                                y={this.state.clientY}\r\n                            />) : null\r\n                    } */}\r\n                </span>\r\n            )\r\n        }\r\n    }\r\n\r\n    getInputByType = () => {\r\n        const value = this.props.value;\r\n        switch (this.props.type) {\r\n            case \"Coordinate\":\r\n                return (\r\n                    <div className={cn.InnerInputWrapper}>\r\n                        {this.props.button && <span className={`${cn.Icon} ${cn.PositionIcon}`} title=\"Select On Map\" onClick={() => this.props.button.action()} />}\r\n                        {this.getInputField(value && value.x || \"\", 'X')}\r\n                        {this.getInputField(value && value.y || \"\", 'Y')}\r\n                        {this.getInputField(value && value.z || \"\", 'Z')}\r\n                    </div>)\r\n            default:\r\n                return this.getInputField(value, this.props.placeHolder);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    render() {\r\n        const mandatoyClass = this.props.mandatory ? ` ${cn.Mandatory}` : '';\r\n        const disabled = this.props.disabled ? ` ${cn.Disabled}` : '';\r\n        const errorClass = this.props.error ? ` ${cn.ShowError}` : '';\r\n        const readOnly = this.props.readOnly ? ` ${cn.readOnly}` : '';\r\n        return (\r\n            <div className={`${cn.Row}${disabled}`}>\r\n                <span className={`${cn.Label}${mandatoyClass}`}>{this.props.label}{this.renderInfo()}</span>\r\n                <div className={cn.InputWrapper}>\r\n                <div className={cn.InnerInputWrapper}>\r\n                    <input\r\n                        ref={this.props.parentRef || null}\r\n                        placeholder={this.props.placeHolder}\r\n                        value={this.props.value}\r\n                        name={this.props.name}\r\n                        className={`${cn.Input}${errorClass}${readOnly}`}\r\n                        maxLength={this.props.maxLength || null}\r\n                        type={this.props.type || 'text'}\r\n                        onFocus={this.props.onFocus}\r\n                        onChange={this.props.onChange}\r\n                        readOnly={this.props.readOnly || this.props.disabled} />\r\n                         </div>\r\n                    {/*<img className={`${cn.ValidationImg}${errorClass}`} src={validationX} alt=\"\"/>*/}\r\n                    <div className={`${cn.ValidationMessage}${errorClass}`}>{this.props.error || ''}</div>\r\n                </div>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n","C:\\mapCoreDrones\\wasp\\src\\services\\index.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\controls\\RadioGroup\\RadioGroup.js",[],"C:\\mapCoreDrones\\wasp\\src\\components\\controls\\Radio\\Radio.js",[],{"ruleId":"327","replacedBy":"328"},{"ruleId":"329","replacedBy":"330"},{"ruleId":"331","severity":1,"message":"332","line":1,"column":17,"nodeType":"333","messageId":"334","endLine":1,"endColumn":30},{"ruleId":"331","severity":1,"message":"335","line":14,"column":10,"nodeType":"333","messageId":"334","endLine":14,"endColumn":16},{"ruleId":"331","severity":1,"message":"336","line":14,"column":18,"nodeType":"333","messageId":"334","endLine":14,"endColumn":23},{"ruleId":"337","severity":1,"message":"338","line":102,"column":56,"nodeType":"339","messageId":"340","endLine":102,"endColumn":58},{"ruleId":"337","severity":1,"message":"338","line":105,"column":62,"nodeType":"339","messageId":"340","endLine":105,"endColumn":64},{"ruleId":"341","severity":1,"message":"342","line":44,"column":17,"nodeType":"343","endLine":44,"endColumn":81},{"ruleId":"344","severity":1,"message":"345","line":45,"column":21,"nodeType":"343","endLine":45,"endColumn":67},{"ruleId":"344","severity":1,"message":"345","line":31,"column":16,"nodeType":"343","endLine":31,"endColumn":60},{"ruleId":"331","severity":1,"message":"346","line":214,"column":15,"nodeType":"333","messageId":"334","endLine":214,"endColumn":19},{"ruleId":"341","severity":1,"message":"342","line":220,"column":21,"nodeType":"343","endLine":220,"endColumn":148},{"ruleId":"331","severity":1,"message":"347","line":2,"column":8,"nodeType":"333","messageId":"334","endLine":2,"endColumn":22},{"ruleId":"331","severity":1,"message":"347","line":3,"column":8,"nodeType":"333","messageId":"334","endLine":3,"endColumn":22},{"ruleId":"331","severity":1,"message":"348","line":1,"column":32,"nodeType":"333","messageId":"334","endLine":1,"endColumn":41},{"ruleId":"331","severity":1,"message":"349","line":8,"column":8,"nodeType":"333","messageId":"334","endLine":8,"endColumn":15},{"ruleId":"350","severity":1,"message":"351","line":51,"column":19,"nodeType":"352","messageId":"353","endLine":51,"endColumn":26,"fix":"354"},{"ruleId":"350","severity":1,"message":"351","line":66,"column":23,"nodeType":"352","messageId":"353","endLine":66,"endColumn":31,"fix":"355"},{"ruleId":"350","severity":1,"message":"351","line":67,"column":28,"nodeType":"352","messageId":"353","endLine":67,"endColumn":36,"fix":"356"},{"ruleId":"337","severity":1,"message":"357","line":113,"column":40,"nodeType":"339","messageId":"340","endLine":113,"endColumn":42},{"ruleId":"337","severity":1,"message":"357","line":117,"column":62,"nodeType":"339","messageId":"340","endLine":117,"endColumn":64},{"ruleId":"337","severity":1,"message":"357","line":120,"column":72,"nodeType":"339","messageId":"340","endLine":120,"endColumn":74},{"ruleId":"337","severity":1,"message":"357","line":131,"column":38,"nodeType":"339","messageId":"340","endLine":131,"endColumn":40},{"ruleId":"337","severity":1,"message":"338","line":134,"column":76,"nodeType":"339","messageId":"340","endLine":134,"endColumn":78},{"ruleId":"337","severity":1,"message":"338","line":142,"column":25,"nodeType":"339","messageId":"340","endLine":142,"endColumn":27},{"ruleId":"337","severity":1,"message":"357","line":143,"column":26,"nodeType":"339","messageId":"340","endLine":143,"endColumn":28},{"ruleId":"337","severity":1,"message":"357","line":143,"column":71,"nodeType":"339","messageId":"340","endLine":143,"endColumn":73},{"ruleId":"337","severity":1,"message":"338","line":146,"column":30,"nodeType":"339","messageId":"340","endLine":146,"endColumn":32},{"ruleId":"337","severity":1,"message":"357","line":147,"column":26,"nodeType":"339","messageId":"340","endLine":147,"endColumn":28},{"ruleId":"337","severity":1,"message":"357","line":147,"column":73,"nodeType":"339","messageId":"340","endLine":147,"endColumn":75},{"ruleId":"337","severity":1,"message":"338","line":225,"column":44,"nodeType":"339","messageId":"340","endLine":225,"endColumn":46},{"ruleId":"337","severity":1,"message":"338","line":229,"column":44,"nodeType":"339","messageId":"340","endLine":229,"endColumn":46},{"ruleId":"331","severity":1,"message":"358","line":234,"column":17,"nodeType":"333","messageId":"334","endLine":234,"endColumn":22},{"ruleId":"337","severity":1,"message":"338","line":299,"column":56,"nodeType":"339","messageId":"340","endLine":299,"endColumn":58},{"ruleId":"337","severity":1,"message":"338","line":302,"column":62,"nodeType":"339","messageId":"340","endLine":302,"endColumn":64},{"ruleId":"337","severity":1,"message":"338","line":309,"column":64,"nodeType":"339","messageId":"340","endLine":309,"endColumn":66},{"ruleId":"337","severity":1,"message":"338","line":344,"column":64,"nodeType":"339","messageId":"340","endLine":344,"endColumn":66},{"ruleId":"337","severity":1,"message":"357","line":430,"column":41,"nodeType":"339","messageId":"340","endLine":430,"endColumn":43},{"ruleId":"337","severity":1,"message":"357","line":436,"column":50,"nodeType":"339","messageId":"340","endLine":436,"endColumn":52},{"ruleId":"337","severity":1,"message":"338","line":460,"column":42,"nodeType":"339","messageId":"340","endLine":460,"endColumn":44},{"ruleId":"337","severity":1,"message":"338","line":469,"column":42,"nodeType":"339","messageId":"340","endLine":469,"endColumn":44},{"ruleId":"337","severity":1,"message":"338","line":478,"column":42,"nodeType":"339","messageId":"340","endLine":478,"endColumn":44},{"ruleId":"337","severity":1,"message":"338","line":488,"column":42,"nodeType":"339","messageId":"340","endLine":488,"endColumn":44},{"ruleId":"337","severity":1,"message":"338","line":498,"column":42,"nodeType":"339","messageId":"340","endLine":498,"endColumn":44},{"ruleId":"337","severity":1,"message":"338","line":510,"column":68,"nodeType":"339","messageId":"340","endLine":510,"endColumn":70},{"ruleId":"337","severity":1,"message":"338","line":544,"column":52,"nodeType":"339","messageId":"340","endLine":544,"endColumn":54},{"ruleId":"337","severity":1,"message":"357","line":555,"column":123,"nodeType":"339","messageId":"340","endLine":555,"endColumn":125},{"ruleId":"337","severity":1,"message":"338","line":566,"column":57,"nodeType":"339","messageId":"340","endLine":566,"endColumn":59},{"ruleId":"337","severity":1,"message":"338","line":592,"column":48,"nodeType":"339","messageId":"340","endLine":592,"endColumn":50},{"ruleId":"337","severity":1,"message":"357","line":596,"column":60,"nodeType":"339","messageId":"340","endLine":596,"endColumn":62},{"ruleId":"359","severity":1,"message":"360","line":602,"column":144,"nodeType":"339","messageId":"361","endLine":602,"endColumn":145},{"ruleId":"337","severity":1,"message":"338","line":631,"column":29,"nodeType":"339","messageId":"340","endLine":631,"endColumn":31},{"ruleId":"337","severity":1,"message":"357","line":639,"column":34,"nodeType":"339","messageId":"340","endLine":639,"endColumn":36},{"ruleId":"337","severity":1,"message":"338","line":683,"column":65,"nodeType":"339","messageId":"340","endLine":683,"endColumn":67},{"ruleId":"350","severity":1,"message":"351","line":742,"column":32,"nodeType":"352","messageId":"353","endLine":742,"endColumn":40,"fix":"362"},{"ruleId":"337","severity":1,"message":"357","line":755,"column":44,"nodeType":"339","messageId":"340","endLine":755,"endColumn":46},{"ruleId":"331","severity":1,"message":"363","line":756,"column":17,"nodeType":"333","messageId":"334","endLine":756,"endColumn":22},{"ruleId":"337","severity":1,"message":"357","line":769,"column":44,"nodeType":"339","messageId":"340","endLine":769,"endColumn":46},{"ruleId":"337","severity":1,"message":"357","line":772,"column":117,"nodeType":"339","messageId":"340","endLine":772,"endColumn":119},{"ruleId":"337","severity":1,"message":"338","line":805,"column":62,"nodeType":"339","messageId":"340","endLine":805,"endColumn":64},{"ruleId":"337","severity":1,"message":"338","line":825,"column":36,"nodeType":"339","messageId":"340","endLine":825,"endColumn":38},{"ruleId":"331","severity":1,"message":"364","line":836,"column":13,"nodeType":"333","messageId":"334","endLine":836,"endColumn":29},{"ruleId":"337","severity":1,"message":"338","line":892,"column":40,"nodeType":"339","messageId":"340","endLine":892,"endColumn":42},{"ruleId":"337","severity":1,"message":"357","line":915,"column":45,"nodeType":"339","messageId":"340","endLine":915,"endColumn":47},{"ruleId":"337","severity":1,"message":"338","line":932,"column":51,"nodeType":"339","messageId":"340","endLine":932,"endColumn":53},{"ruleId":"337","severity":1,"message":"338","line":949,"column":23,"nodeType":"339","messageId":"340","endLine":949,"endColumn":25},{"ruleId":"337","severity":1,"message":"357","line":950,"column":34,"nodeType":"339","messageId":"340","endLine":950,"endColumn":36},{"ruleId":"337","severity":1,"message":"338","line":952,"column":48,"nodeType":"339","messageId":"340","endLine":952,"endColumn":50},{"ruleId":"337","severity":1,"message":"357","line":984,"column":49,"nodeType":"339","messageId":"340","endLine":984,"endColumn":51},{"ruleId":"337","severity":1,"message":"338","line":989,"column":30,"nodeType":"339","messageId":"340","endLine":989,"endColumn":32},{"ruleId":"337","severity":1,"message":"338","line":998,"column":33,"nodeType":"339","messageId":"340","endLine":998,"endColumn":35},{"ruleId":"337","severity":1,"message":"338","line":1003,"column":20,"nodeType":"339","messageId":"340","endLine":1003,"endColumn":22},{"ruleId":"337","severity":1,"message":"338","line":1003,"column":47,"nodeType":"339","messageId":"340","endLine":1003,"endColumn":49},{"ruleId":"337","severity":1,"message":"357","line":1033,"column":45,"nodeType":"339","messageId":"340","endLine":1033,"endColumn":47},{"ruleId":"337","severity":1,"message":"338","line":1039,"column":21,"nodeType":"339","messageId":"340","endLine":1039,"endColumn":23},{"ruleId":"337","severity":1,"message":"357","line":1055,"column":45,"nodeType":"339","messageId":"340","endLine":1055,"endColumn":47},{"ruleId":"337","severity":1,"message":"338","line":1064,"column":45,"nodeType":"339","messageId":"340","endLine":1064,"endColumn":47},{"ruleId":"337","severity":1,"message":"338","line":1078,"column":21,"nodeType":"339","messageId":"340","endLine":1078,"endColumn":23},{"ruleId":"337","severity":1,"message":"338","line":1090,"column":41,"nodeType":"339","messageId":"340","endLine":1090,"endColumn":43},{"ruleId":"337","severity":1,"message":"338","line":1092,"column":127,"nodeType":"339","messageId":"340","endLine":1092,"endColumn":129},{"ruleId":"337","severity":1,"message":"338","line":1586,"column":63,"nodeType":"339","messageId":"340","endLine":1586,"endColumn":65},{"ruleId":"337","severity":1,"message":"338","line":1625,"column":40,"nodeType":"339","messageId":"340","endLine":1625,"endColumn":42},{"ruleId":"337","severity":1,"message":"338","line":1673,"column":23,"nodeType":"339","messageId":"340","endLine":1673,"endColumn":25},{"ruleId":"337","severity":1,"message":"338","line":1704,"column":21,"nodeType":"339","messageId":"340","endLine":1704,"endColumn":23},{"ruleId":"365","severity":1,"message":"366","line":1730,"column":9,"nodeType":"367","messageId":"368","endLine":1753,"endColumn":10},{"ruleId":"337","severity":1,"message":"338","line":1775,"column":71,"nodeType":"339","messageId":"340","endLine":1775,"endColumn":73},{"ruleId":"369","severity":1,"message":"370","line":1780,"column":33,"nodeType":"371","messageId":"340","endLine":1780,"endColumn":37},{"ruleId":"369","severity":1,"message":"370","line":1785,"column":31,"nodeType":"371","messageId":"340","endLine":1785,"endColumn":35},{"ruleId":"337","severity":1,"message":"338","line":1875,"column":57,"nodeType":"339","messageId":"340","endLine":1875,"endColumn":59},{"ruleId":"337","severity":1,"message":"338","line":1894,"column":36,"nodeType":"339","messageId":"340","endLine":1894,"endColumn":38},{"ruleId":"350","severity":1,"message":"351","line":1924,"column":28,"nodeType":"352","messageId":"353","endLine":1924,"endColumn":35,"fix":"372"},{"ruleId":"350","severity":1,"message":"351","line":1932,"column":32,"nodeType":"352","messageId":"353","endLine":1932,"endColumn":40,"fix":"373"},{"ruleId":"350","severity":1,"message":"351","line":1933,"column":37,"nodeType":"352","messageId":"353","endLine":1933,"endColumn":45,"fix":"374"},{"ruleId":"331","severity":1,"message":"375","line":2013,"column":15,"nodeType":"333","messageId":"334","endLine":2013,"endColumn":23},{"ruleId":"344","severity":1,"message":"345","line":184,"column":21,"nodeType":"343","endLine":184,"endColumn":124},{"ruleId":"344","severity":1,"message":"345","line":191,"column":17,"nodeType":"343","endLine":200,"endColumn":19},{"ruleId":"331","severity":1,"message":"376","line":3,"column":8,"nodeType":"333","messageId":"334","endLine":3,"endColumn":23},{"ruleId":"331","severity":1,"message":"349","line":5,"column":8,"nodeType":"333","messageId":"334","endLine":5,"endColumn":15},{"ruleId":"331","severity":1,"message":"377","line":10,"column":8,"nodeType":"333","messageId":"334","endLine":10,"endColumn":20},{"ruleId":"344","severity":1,"message":"345","line":93,"column":28,"nodeType":"343","endLine":93,"endColumn":81},{"ruleId":"337","severity":1,"message":"338","line":116,"column":74,"nodeType":"339","messageId":"340","endLine":116,"endColumn":76},{"ruleId":"337","severity":1,"message":"338","line":120,"column":74,"nodeType":"339","messageId":"340","endLine":120,"endColumn":76},{"ruleId":"337","severity":1,"message":"338","line":124,"column":74,"nodeType":"339","messageId":"340","endLine":124,"endColumn":76},{"ruleId":"337","severity":1,"message":"338","line":128,"column":74,"nodeType":"339","messageId":"340","endLine":128,"endColumn":76},{"ruleId":"344","severity":1,"message":"345","line":153,"column":13,"nodeType":"343","endLine":162,"endColumn":15},{"ruleId":"344","severity":1,"message":"345","line":163,"column":43,"nodeType":"343","endLine":163,"endColumn":95},{"ruleId":"344","severity":1,"message":"345","line":170,"column":13,"nodeType":"343","endLine":179,"endColumn":15},{"ruleId":"331","severity":1,"message":"378","line":200,"column":27,"nodeType":"333","messageId":"334","endLine":200,"endColumn":45},{"ruleId":"337","severity":1,"message":"338","line":209,"column":45,"nodeType":"339","messageId":"340","endLine":209,"endColumn":47},{"ruleId":"379","severity":1,"message":"380","line":11,"column":44,"nodeType":"381","messageId":"382","endLine":11,"endColumn":46},{"ruleId":"379","severity":1,"message":"380","line":11,"column":77,"nodeType":"381","messageId":"382","endLine":11,"endColumn":79},{"ruleId":"379","severity":1,"message":"380","line":12,"column":43,"nodeType":"381","messageId":"382","endLine":12,"endColumn":45},{"ruleId":"379","severity":1,"message":"380","line":12,"column":75,"nodeType":"381","messageId":"382","endLine":12,"endColumn":77},{"ruleId":"379","severity":1,"message":"380","line":14,"column":34,"nodeType":"381","messageId":"382","endLine":14,"endColumn":36},{"ruleId":"379","severity":1,"message":"380","line":14,"column":57,"nodeType":"381","messageId":"382","endLine":14,"endColumn":59},{"ruleId":"337","severity":1,"message":"357","line":24,"column":36,"nodeType":"339","messageId":"340","endLine":24,"endColumn":38},{"ruleId":"337","severity":1,"message":"357","line":31,"column":66,"nodeType":"339","messageId":"340","endLine":31,"endColumn":68},{"ruleId":"337","severity":1,"message":"338","line":105,"column":37,"nodeType":"339","messageId":"340","endLine":105,"endColumn":39},{"ruleId":"379","severity":1,"message":"380","line":42,"column":51,"nodeType":"381","messageId":"382","endLine":42,"endColumn":53},{"ruleId":"379","severity":1,"message":"380","line":42,"column":62,"nodeType":"381","messageId":"382","endLine":42,"endColumn":64},{"ruleId":"379","severity":1,"message":"380","line":43,"column":51,"nodeType":"381","messageId":"382","endLine":43,"endColumn":53},{"ruleId":"379","severity":1,"message":"380","line":43,"column":62,"nodeType":"381","messageId":"382","endLine":43,"endColumn":64},{"ruleId":"379","severity":1,"message":"380","line":44,"column":51,"nodeType":"381","messageId":"382","endLine":44,"endColumn":53},{"ruleId":"379","severity":1,"message":"380","line":44,"column":62,"nodeType":"381","messageId":"382","endLine":44,"endColumn":64},"no-native-reassign",["383"],"no-negated-in-lhs",["384"],"no-unused-vars","'PureComponent' is defined but never used.","Identifier","unusedVar","'Switch' is defined but never used.","'Route' is defined but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","jsx-a11y/anchor-is-valid","The href attribute requires a valid value to be accessible. Provide a valid, navigable address as the href value. If you cannot provide a valid href, but still need the element to resemble a link, use a button and change it with appropriate styles. Learn more: https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/anchor-is-valid.md","JSXOpeningElement","jsx-a11y/alt-text","img elements must have an alt prop, either with meaningful text, or an empty string for decorative images.","'icon' is assigned a value but never used.","'externalConfig' is defined but never used.","'Component' is defined but never used.","'actions' is defined but never used.","new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"385","text":"386"},{"range":"387","text":"386"},{"range":"388","text":"386"},"Expected '!==' and instead saw '!='.","'index' is assigned a value but never used.","no-useless-concat","Unexpected string concatenation of literals.","unexpectedConcat",{"range":"389","text":"386"},"'usage' is assigned a value but never used.","'CanvasesInColumn' is assigned a value but never used.","default-case","Expected a default case.","SwitchStatement","missingDefaultCase","no-eval","eval can be harmful.","CallExpression",{"range":"390","text":"386"},{"range":"391","text":"386"},{"range":"392","text":"386"},"'dtmLayer' is assigned a value but never used.","'WeaponDetection' is defined but never used.","'rosWebSocket' is defined but never used.","'INDOOR_EXPLORATION' is assigned a value but never used.","no-mixed-operators","Unexpected mix of '&&' and '||'.","LogicalExpression","unexpectedMixedOperator","no-global-assign","no-unsafe-negation",[2006,2006],"()",[2394,2394],[2443,2443],[36768,36768],[89498,89498],[89780,89780],[89838,89838]]